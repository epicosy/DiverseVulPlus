func,target,cwe,project_x,commit_id,hash,size,message_x,cve_id,vuln_id,cwe_id,score,summary,published_date,dataset,has_metadata,chain_len,project_y,chain,commit_href,patch,before_first_fix_commit,chain_ord_pos,last_fix_commit,commit_datetime,commit_sha,chain_ord,author,message_y,files,comments,stats,files_extension,language
"cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,
    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)
{
	const cdf_section_header_t *shp;
	cdf_section_header_t sh;
	const uint8_t *p, *q, *e;
	int16_t s16;
	int32_t s32;
	uint32_t u32;
	int64_t s64;
	uint64_t u64;
	cdf_timestamp_t tp;
	size_t i, o, o4, nelements, j;
	cdf_property_info_t *inp;

	if (offs > UINT32_MAX / 4) {
		errno = EFTYPE;
		goto out;
	}
	shp = CAST(const cdf_section_header_t *, (const void *)
	    ((const char *)sst->sst_tab + offs));
	if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)
		goto out;
	sh.sh_len = CDF_TOLE4(shp->sh_len);
#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)
	if (sh.sh_len > CDF_SHLEN_LIMIT) {
		errno = EFTYPE;
		goto out;
	}
	sh.sh_properties = CDF_TOLE4(shp->sh_properties);
#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))
	if (sh.sh_properties > CDF_PROP_LIMIT)
		goto out;
	DPRINTF((""section len: %u properties %u\n"", sh.sh_len,
	    sh.sh_properties));
	if (*maxcount) {
		if (*maxcount > CDF_PROP_LIMIT)
			goto out;
		*maxcount += sh.sh_properties;
		inp = CAST(cdf_property_info_t *,
		    realloc(*info, *maxcount * sizeof(*inp)));
	} else {
		*maxcount = sh.sh_properties;
		inp = CAST(cdf_property_info_t *,
		    malloc(*maxcount * sizeof(*inp)));
	}
	if (inp == NULL)
		goto out;
	*info = inp;
	inp += *count;
	*count += sh.sh_properties;
	p = CAST(const uint8_t *, (const void *)
	    ((const char *)(const void *)sst->sst_tab +
	    offs + sizeof(sh)));
	e = CAST(const uint8_t *, (const void *)
	    (((const char *)(const void *)shp) + sh.sh_len));
	if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)
		goto out;
	for (i = 0; i < sh.sh_properties; i++) {
		size_t ofs = CDF_GETUINT32(p, (i << 1) + 1);
		q = (const uint8_t *)(const void *)
		    ((const char *)(const void *)p + ofs
		    - 2 * sizeof(uint32_t));
		if (q > e) {
			DPRINTF((""Ran of the end %p > %p\n"", q, e));
			goto out;
		}
		inp[i].pi_id = CDF_GETUINT32(p, i << 1);
		inp[i].pi_type = CDF_GETUINT32(q, 0);
		DPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\n"",
		    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));
		if (inp[i].pi_type & CDF_VECTOR) {
			nelements = CDF_GETUINT32(q, 1);
			o = 2;
		} else {
			nelements = 1;
			o = 1;
		}
		o4 = o * sizeof(uint32_t);
		if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))
			goto unknown;
		switch (inp[i].pi_type & CDF_TYPEMASK) {
		case CDF_NULL:
		case CDF_EMPTY:
			break;
		case CDF_SIGNED16:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&s16, &q[o4], sizeof(s16));
			inp[i].pi_s16 = CDF_TOLE2(s16);
			break;
		case CDF_SIGNED32:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&s32, &q[o4], sizeof(s32));
			inp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);
			break;
		case CDF_BOOL:
		case CDF_UNSIGNED32:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u32, &q[o4], sizeof(u32));
			inp[i].pi_u32 = CDF_TOLE4(u32);
			break;
		case CDF_SIGNED64:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&s64, &q[o4], sizeof(s64));
			inp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);
			break;
		case CDF_UNSIGNED64:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u64, &q[o4], sizeof(u64));
			inp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);
			break;
		case CDF_FLOAT:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u32, &q[o4], sizeof(u32));
			u32 = CDF_TOLE4(u32);
			memcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));
			break;
		case CDF_DOUBLE:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u64, &q[o4], sizeof(u64));
			u64 = CDF_TOLE8((uint64_t)u64);
			memcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));
			break;
		case CDF_LENGTH32_STRING:
		case CDF_LENGTH32_WSTRING:
			if (nelements > 1) {
				size_t nelem = inp - *info;
				if (*maxcount > CDF_PROP_LIMIT
				    || nelements > CDF_PROP_LIMIT)
					goto out;
				*maxcount += nelements;
				inp = CAST(cdf_property_info_t *,
				    realloc(*info, *maxcount * sizeof(*inp)));
				if (inp == NULL)
					goto out;
				*info = inp;
				inp = *info + nelem;
			}
			DPRINTF((""nelements = %"" SIZE_T_FORMAT ""u\n"",
			    nelements));
			for (j = 0; j < nelements; j++, i++) {
				uint32_t l = CDF_GETUINT32(q, o);
				inp[i].pi_str.s_len = l;
				inp[i].pi_str.s_buf = (const char *)
				    (const void *)(&q[o4 + sizeof(l)]);
				DPRINTF((""l = %d, r = %"" SIZE_T_FORMAT
				    ""u, s = %s\n"", l,
				    CDF_ROUND(l, sizeof(l)),
				    inp[i].pi_str.s_buf));
				if (l & 1)
					l++;
				o += l >> 1;
				if (q + o >= e)
					goto out;
				o4 = o * sizeof(uint32_t);
			}
			i--;
			break;
		case CDF_FILETIME:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&tp, &q[o4], sizeof(tp));
			inp[i].pi_tp = CDF_TOLE8((uint64_t)tp);
			break;
		case CDF_CLIPBOARD:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			break;
		default:
		unknown:
			DPRINTF((""Don't know how to deal with %x\n"",
			    inp[i].pi_type));
			break;
		}
	}
	return 0;
out:
	free(*info);
	return -1;
}",1,"['CWE-119', 'CWE-787']",file,f97486ef5dc3e8735440edc4fc8808c63e1a3ef0,258776487316015398296342004874121420046,187,"CVE-2014-0207: Prevent 0 element vectors and vectors longer than the number
of properties from accessing random memory.",CVE-2014-0207,CVE-2014-0207,{'CWE-119'},2.9,"The cdf_read_short_sector function in cdf.c in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, allows remote attackers to cause a denial of service (assertion failure and application exit) via a crafted CDF file.",2014-07-09,NVD,0.0,1.0,https://github.com/file/file,{'https://github.com/file/file/commit/6d209c1c489457397a5763bca4b28e43aac90391'},https://github.com/file/file/commit/6d209c1c489457397a5763bca4b28e43aac90391,SINGLE,['aa45cb543a1c46a569a1922bb7912905cc7e03a1'],1,6d209c1c489457397a5763bca4b28e43aac90391,"05/05/2014, 16:11:21",6d209c1c489457397a5763bca4b28e43aac90391,['6d209c1c489457397a5763bca4b28e43aac90391'],Christos Zoulas,"Apply patches from file-CVE-2012-1571.patch
From Francisco Alonso Espejo:
    file < 5.18/git version can be made to crash when checking some
    corrupt CDF files (Using an invalid cdf_read_short_sector size)
    The problem I found here, is that in most situations (if
    h_short_sec_size_p2 > 8) because the blocksize is 512 and normal
    values are 06 which means reading 64 bytes.As long as the check
    for the block size copy is not checked properly (there's an assert
    that makes wrong/invalid assumptions)","{'src/cdf.c': {'additions': 3, 'deletions': 3, 'changes': 6, 'status': 'modified', 'raw_url': 'https://github.com/file/file/raw/6d209c1c489457397a5763bca4b28e43aac90391/src%2Fcdf.c', 'patch': '@@ -35,7 +35,7 @@\n #include ""file.h""\n \n #ifndef lint\n-FILE_RCSID(""@(#)$File: cdf.c,v 1.54 2014/02/25 20:52:02 christos Exp $"")\n+FILE_RCSID(""@(#)$File: cdf.c,v 1.55 2014/02/27 23:26:17 christos Exp $"")\n #endif\n \n #include <assert.h>\n@@ -352,10 +352,10 @@ cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n \tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n \tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n \tassert(ss == len);\n-\tif (pos > CDF_SEC_SIZE(h) * sst->sst_len) {\n+\tif (pos + len > CDF_SEC_SIZE(h) * sst->sst_len) {\n \t\tDPRINTF((""Out of bounds read %"" SIZE_T_FORMAT ""u > %""\n \t\t    SIZE_T_FORMAT ""u\\n"",\n-\t\t    pos, CDF_SEC_SIZE(h) * sst->sst_len));\n+\t\t    pos + len, CDF_SEC_SIZE(h) * sst->sst_len));\n \t\treturn -1;\n \t}\n \t(void)memcpy(((char *)buf) + offs,'}, 'src/readcdf.c': {'additions': 15, 'deletions': 14, 'changes': 29, 'status': 'modified', 'raw_url': 'https://github.com/file/file/raw/6d209c1c489457397a5763bca4b28e43aac90391/src%2Freadcdf.c', 'patch': '@@ -26,7 +26,7 @@\n #include ""file.h""\n \n #ifndef lint\n-FILE_RCSID(""@(#)$File: readcdf.c,v 1.39 2014/02/27 23:26:18 christos Exp $"")\n+FILE_RCSID(""@(#)$File: readcdf.c,v 1.40 2014/03/06 15:23:33 christos Exp $"")\n #endif\n \n #include <assert.h>\n@@ -120,7 +120,7 @@ cdf_app_to_mime(const char *vbuf, const struct nv *nv)\n \n private int\n cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n-    size_t count, const uint64_t clsid[2])\n+    size_t count, const cdf_directory_t *root_storage)\n {\n         size_t i;\n         cdf_timestamp_t tp;\n@@ -130,8 +130,8 @@ cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n         const char *s;\n         int len;\n \n-        if (!NOTMIME(ms))\n-\t\tstr = cdf_clsid_to_mime(clsid, clsid2mime);\n+        if (!NOTMIME(ms) && root_storage)\n+\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2mime);\n \n         for (i = 0; i < count; i++) {\n                 cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n@@ -236,7 +236,7 @@ cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n \n private int\n cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n-    const cdf_stream_t *sst, const uint64_t clsid[2])\n+    const cdf_stream_t *sst, const cdf_directory_t *root_storage)\n {\n         cdf_summary_info_header_t si;\n         cdf_property_info_t *info;\n@@ -276,13 +276,15 @@ cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n                                 return -2;\n                         break;\n                 }\n-\t\tstr = cdf_clsid_to_mime(clsid, clsid2desc);\n-\t\tif (str)\n-                        if (file_printf(ms, "", %s"", str) == -1)\n-\t\t\t\treturn -2;\n-        }\n+\t\tif (root_storage) {\n+\t\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2desc);\n+\t\t\tif (str)\n+\t\t\t\tif (file_printf(ms, "", %s"", str) == -1)\n+\t\t\t\t\treturn -2;\n+\t\t\t}\n+\t\t}\n \n-        m = cdf_file_property_info(ms, info, count, clsid);\n+        m = cdf_file_property_info(ms, info, count, root_storage);\n         free(info);\n \n         return m == -1 ? -2 : m;\n@@ -381,9 +383,8 @@ file_trycdf(struct magic_set *ms, int fd, const unsigned char *buf,\n #ifdef CDF_DEBUG\n         cdf_dump_summary_info(&h, &scn);\n #endif\n-        if ((i = cdf_file_summary_info(ms, &h, &scn,\n-\t    root_storage->d_storage_uuid)) < 0)\n-                expn = ""Can\'t expand summary_info"";\n+        if ((i = cdf_file_summary_info(ms, &h, &scn, root_storage)) < 0)\n+            expn = ""Can\'t expand summary_info"";\n \n \tif (i == 0) {\n \t\tconst char *str = NULL;'}}",,"{'additions': 18, 'deletions': 17, 'total': 35}",{'c'},{'C/C++'}
"static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
{
	jas_tvparser_t *tvp;
	mif_cmpt_t *cmpt;
	int id;

	cmpt = 0;
	tvp = 0;

	if (!(cmpt = mif_cmpt_create())) {
		goto error;
	}
	cmpt->tlx = 0;
	cmpt->tly = 0;
	cmpt->sampperx = 0;
	cmpt->samppery = 0;
	cmpt->width = 0;
	cmpt->height = 0;
	cmpt->prec = 0;
	cmpt->sgnd = -1;
	cmpt->data = 0;

	if (!(tvp = jas_tvparser_create(buf))) {
		goto error;
	}
	while (!(id = jas_tvparser_next(tvp))) {
		switch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,
		  jas_tvparser_gettag(tvp)))->id) {
		case MIF_TLX:
			cmpt->tlx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_TLY:
			cmpt->tly = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_WIDTH:
			cmpt->width = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HEIGHT:
			cmpt->height = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HSAMP:
			cmpt->sampperx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_VSAMP:
			cmpt->samppery = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_PREC:
			cmpt->prec = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_SGND:
			cmpt->sgnd = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_DATA:
			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
				return -1;
			}
			break;
		}
	}
	jas_tvparser_destroy(tvp);
	if (!cmpt->sampperx || !cmpt->samppery) {
		goto error;
	}
	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
		goto error;
	}
	return 0;

error:
	if (cmpt) {
		mif_cmpt_destroy(cmpt);
	}
	if (tvp) {
		jas_tvparser_destroy(tvp);
	}
	return -1;
}",1,['CWE-416'],jasper,df5d2867e8004e51e18b89865bc4aa69229227b3,291215968342278820707548139132976181607,77,CVE-2015-5221,CVE-2015-5221,CVE-2015-5221,{'CWE-416'},2.9,Use-after-free vulnerability in the mif_process_cmpt function in libjasper/mif/mif_cod.c in the JasPer JPEG-2000 library before 1.900.2 allows remote attackers to cause a denial of service (crash) via a crafted JPEG 2000 image file.,2017-07-25,NVD,0.0,1.0,https://github.com/mdadams/jasper,{'https://github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3'},https://github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3,SINGLE,['b13b8c86be870107f83b0a9a4b77557cb2b65d69'],1,df5d2867e8004e51e18b89865bc4aa69229227b3,"09/19/2016, 09:03:36",df5d2867e8004e51e18b89865bc4aa69229227b3,['df5d2867e8004e51e18b89865bc4aa69229227b3'],Richard Hughes,CVE-2015-5221,"{'src/libjasper/mif/mif_cod.c': {'additions': 1, 'deletions': 1, 'changes': 2, 'status': 'modified', 'raw_url': 'https://github.com/jasper-software/jasper/raw/df5d2867e8004e51e18b89865bc4aa69229227b3/src%2Flibjasper%2Fmif%2Fmif_cod.c', 'patch': '@@ -570,13 +570,13 @@ static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n \t\t\tbreak;\n \t\t}\n \t}\n-\tjas_tvparser_destroy(tvp);\n \tif (!cmpt->sampperx || !cmpt->samppery) {\n \t\tgoto error;\n \t}\n \tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n \t\tgoto error;\n \t}\n+\tjas_tvparser_destroy(tvp);\n \treturn 0;\n \n error:'}}",,"{'additions': 1, 'deletions': 1, 'total': 2}",{'c'},{'C/C++'}
"static int rename_in_ns(int pid, char *oldname, char **newnamep)
{
	int fd = -1, ofd = -1, ret, ifindex = -1;
	bool grab_newname = false;

	ofd = lxc_preserve_ns(getpid(), ""net"");
	if (ofd < 0) {
		fprintf(stderr, ""Failed opening network namespace path for '%d'."", getpid());
		return -1;
	}

	fd = lxc_preserve_ns(pid, ""net"");
	if (fd < 0) {
		fprintf(stderr, ""Failed opening network namespace path for '%d'."", pid);
		return -1;
	}

	if (setns(fd, 0) < 0) {
		fprintf(stderr, ""setns to container network namespace\n"");
		goto out_err;
	}
	close(fd); fd = -1;
	if (!*newnamep) {
		grab_newname = true;
		*newnamep = VETH_DEF_NAME;
		if (!(ifindex = if_nametoindex(oldname))) {
			fprintf(stderr, ""failed to get netdev index\n"");
			goto out_err;
		}
	}
	if ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {
		fprintf(stderr, ""Error %d renaming netdev %s to %s in container\n"", ret, oldname, *newnamep);
		goto out_err;
	}
	if (grab_newname) {
		char ifname[IFNAMSIZ], *namep = ifname;
		if (!if_indextoname(ifindex, namep)) {
			fprintf(stderr, ""Failed to get new netdev name\n"");
			goto out_err;
		}
		*newnamep = strdup(namep);
		if (!*newnamep)
			goto out_err;
	}
	if (setns(ofd, 0) < 0) {
		fprintf(stderr, ""Error returning to original netns\n"");
		close(ofd);
		return -1;
	}
	close(ofd);

	return 0;

out_err:
	if (ofd >= 0)
		close(ofd);
	if (setns(ofd, 0) < 0)
		fprintf(stderr, ""Error returning to original network namespace\n"");
	if (fd >= 0)
		close(fd);
	return -1;
}",1,"['CWE-284', 'CWE-862']",lxc,16af238036a5464ae8f2420ed3af214f0de875f9,325759591118093570721283619308594794531,62,"CVE-2017-5985: Ensure target netns is caller-owned

Before this commit, lxc-user-nic could potentially have been tricked into
operating on a network namespace over which the caller did not hold privilege.

This commit ensures that the caller is privileged over the network namespace by
temporarily dropping privilege.

Launchpad: https://bugs.launchpad.net/ubuntu/+source/lxc/+bug/1654676
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>",CVE-2017-5985,CVE-2017-5985,{'CWE-862'},2.9,lxc-user-nic in Linux Containers (LXC) allows local users with a lxc-usernet allocation to create network interfaces on the host and choose the name of those interfaces by leveraging lack of netns ownership check.,2017-03-14,NVD,0.0,1.0,https://github.com/lxc/lxc,{'https://github.com/lxc/lxc/commit/16af238036a5464ae8f2420ed3af214f0de875f9'},https://github.com/lxc/lxc/commit/16af238036a5464ae8f2420ed3af214f0de875f9,SINGLE,['7c583068cec23911de4b1edbbc4e1e3f41f44155'],1,16af238036a5464ae8f2420ed3af214f0de875f9,"01/28/2017, 12:02:34",16af238036a5464ae8f2420ed3af214f0de875f9,['16af238036a5464ae8f2420ed3af214f0de875f9'],Christian Brauner,"CVE-2017-5985: Ensure target netns is caller-owned

Before this commit, lxc-user-nic could potentially have been tricked into
operating on a network namespace over which the caller did not hold privilege.

This commit ensures that the caller is privileged over the network namespace by
temporarily dropping privilege.

Launchpad: https://bugs.launchpad.net/ubuntu/+source/lxc/+bug/1654676
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>","{'src/lxc/lxc_user_nic.c': {'additions': 87, 'deletions': 32, 'changes': 119, 'status': 'modified', 'raw_url': 'https://github.com/lxc/lxc/raw/16af238036a5464ae8f2420ed3af214f0de875f9/src%2Flxc%2Flxc_user_nic.c', 'patch': '@@ -50,6 +50,14 @@\n #include ""utils.h""\n #include ""network.h""\n \n+#define usernic_debug_stream(stream, format, ...)                              \\\n+\tdo {                                                                   \\\n+\t\tfprintf(stream, ""%s: %d: %s: "" format, __FILE__, __LINE__,     \\\n+\t\t\t__func__, __VA_ARGS__);                                \\\n+\t} while (false)\n+\n+#define usernic_error(format, ...) usernic_debug_stream(stderr, format, __VA_ARGS__)\n+\n static void usage(char *me, bool fail)\n {\n \tfprintf(stderr, ""Usage: %s lxcpath name pid type bridge nicname\\n"", me);\n@@ -670,68 +678,115 @@ static bool create_db_dir(char *fnam)\n }\n \n #define VETH_DEF_NAME ""eth%d""\n-\n static int rename_in_ns(int pid, char *oldname, char **newnamep)\n {\n-\tint fd = -1, ofd = -1, ret, ifindex = -1;\n+\tuid_t ruid, suid, euid;\n+\tint fret = -1;\n+\tint fd = -1, ifindex = -1, ofd = -1, ret;\n \tbool grab_newname = false;\n \n \tofd = lxc_preserve_ns(getpid(), ""net"");\n \tif (ofd < 0) {\n-\t\tfprintf(stderr, ""Failed opening network namespace path for \'%d\'."", getpid());\n-\t\treturn -1;\n+\t\tusernic_error(""Failed opening network namespace path for \'%d\'."", getpid());\n+\t\treturn fret;\n \t}\n \n \tfd = lxc_preserve_ns(pid, ""net"");\n \tif (fd < 0) {\n-\t\tfprintf(stderr, ""Failed opening network namespace path for \'%d\'."", pid);\n-\t\treturn -1;\n+\t\tusernic_error(""Failed opening network namespace path for \'%d\'."", pid);\n+\t\tgoto do_partial_cleanup;\n+\t}\n+\n+\tret = getresuid(&ruid, &euid, &suid);\n+\tif (ret < 0) {\n+\t\tusernic_error(""Failed to retrieve real, effective, and saved ""\n+\t\t\t      ""user IDs: %s\\n"",\n+\t\t\t      strerror(errno));\n+\t\tgoto do_partial_cleanup;\n+\t}\n+\n+\tret = setns(fd, CLONE_NEWNET);\n+\tclose(fd);\n+\tfd = -1;\n+\tif (ret < 0) {\n+\t\tusernic_error(""Failed to setns() to the network namespace of ""\n+\t\t\t      ""the container with PID %d: %s.\\n"",\n+\t\t\t      pid, strerror(errno));\n+\t\tgoto do_partial_cleanup;\n \t}\n \n-\tif (setns(fd, 0) < 0) {\n-\t\tfprintf(stderr, ""setns to container network namespace\\n"");\n-\t\tgoto out_err;\n+\tret = setresuid(ruid, ruid, 0);\n+\tif (ret < 0) {\n+\t\tusernic_error(""Failed to drop privilege by setting effective ""\n+\t\t\t      ""user id and real user id to %d, and saved user ""\n+\t\t\t      ""ID to 0: %s.\\n"",\n+\t\t\t      ruid, strerror(errno));\n+\t\t// COMMENT(brauner): It\'s ok to jump to do_full_cleanup here\n+\t\t// since setresuid() will succeed when trying to set real,\n+\t\t// effective, and saved to values they currently have.\n+\t\tgoto do_full_cleanup;\n \t}\n-\tclose(fd); fd = -1;\n+\n \tif (!*newnamep) {\n \t\tgrab_newname = true;\n \t\t*newnamep = VETH_DEF_NAME;\n-\t\tif (!(ifindex = if_nametoindex(oldname))) {\n-\t\t\tfprintf(stderr, ""failed to get netdev index\\n"");\n-\t\t\tgoto out_err;\n+\n+\t\tifindex = if_nametoindex(oldname);\n+\t\tif (!ifindex) {\n+\t\t\tusernic_error(""Failed to get netdev index: %s.\\n"", strerror(errno));\n+\t\t\tgoto do_full_cleanup;\n \t\t}\n \t}\n-\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n-\t\tfprintf(stderr, ""Error %d renaming netdev %s to %s in container\\n"", ret, oldname, *newnamep);\n-\t\tgoto out_err;\n+\n+\tret = lxc_netdev_rename_by_name(oldname, *newnamep);\n+\tif (ret < 0) {\n+\t\tusernic_error(""Error %d renaming netdev %s to %s in container.\\n"", ret, oldname, *newnamep);\n+\t\tgoto do_full_cleanup;\n \t}\n+\n \tif (grab_newname) {\n-\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n+\t\tchar ifname[IFNAMSIZ];\n+\t\tchar *namep = ifname;\n+\n \t\tif (!if_indextoname(ifindex, namep)) {\n-\t\t\tfprintf(stderr, ""Failed to get new netdev name\\n"");\n-\t\t\tgoto out_err;\n+\t\t\tusernic_error(""Failed to get new netdev name: %s.\\n"", strerror(errno));\n+\t\t\tgoto do_full_cleanup;\n \t\t}\n+\n \t\t*newnamep = strdup(namep);\n \t\tif (!*newnamep)\n-\t\t\tgoto out_err;\n+\t\t\tgoto do_full_cleanup;\n \t}\n-\tif (setns(ofd, 0) < 0) {\n-\t\tfprintf(stderr, ""Error returning to original netns\\n"");\n-\t\tclose(ofd);\n-\t\treturn -1;\n+\n+\tfret = 0;\n+\n+do_full_cleanup:\n+\tret = setresuid(ruid, euid, suid);\n+\tif (ret < 0) {\n+\t\tusernic_error(""Failed to restore privilege by setting effective ""\n+\t\t\t      ""user id to %d, real user id to %d, and saved user ""\n+\t\t\t      ""ID to %d: %s.\\n"",\n+\t\t\t      ruid, euid, suid, strerror(errno));\n+\t\tfret = -1;\n+\t\t// COMMENT(brauner): setns() should fail if setresuid() doesn\'t\n+\t\t// succeed but there\'s no harm in falling through; keeps the\n+\t\t// code cleaner.\n \t}\n-\tclose(ofd);\n \n-\treturn 0;\n+\tret = setns(ofd, CLONE_NEWNET);\n+\tif (ret < 0) {\n+\t\tusernic_error(""Failed to setns() to original network namespace ""\n+\t\t\t      ""of PID %d: %s.\\n"",\n+\t\t\t      ofd, strerror(errno));\n+\t\tfret = -1;\n+\t}\n \n-out_err:\n-\tif (ofd >= 0)\n-\t\tclose(ofd);\n-\tif (setns(ofd, 0) < 0)\n-\t\tfprintf(stderr, ""Error returning to original network namespace\\n"");\n+do_partial_cleanup:\n \tif (fd >= 0)\n \t\tclose(fd);\n-\treturn -1;\n+\tclose(ofd);\n+\n+\treturn fret;\n }\n \n /*'}}",,"{'additions': 87, 'deletions': 32, 'total': 119}",{'c'},{'C/C++'}
"ctcompare(const char *a,		/* I - First string */
          const char *b)		/* I - Second string */
{
  int	result = 0;			/* Result */


  while (*a && *b)
  {
    result |= *a ^ *b;
    a ++;
    b ++;
  }

  return (result);
}",1,['CWE-284'],cups,0bc9dc4658c26920a3f66da7dd234be463ca572e,39715001571456723900086525845394192958,15,CVE-2022-26691: An incorrect comparison in local admin authentication,CVE-2022-26691,CVE-2022-26691,{'CWE-269'},10.0,"A logic issue was addressed with improved state management. This issue is fixed in Security Update 2022-003 Catalina, macOS Monterey 12.3, macOS Big Sur 11.6.5. An application may be able to gain elevated privileges.",2022-05-26,NVD,0.0,1.0,https://github.com/OpenPrinting/cups,{'https://github.com/OpenPrinting/cups/commit/de4f8c196106033e4c372dce3e91b9d42b0b9444'},https://github.com/OpenPrinting/cups/commit/de4f8c196106033e4c372dce3e91b9d42b0b9444,SINGLE,['498fd9f580a514a6e4fa3b469cbdf5bb38d4d625'],1,de4f8c196106033e4c372dce3e91b9d42b0b9444,"05/26/2022, 04:27:04",de4f8c196106033e4c372dce3e91b9d42b0b9444,['de4f8c196106033e4c372dce3e91b9d42b0b9444'],Zdenek Dohnal,"scheduler/cert.c: Fix string comparison (fixes CVE-2022-26691)

The previous algorithm didn't expect the strings can have a different
length, so one string can be a substring of the other and such substring
was reported as equal to the longer string.","{'CHANGES.md': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/OpenPrinting/cups/raw/de4f8c196106033e4c372dce3e91b9d42b0b9444/CHANGES.md', 'patch': '@@ -4,6 +4,7 @@ CHANGES - OpenPrinting CUPS 2.4.1 - 2022-01-27\n Changes in CUPS v2.4.2 (TBA)\n ----------------------------\n \n+- Fixed certificate strings comparison for Local authorization (CVE-2022-26691)\n - The `cupsFileOpen` function no longer opens files for append in read-write\n   mode (Issue #291)\n - The cupsd daemon removed processing temporary queue (Issue #364)'}, 'scheduler/cert.c': {'additions': 8, 'deletions': 1, 'changes': 9, 'status': 'modified', 'raw_url': 'https://github.com/OpenPrinting/cups/raw/de4f8c196106033e4c372dce3e91b9d42b0b9444/scheduler%2Fcert.c', 'patch': ""@@ -444,5 +444,12 @@ ctcompare(const char *a,\t\t/* I - First string */\n     b ++;\n   }\n \n-  return (result);\n+ /*\n+  * The while loop finishes when *a == '\\0' or *b == '\\0'\n+  * so after the while loop either both *a and *b == '\\0',\n+  * or one points inside a string, so when we apply logical OR on *a,\n+  * *b and result, we get a non-zero return value if the compared strings don't match.\n+  */\n+\n+  return (result | *a | *b);\n }""}}",,"{'additions': 9, 'deletions': 1, 'total': 10}","{'c', 'md'}",{'C/C++'}
"ns_nprint(netdissect_options *ndo,
          register const u_char *cp, register const u_char *bp)
{
	register u_int i, l;
	register const u_char *rp = NULL;
	register int compress = 0;
	int chars_processed;
	int elt;
	int data_size = ndo->ndo_snapend - bp;

	if ((l = labellen(ndo, cp)) == (u_int)-1)
		return(NULL);
	if (!ND_TTEST2(*cp, 1))
		return(NULL);
	chars_processed = 1;
	if (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {
		compress = 0;
		rp = cp + l;
	}

	if (i != 0)
		while (i && cp < ndo->ndo_snapend) {
			if ((i & INDIR_MASK) == INDIR_MASK) {
				if (!compress) {
					rp = cp + 1;
					compress = 1;
				}
				if (!ND_TTEST2(*cp, 1))
					return(NULL);
				cp = bp + (((i << 8) | *cp) & 0x3fff);
				if ((l = labellen(ndo, cp)) == (u_int)-1)
					return(NULL);
				if (!ND_TTEST2(*cp, 1))
					return(NULL);
				i = *cp++;
				chars_processed++;

				/*
				 * If we've looked at every character in
				 * the message, this pointer will make
				 * us look at some character again,
				 * which means we're looping.
				 */
				if (chars_processed >= data_size) {
					ND_PRINT((ndo, ""<LOOP>""));
					return (NULL);
				}
				continue;
			}
			if ((i & INDIR_MASK) == EDNS0_MASK) {
				elt = (i & ~INDIR_MASK);
				switch(elt) {
				case EDNS0_ELT_BITLABEL:
					if (blabel_print(ndo, cp) == NULL)
						return (NULL);
					break;
				default:
					/* unknown ELT */
					ND_PRINT((ndo, ""<ELT %d>"", elt));
					return(NULL);
				}
			} else {
				if (fn_printn(ndo, cp, l, ndo->ndo_snapend))
					return(NULL);
			}

			cp += l;
			chars_processed += l;
			ND_PRINT((ndo, "".""));
			if ((l = labellen(ndo, cp)) == (u_int)-1)
				return(NULL);
			if (!ND_TTEST2(*cp, 1))
				return(NULL);
			i = *cp++;
			chars_processed++;
			if (!compress)
				rp += l + 1;
		}
	else
		ND_PRINT((ndo, "".""));
	return (rp);
}",1,"['CWE-399', 'CWE-835']",tcpdump,3a76fd7c95fced2c2f8c8148a9055c3a542eff29,128281638820492277906995516701829193173,82,"CVE-2017-12995/Check for DNS compression pointers that don't point backwards.

This is what BIND 9.11.0-P2 does; it not only detects pointers that
loop, as ""point backwards"" means ""point before anything we've processed
so far, including what we're processing right now"", so the pointer can't
point to itself (as that's what we're processing right now).

This fixes an infinite loop discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomäki.

Add a test using the capture file supplied by the reporter(s).

Also, add some infinite-pointer-loop captures.

More checks should be done.  We might, for example, want to make sure
the upper 2 bits of the label length/pointer byte are 00 or 11, and that
if we encounter a pointer and jump backwards to what we think is a label
the label ends before the beginning of the last label we processed, to
make sure the pointer doesn't point backwards into the *middle* of a
label, and also make sure the entire name is <= 255 bytes long.",CVE-2017-12995,CVE-2017-12995,{'CWE-835'},2.9,The DNS parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-domain.c:ns_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/3a76fd7c95fced2c2f8c8148a9055c3a542eff29'},https://github.com/the-tcpdump-group/tcpdump/commit/3a76fd7c95fced2c2f8c8148a9055c3a542eff29,SINGLE,['866c60236c41cea1e1654c8a071897292f64be49'],1,3a76fd7c95fced2c2f8c8148a9055c3a542eff29,"02/11/2017, 02:52:17",3a76fd7c95fced2c2f8c8148a9055c3a542eff29,['3a76fd7c95fced2c2f8c8148a9055c3a542eff29'],Guy Harris,"CVE-2017-12995/Check for DNS compression pointers that don't point backwards.

This is what BIND 9.11.0-P2 does; it not only detects pointers that
loop, as ""point backwards"" means ""point before anything we've processed
so far, including what we're processing right now"", so the pointer can't
point to itself (as that's what we're processing right now).

This fixes an infinite loop discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomäki.

Add a test using the capture file supplied by the reporter(s).

Also, add some infinite-pointer-loop captures.

More checks should be done.  We might, for example, want to make sure
the upper 2 bits of the label length/pointer byte are 00 or 11, and that
if we encounter a pointer and jump backwards to what we think is a label
the label ends before the beginning of the last label we processed, to
make sure the pointer doesn't point backwards into the *middle* of a
label, and also make sure the entire name is <= 255 bytes long.","{'print-domain.c': {'additions': 19, 'deletions': 18, 'changes': 37, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/print-domain.c', 'patch': '@@ -151,15 +151,14 @@ ns_nprint(netdissect_options *ndo,\n \tregister u_int i, l;\n \tregister const u_char *rp = NULL;\n \tregister int compress = 0;\n-\tint chars_processed;\n \tint elt;\n-\tint data_size = ndo->ndo_snapend - bp;\n+\tu_int offset, max_offset;\n \n \tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\treturn(NULL);\n \tif (!ND_TTEST2(*cp, 1))\n \t\treturn(NULL);\n-\tchars_processed = 1;\n+\tmax_offset = (u_int)(cp - bp);\n \tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n \t\tcompress = 0;\n \t\trp = cp + l;\n@@ -174,24 +173,28 @@ ns_nprint(netdissect_options *ndo,\n \t\t\t\t}\n \t\t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\t\treturn(NULL);\n-\t\t\t\tcp = bp + (((i << 8) | *cp) & 0x3fff);\n+\t\t\t\toffset = (((i << 8) | *cp) & 0x3fff);\n+\t\t\t\t/*\n+\t\t\t\t * This must move backwards in the packet.\n+\t\t\t\t * No RFC explicitly says that, but BIND\'s\n+\t\t\t\t * name decompression code requires it,\n+\t\t\t\t * as a way of preventing infinite loops\n+\t\t\t\t * and other bad behavior, and it\'s probably\n+\t\t\t\t * what was intended (compress by pointing\n+\t\t\t\t * to domain name suffixes already seen in\n+\t\t\t\t * the packet).\n+\t\t\t\t */\n+\t\t\t\tif (offset >= max_offset) {\n+\t\t\t\t\tND_PRINT((ndo, ""<BAD PTR>""));\n+\t\t\t\t\treturn(NULL);\n+\t\t\t\t}\n+\t\t\t\tmax_offset = offset;\n+\t\t\t\tcp = bp + offset;\n \t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\t\t\t\treturn(NULL);\n \t\t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\t\treturn(NULL);\n \t\t\t\ti = *cp++;\n-\t\t\t\tchars_processed++;\n-\n-\t\t\t\t/*\n-\t\t\t\t * If we\'ve looked at every character in\n-\t\t\t\t * the message, this pointer will make\n-\t\t\t\t * us look at some character again,\n-\t\t\t\t * which means we\'re looping.\n-\t\t\t\t */\n-\t\t\t\tif (chars_processed >= data_size) {\n-\t\t\t\t\tND_PRINT((ndo, ""<LOOP>""));\n-\t\t\t\t\treturn (NULL);\n-\t\t\t\t}\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n@@ -212,14 +215,12 @@ ns_nprint(netdissect_options *ndo,\n \t\t\t}\n \n \t\t\tcp += l;\n-\t\t\tchars_processed += l;\n \t\t\tND_PRINT((ndo, "".""));\n \t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\t\t\treturn(NULL);\n \t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\treturn(NULL);\n \t\t\ti = *cp++;\n-\t\t\tchars_processed++;\n \t\t\tif (!compress)\n \t\t\t\trp += l + 1;\n \t\t}'}, 'tests/TESTLIST': {'additions': 9, 'deletions': 0, 'changes': 9, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests%2FTESTLIST', 'patch': '@@ -474,6 +474,7 @@ zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n+dns_fwdptr\t\tdns_fwdptr.pcap\t\t\tdns_fwdptr.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap\n@@ -483,3 +484,11 @@ rtp-seg-fault-2  rtp-seg-fault-2.pcap  rtp-seg-fault-2.out  -v -T rtp\n # NFS tests\n # fuzzed pcap\n nfs-seg-fault-1  nfs-seg-fault-1.pcap  nfs-seg-fault-1.out\n+\n+# DNS infinite loop tests\n+#\n+# See http://marc.info/?l=tcpdump-workers&m=95552439022555\n+#\n+dns-zlip-1\t\tdns-zlip-1.pcap\t\tdns-zlip-1.out\n+dns-zlip-2\t\tdns-zlip-2.pcap\t\tdns-zlip-2.out\n+dns-zlip-3\t\tdns-zlip-3.pcap\t\tdns-zlip-3.out'}, 'tests/dns-zlip-1.out': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests%2Fdns-zlip-1.out', 'patch': '@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 60777 Type49159 (Class 49168)? <BAD PTR>[|domain]'}, 'tests/dns-zlip-1.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests%2Fdns-zlip-1.pcap', 'patch': None}, 'tests/dns-zlip-2.out': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests%2Fdns-zlip-2.out', 'patch': '@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 18992 Type49164 (Class 49168)? <BAD PTR>[|domain]'}, 'tests/dns-zlip-2.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests%2Fdns-zlip-2.pcap', 'patch': None}, 'tests/dns-zlip-3.out': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests%2Fdns-zlip-3.out', 'patch': '@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 65483 Type49164 (Class 49164)? thisleetostringwillcrashyourlittlenameserverforsurehahahahahah.<BAD PTR>[|domain]'}, 'tests/dns-zlip-3.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests%2Fdns-zlip-3.pcap', 'patch': None}, 'tests/dns_fwdptr.out': {'additions': 2, 'deletions': 0, 'changes': 2, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests%2Fdns_fwdptr.out', 'patch': '@@ -0,0 +1,2 @@\n+be:af:ca:ce:ff:ff > de:ad:be:ef:00:01, ethertype IPv4 (0x0800), length 63207: (tos 0x0, ttl 128, id 36039, offset 0, flags [none], proto UDP (17), length 63193)\n+    156.118.17.235.53 > 156.118.27.229.500: [udp sum ok] 51584 zoneRef NoChange*|$ [64259q] q: Type507 (Class 769)? M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{ .M-{^C^A.<BAD PTR>[|domain]'}, 'tests/dns_fwdptr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3a76fd7c95fced2c2f8c8148a9055c3a542eff29/tests%2Fdns_fwdptr.pcap', 'patch': None}}",,"{'additions': 33, 'deletions': 18, 'total': 51}","{'c', 'pcap', 'out'}",{'C/C++'}
"mobility_opt_print(netdissect_options *ndo,
                   const u_char *bp, const unsigned len)
{
	unsigned i, optlen;

	for (i = 0; i < len; i += optlen) {
		ND_TCHECK(bp[i]);
		if (bp[i] == IP6MOPT_PAD1)
			optlen = 1;
		else {
			if (i + 1 < len) {
				ND_TCHECK(bp[i + 1]);
				optlen = bp[i + 1] + 2;
			}
			else
				goto trunc;
		}
		if (i + optlen > len)
			goto trunc;
		ND_TCHECK(bp[i + optlen]);

		switch (bp[i]) {
		case IP6MOPT_PAD1:
			ND_PRINT((ndo, ""(pad1)""));
			break;
		case IP6MOPT_PADN:
			if (len - i < IP6MOPT_MINLEN) {
				ND_PRINT((ndo, ""(padn: trunc)""));
				goto trunc;
			}
			ND_PRINT((ndo, ""(padn)""));
			break;
		case IP6MOPT_REFRESH:
			if (len - i < IP6MOPT_REFRESH_MINLEN) {
				ND_PRINT((ndo, ""(refresh: trunc)""));
				goto trunc;
			}
			/* units of 4 secs */
			ND_PRINT((ndo, ""(refresh: %u)"",
				EXTRACT_16BITS(&bp[i+2]) << 2));
			break;
		case IP6MOPT_ALTCOA:
			if (len - i < IP6MOPT_ALTCOA_MINLEN) {
				ND_PRINT((ndo, ""(altcoa: trunc)""));
				goto trunc;
			}
			ND_PRINT((ndo, ""(alt-CoA: %s)"", ip6addr_string(ndo, &bp[i+2])));
			break;
		case IP6MOPT_NONCEID:
			if (len - i < IP6MOPT_NONCEID_MINLEN) {
				ND_PRINT((ndo, ""(ni: trunc)""));
				goto trunc;
			}
			ND_PRINT((ndo, ""(ni: ho=0x%04x co=0x%04x)"",
				EXTRACT_16BITS(&bp[i+2]),
				EXTRACT_16BITS(&bp[i+4])));
			break;
		case IP6MOPT_AUTH:
			if (len - i < IP6MOPT_AUTH_MINLEN) {
				ND_PRINT((ndo, ""(auth: trunc)""));
				goto trunc;
			}
			ND_PRINT((ndo, ""(auth)""));
			break;
		default:
			if (len - i < IP6MOPT_MINLEN) {
				ND_PRINT((ndo, ""(sopt_type %u: trunc)"", bp[i]));
				goto trunc;
			}
			ND_PRINT((ndo, ""(type-0x%02x: len=%u)"", bp[i], bp[i + 1]));
			break;
		}
	}
	return 0;

trunc:
	return 1;
}",1,"['CWE-125', 'CWE-787']",tcpdump,b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,29038185424840314376808343974397208502,78,"CVE-2017-13023/IPv6 mobility: Add a bounds check before fetching data

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't cause 'tcpdump: pcap_loop: truncated dump file'",CVE-2017-13023,CVE-2017-13023,{'CWE-125'},6.4,The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_opt_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00'},https://github.com/the-tcpdump-group/tcpdump/commit/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,SINGLE,['eee0b04bcfdae319c242b0b8fc3d07029ee65b8c'],1,b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,"03/22/2017, 15:08:25",b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,['b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00'],Francois-Xavier Le Bail,"CVE-2017-13023/IPv6 mobility: Add a bounds check before fetching data

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't cause 'tcpdump: pcap_loop: truncated dump file'","{'print-mobility.c': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00/print-mobility.c', 'patch': '@@ -150,6 +150,7 @@ mobility_opt_print(netdissect_options *ndo,\n \t\t\t\tgoto trunc;\n \t\t\t}\n \t\t\t/* units of 4 secs */\n+\t\t\tND_TCHECK_16BITS(&bp[i+2]);\n \t\t\tND_PRINT((ndo, ""(refresh: %u)"",\n \t\t\t\tEXTRACT_16BITS(&bp[i+2]) << 2));\n \t\t\tbreak;'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00/tests%2FTESTLIST', 'patch': '@@ -524,6 +524,7 @@ pgm_opts_asan_2\t\tpgm_opts_asan_2.pcap\t\tpgm_opts_asan_2.out\t-v\n vtp_asan\t\tvtp_asan.pcap\t\t\tvtp_asan.out\t-v\n icmp6_mobileprefix_asan\ticmp6_mobileprefix_asan.pcap\ticmp6_mobileprefix_asan.out\t-v\n ip_printroute_asan\tip_printroute_asan.pcap\t\tip_printroute_asan.out\t-v\n+mobility_opt_asan\tmobility_opt_asan.pcap\t\tmobility_opt_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap'}, 'tests/mobility_opt_asan.out': {'additions': 2, 'deletions': 0, 'changes': 2, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00/tests%2Fmobility_opt_asan.out', 'patch': '@@ -0,0 +1,2 @@\n+IP6 (class 0x50, flowlabel 0x00004, hlim 0, next-header Mobile IP (old) (62) payload length: 7168) d400:7fa1:0:400::6238:2949 > 9675:86dd:7300:2c:1c7f:ffff:ffc3:b2a1: mobility: BU seq#=116 A lifetime=15872(pad1)[|MOBILITY]\n+IP6 (class 0x50, flowlabel 0x00004, hlim 0, next-header Mobile IP (old) (62) payload length: 7168) d4c3:b2a1:200:400::6238:2949 > 9675:86dd:73f0:2c:1c7f:ffff:ebc3:b291: mobility: BU seq#=116 A lifetime=15360[|MOBILITY]'}, 'tests/mobility_opt_asan.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00/tests%2Fmobility_opt_asan.pcap', 'patch': None}}",,"{'additions': 4, 'deletions': 0, 'total': 4}","{'c', 'pcap', 'out'}",{'C/C++'}
"void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,
                                                    uint8_t hash_buffer[EVP_MAX_MD_SIZE],
                                                    unsigned hash_length) {
  int rc;

  // Hash all the settings that affect whether the server will allow/accept
  // the client connection. This ensures that the client is always validated against
  // the correct settings, even if session resumption across different listeners
  // is enabled.
  if (ca_cert_ != nullptr) {
    rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);
    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));
    RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,
                   fmt::format(""invalid SHA256 hash length {}"", hash_length));

    rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);
    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));
  }

  for (const auto& hash : verify_certificate_hash_list_) {
    rc = EVP_DigestUpdate(md.get(), hash.data(),
                          hash.size() *
                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));
    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));
  }

  for (const auto& hash : verify_certificate_spki_list_) {
    rc = EVP_DigestUpdate(md.get(), hash.data(),
                          hash.size() *
                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));
    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));
  }
}",1,"['CWE-362', 'CWE-295']",envoy,e9f936d85dc1edc34fabd0a1725ec180f2316353,67659419293076123709338539213514573993,33,"CVE-2022-21654

tls allows re-use when some cert validation settings have changed

Signed-off-by: Yan Avlasov <yavlasov@google.com>",CVE-2022-21654,CVE-2022-21654,{'CWE-295'},6.4,"Envoy is an open source edge and service proxy, designed for cloud-native applications. Envoy's tls allows re-use when some cert validation settings have changed from their default configuration. The only workaround for this issue is to ensure that default tls settings are used. Users are advised to upgrade.",2022-02-22,NVD,0.0,1.0,https://github.com/envoyproxy/envoy,{'https://github.com/envoyproxy/envoy/commit/e9f936d85dc1edc34fabd0a1725ec180f2316353'},https://github.com/envoyproxy/envoy/commit/e9f936d85dc1edc34fabd0a1725ec180f2316353,SINGLE,['9371333230b1a6e1be2eccf4868771e11af6253a'],1,e9f936d85dc1edc34fabd0a1725ec180f2316353,"02/01/2022, 19:57:15",e9f936d85dc1edc34fabd0a1725ec180f2316353,['e9f936d85dc1edc34fabd0a1725ec180f2316353'],Yan Avlasov,"CVE-2022-21654

tls allows re-use when some cert validation settings have changed

Signed-off-by: Yan Avlasov <yavlasov@google.com>","{'envoy/ssl/certificate_validation_context_config.h': {'additions': 5, 'deletions': 0, 'changes': 5, 'status': 'modified', 'raw_url': 'https://github.com/envoyproxy/envoy/raw/e9f936d85dc1edc34fabd0a1725ec180f2316353/envoy%2Fssl%2Fcertificate_validation_context_config.h', 'patch': '@@ -15,6 +15,11 @@\n namespace Envoy {\n namespace Ssl {\n \n+// SECURITY NOTE\n+//\n+// When adding or changing this interface, it is likely that a change is needed to\n+// `DefaultCertValidator::updateDigestForSessionId` in\n+// `source/extensions/transport_sockets/tls/cert_validator/default_validator.cc`.\n class CertificateValidationContextConfig {\n public:\n   virtual ~CertificateValidationContextConfig() = default;'}, 'source/extensions/transport_sockets/tls/cert_validator/cert_validator.h': {'additions': 4, 'deletions': 1, 'changes': 5, 'status': 'modified', 'raw_url': 'https://github.com/envoyproxy/envoy/raw/e9f936d85dc1edc34fabd0a1725ec180f2316353/source%2Fextensions%2Ftransport_sockets%2Ftls%2Fcert_validator%2Fcert_validator.h', 'patch': '@@ -62,7 +62,10 @@ class CertValidator {\n                                     bool handshaker_provides_certificates) PURE;\n \n   /**\n-   * Called when calculation hash for session context ids\n+   * Called when calculation hash for session context ids. This hash MUST include all\n+   * configuration used to validate a peer certificate, so that if this configuration\n+   * is changed, sessions cannot be re-used and must be re-negotiated and re-validated\n+   * using the new settings.\n    *\n    * @param md the store context\n    * @param hash_buffer the buffer used for digest calculation'}, 'source/extensions/transport_sockets/tls/cert_validator/default_validator.cc': {'additions': 29, 'deletions': 0, 'changes': 29, 'status': 'modified', 'raw_url': 'https://github.com/envoyproxy/envoy/raw/e9f936d85dc1edc34fabd0a1725ec180f2316353/source%2Fextensions%2Ftransport_sockets%2Ftls%2Fcert_validator%2Fdefault_validator.cc', 'patch': '@@ -378,6 +378,35 @@ void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                               sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n     RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));\n   }\n+\n+  rc = EVP_DigestUpdate(md.get(), &verify_trusted_ca_, sizeof(verify_trusted_ca_));\n+  RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));\n+\n+  if (config_ != nullptr) {\n+    for (const auto& matcher : config_->subjectAltNameMatchers()) {\n+      size_t hash = MessageUtil::hash(matcher);\n+      rc = EVP_DigestUpdate(md.get(), &hash, sizeof(hash));\n+      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));\n+    }\n+\n+    const std::string& crl = config_->certificateRevocationList();\n+    if (!crl.empty()) {\n+      rc = EVP_DigestUpdate(md.get(), crl.data(), crl.length());\n+      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));\n+    }\n+\n+    bool allow_expired = config_->allowExpiredCertificate();\n+    rc = EVP_DigestUpdate(md.get(), &allow_expired, sizeof(allow_expired));\n+    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));\n+\n+    auto trust_chain_verification = config_->trustChainVerification();\n+    rc = EVP_DigestUpdate(md.get(), &trust_chain_verification, sizeof(trust_chain_verification));\n+    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));\n+\n+    auto only_leaf_crl = config_->onlyVerifyLeafCertificateCrl();\n+    rc = EVP_DigestUpdate(md.get(), &only_leaf_crl, sizeof(only_leaf_crl));\n+    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(""""));\n+  }\n }\n \n void DefaultCertValidator::addClientValidationContext(SSL_CTX* ctx, bool require_client_cert) {'}, 'test/extensions/transport_sockets/tls/ssl_socket_test.cc': {'additions': 158, 'deletions': 0, 'changes': 158, 'status': 'modified', 'raw_url': 'https://github.com/envoyproxy/envoy/raw/e9f936d85dc1edc34fabd0a1725ec180f2316353/test%2Fextensions%2Ftransport_sockets%2Ftls%2Fssl_socket_test.cc', 'patch': '@@ -3373,6 +3373,164 @@ TEST_P(SslSocketTest, TicketSessionResumptionDifferentServerNames) {\n                               client_ctx_yaml, false, GetParam());\n }\n \n+// Sessions cannot be resumed even though the server certificates are the same,\n+// because of the different `verify_certificate_hash` settings.\n+TEST_P(SslSocketTest, TicketSessionResumptionDifferentVerifyCertHash) {\n+  const std::string server_ctx_yaml1 = absl::StrCat(R""EOF(\n+  session_ticket_keys:\n+    keys:\n+      filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a""\n+  common_tls_context:\n+    tls_certificates:\n+      certificate_chain:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem""\n+      private_key:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem""\n+    validation_context:\n+      trusted_ca:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem""\n+      verify_certificate_hash:\n+        - "")EOF"",\n+                                                    TEST_SAN_URI_CERT_256_HASH, ""\\"""");\n+\n+  const std::string server_ctx_yaml2 = absl::StrCat(R""EOF(\n+  session_ticket_keys:\n+    keys:\n+      filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a""\n+  common_tls_context:\n+    tls_certificates:\n+      certificate_chain:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem""\n+      private_key:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem""\n+    validation_context:\n+      trusted_ca:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem""\n+      verify_certificate_hash:\n+        - ""0000000000000000000000000000000000000000000000000000000000000000""\n+        - "")EOF"",\n+                                                    TEST_SAN_URI_CERT_256_HASH, ""\\"""");\n+\n+  const std::string client_ctx_yaml = R""EOF(\n+  common_tls_context:\n+    tls_certificates:\n+      certificate_chain:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem""\n+      private_key:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem""\n+)EOF"";\n+\n+  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml1, {}, client_ctx_yaml, true,\n+                              GetParam());\n+  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, false,\n+                              GetParam());\n+}\n+\n+// Sessions cannot be resumed even though the server certificates are the same,\n+// because of the different `verify_certificate_spki` settings.\n+TEST_P(SslSocketTest, TicketSessionResumptionDifferentVerifyCertSpki) {\n+  const std::string server_ctx_yaml1 = absl::StrCat(R""EOF(\n+  session_ticket_keys:\n+    keys:\n+      filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a""\n+  common_tls_context:\n+    tls_certificates:\n+      certificate_chain:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem""\n+      private_key:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem""\n+    validation_context:\n+      trusted_ca:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem""\n+      verify_certificate_spki:\n+        - "")EOF"",\n+                                                    TEST_SAN_URI_CERT_SPKI, ""\\"""");\n+\n+  const std::string server_ctx_yaml2 = absl::StrCat(R""EOF(\n+  session_ticket_keys:\n+    keys:\n+      filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a""\n+  common_tls_context:\n+    tls_certificates:\n+      certificate_chain:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem""\n+      private_key:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem""\n+    validation_context:\n+      trusted_ca:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem""\n+      verify_certificate_spki:\n+        - ""NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=""\n+        - "")EOF"",\n+                                                    TEST_SAN_URI_CERT_SPKI, ""\\"""");\n+\n+  const std::string client_ctx_yaml = R""EOF(\n+  common_tls_context:\n+    tls_certificates:\n+      certificate_chain:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem""\n+      private_key:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem""\n+)EOF"";\n+\n+  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml1, {}, client_ctx_yaml, true,\n+                              GetParam());\n+  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, false,\n+                              GetParam());\n+}\n+\n+// Sessions cannot be resumed even though the server certificates are the same,\n+// because of the different `match_subject_alt_names` settings.\n+TEST_P(SslSocketTest, TicketSessionResumptionDifferentMatchSAN) {\n+  const std::string server_ctx_yaml1 = R""EOF(\n+  session_ticket_keys:\n+    keys:\n+      filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a""\n+  common_tls_context:\n+    tls_certificates:\n+      certificate_chain:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem""\n+      private_key:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem""\n+    validation_context:\n+      trusted_ca:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem""\n+      match_subject_alt_names:\n+        - exact: ""spiffe://lyft.com/test-team""\n+)EOF"";\n+\n+  const std::string server_ctx_yaml2 = R""EOF(\n+  session_ticket_keys:\n+    keys:\n+      filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a""\n+  common_tls_context:\n+    tls_certificates:\n+      certificate_chain:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem""\n+      private_key:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem""\n+    validation_context:\n+      trusted_ca:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem""\n+      match_subject_alt_names:\n+        - prefix: ""spiffe://lyft.com/test-team""\n+"")EOF"";\n+\n+  const std::string client_ctx_yaml = R""EOF(\n+  common_tls_context:\n+    tls_certificates:\n+      certificate_chain:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem""\n+      private_key:\n+        filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem""\n+)EOF"";\n+\n+  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml1, {}, client_ctx_yaml, true,\n+                              GetParam());\n+  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, false,\n+                              GetParam());\n+}\n+\n // Sessions can be resumed because the server certificates are different but the CN/SANs and\n // issuer are identical\n TEST_P(SslSocketTest, TicketSessionResumptionDifferentServerCert) {'}}",,"{'additions': 196, 'deletions': 1, 'total': 197}","{'cc', 'h'}",{'C/C++'}
"name_len(netdissect_options *ndo,
         const unsigned char *s, const unsigned char *maxbuf)
{
    const unsigned char *s0 = s;
    unsigned char c;

    if (s >= maxbuf)
	return(-1);	/* name goes past the end of the buffer */
    ND_TCHECK2(*s, 1);
    c = *s;
    if ((c & 0xC0) == 0xC0)
	return(2);
    while (*s) {
	if (s >= maxbuf)
	    return(-1);	/* name goes past the end of the buffer */
	ND_TCHECK2(*s, 1);
	s += (*s) + 1;
    }
    return(PTR_DIFF(s, s0) + 1);

trunc:
    return(-1);	/* name goes past the end of the buffer */
}",1,['CWE-125'],tcpdump,6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45,334193635907625069853697591185349798179,23,"CVE-2017-12893/SMB/CIFS: Add a bounds check in name_len().

After we advance the pointer by the length value in the buffer, make
sure it points to something in the captured data.

This fixes a buffer over-read discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomäki.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-12893,CVE-2017-12893,{'CWE-125'},6.4,The SMB/CIFS parser in tcpdump before 4.9.2 has a buffer over-read in smbutil.c:name_len().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45'},https://github.com/the-tcpdump-group/tcpdump/commit/6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45,SINGLE,['c6e0531b5def26ecf912e8de6ade86cbdaed3751'],1,6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45,"02/04/2017, 00:56:57",6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45,['6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45'],Guy Harris,"CVE-2017-12893/SMB/CIFS: Add a bounds check in name_len().

After we advance the pointer by the length value in the buffer, make
sure it points to something in the captured data.

This fixes a buffer over-read discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomäki.

Add a test using the capture file supplied by the reporter(s).","{'smbutil.c': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45/smbutil.c', 'patch': '@@ -237,6 +237,7 @@ name_len(netdissect_options *ndo,\n \t    return(-1);\t/* name goes past the end of the buffer */\n \tND_TCHECK2(*s, 1);\n \ts += (*s) + 1;\n+\tND_TCHECK2(*s, 1);\n     }\n     return(PTR_DIFF(s, s0) + 1);'}, 'tests/TESTLIST': {'additions': 3, 'deletions': 0, 'changes': 3, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45/tests%2FTESTLIST', 'patch': '@@ -449,6 +449,9 @@ decnet-oobr\t\tdecnet-oobr.pcap\t\tdecnet-oobr.out\n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve\n \n+# bad packets from Otto Airamo and Antti Levomäki\n+nbns-valgrind\t\tnbns-valgrind.pcap\t\tnbns-valgrind.out\t-vvv -e\n+\n # RTP tests\n # fuzzed pcap\n rtp-seg-fault-1  rtp-seg-fault-1.pcap  rtp-seg-fault-1.out  -v -T rtp'}, 'tests/nbns-valgrind.out': {'additions': 16, 'deletions': 0, 'changes': 16, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45/tests%2Fnbns-valgrind.out', 'patch': '@@ -0,0 +1,16 @@\n+00:0c:85:0e:a5:ff > 00:00:0c:07:ac:f0, ethertype IPv4 (0x0800), length 92: (tos 0x0, ttl 127, id 38615, offset 0, flags [none], proto UDP (17), length 78)\n+    10.49.248.228.137 > 10.48.161.241.137: \n+>>> NBT UDP PACKET(137): QUERY; REQUEST; UNICAST\n+TrnID=0x8D40\n+OpCode=0\n+NmFlags=0x10\n+Rcode=0\n+QueryCount=1\n+AnswerCount=0\n+AuthorityCount=0\n+AddressRecCount=0\n+QuestionRecords:\n+Name=\n+WARNING: Short packet. Try increasing the snap length\n+\n+'}, 'tests/nbns-valgrind.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45/tests%2Fnbns-valgrind.pcap', 'patch': None}}",,"{'additions': 20, 'deletions': 0, 'total': 20}","{'c', 'pcap', 'out'}",{'C/C++'}
"aodv_extension(netdissect_options *ndo,
               const struct aodv_ext *ep, u_int length)
{
	const struct aodv_hello *ah;

	switch (ep->type) {
	case AODV_EXT_HELLO:
		ah = (const struct aodv_hello *)(const void *)ep;
		ND_TCHECK(*ah);
		if (length < sizeof(struct aodv_hello))
			goto trunc;
		ND_PRINT((ndo, ""\n\text HELLO %ld ms"",
		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
		break;

	default:
		ND_PRINT((ndo, ""\n\text %u %u"", ep->type, ep->length));
		break;
	}
	return;

trunc:
	ND_PRINT((ndo, "" [|hello]""));
}",1,"['CWE-125', 'CWE-787']",tcpdump,cbddb98484ea8ec1deece351abd56e063d775b38,216064145652669885179481173946753170001,24,"CVE-2017-13002/AODV: Add some missing bounds checks.

In aodv_extension() do a bounds check on the extension header before we
look at it.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add a test using the capture file supplied by the reporter(s).

While we're at it, add the RFC number, and check the validity of the
length for the Hello extension.",CVE-2017-13002,CVE-2017-13002,{'CWE-125'},6.4,The AODV parser in tcpdump before 4.9.2 has a buffer over-read in print-aodv.c:aodv_extension().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/cbddb98484ea8ec1deece351abd56e063d775b38'},https://github.com/the-tcpdump-group/tcpdump/commit/cbddb98484ea8ec1deece351abd56e063d775b38,SINGLE,['7a923447fd49a069a0fd3b6c3547438ab5ee2123'],1,cbddb98484ea8ec1deece351abd56e063d775b38,"02/19/2017, 22:19:32",cbddb98484ea8ec1deece351abd56e063d775b38,['cbddb98484ea8ec1deece351abd56e063d775b38'],Guy Harris,"CVE-2017-13002/AODV: Add some missing bounds checks.

In aodv_extension() do a bounds check on the extension header before we
look at it.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add a test using the capture file supplied by the reporter(s).

While we're at it, add the RFC number, and check the validity of the
length for the Hello extension.","{'print-aodv.c': {'additions': 8, 'deletions': 1, 'changes': 9, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/cbddb98484ea8ec1deece351abd56e063d775b38/print-aodv.c', 'patch': '@@ -42,7 +42,9 @@\n #include ""addrtoname.h""\n #include ""extract.h""\n \n-\n+/*\n+ * RFC 3561\n+ */\n struct aodv_rreq {\n \tuint8_t\t\trreq_type;\t/* AODV message type (1) */\n \tuint8_t\t\trreq_flags;\t/* various flags */\n@@ -178,12 +180,17 @@ aodv_extension(netdissect_options *ndo,\n {\n \tconst struct aodv_hello *ah;\n \n+\tND_TCHECK(*ep);\n \tswitch (ep->type) {\n \tcase AODV_EXT_HELLO:\n \t\tah = (const struct aodv_hello *)(const void *)ep;\n \t\tND_TCHECK(*ah);\n \t\tif (length < sizeof(struct aodv_hello))\n \t\t\tgoto trunc;\n+\t\tif (ep->length < 4) {\n+\t\t\tND_PRINT((ndo, ""\\n\\text HELLO - bad length %u"", ep->length));\n+\t\t\tbreak;\n+\t\t}\n \t\tND_PRINT((ndo, ""\\n\\text HELLO %ld ms"",\n \t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n \t\tbreak;'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/cbddb98484ea8ec1deece351abd56e063d775b38/tests%2FTESTLIST', 'patch': '@@ -459,6 +459,7 @@ hoobr_chdlc_print\thoobr_chdlc_print.pcap\t\thoobr_chdlc_print.out\n hoobr_lookup_nsap\thoobr_lookup_nsap.pcap\t\thoobr_lookup_nsap.out\n hoobr_rt6_print\t\thoobr_rt6_print.pcap\t\thoobr_rt6_print.out\n hoobr_nfs_printfh\thoobr_nfs_printfh.pcap\t\thoobr_nfs_printfh.out\n+hoobr_aodv_extension\thoobr_aodv_extension.pcap\thoobr_aodv_extension.out\n \n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve'}, 'tests/hoobr_aodv_extension.out': {'additions': 2, 'deletions': 0, 'changes': 2, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/cbddb98484ea8ec1deece351abd56e063d775b38/tests%2Fhoobr_aodv_extension.out', 'patch': '@@ -0,0 +1,2 @@\n+IP 48.48.48.48.654 > 48.48.48.48.12336:  aodv rrep 12308  prefix 16 hops 48\n+\tdst 48.48.48.48 dseq 808464432 src 48.48.48.48 808464432 ms [|hello]'}, 'tests/hoobr_aodv_extension.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/cbddb98484ea8ec1deece351abd56e063d775b38/tests%2Fhoobr_aodv_extension.pcap', 'patch': None}}",,"{'additions': 11, 'deletions': 1, 'total': 12}","{'c', 'pcap', 'out'}",{'C/C++'}
"parse_elements(netdissect_options *ndo,
               struct mgmt_body_t *pbody, const u_char *p, int offset,
               u_int length)
{
	u_int elementlen;
	struct ssid_t ssid;
	struct challenge_t challenge;
	struct rates_t rates;
	struct ds_t ds;
	struct cf_t cf;
	struct tim_t tim;

	/*
	 * We haven't seen any elements yet.
	 */
	pbody->challenge_present = 0;
	pbody->ssid_present = 0;
	pbody->rates_present = 0;
	pbody->ds_present = 0;
	pbody->cf_present = 0;
	pbody->tim_present = 0;

	while (length != 0) {
		/* Make sure we at least have the element ID and length. */
		if (!ND_TTEST2(*(p + offset), 2))
			return 0;
		if (length < 2)
			return 0;
		elementlen = *(p + offset + 1);

		/* Make sure we have the entire element. */
		if (!ND_TTEST2(*(p + offset + 2), elementlen))
			return 0;
		if (length < elementlen + 2)
			return 0;

		switch (*(p + offset)) {
		case E_SSID:
			memcpy(&ssid, p + offset, 2);
			offset += 2;
			length -= 2;
			if (ssid.length != 0) {
				if (ssid.length > sizeof(ssid.ssid) - 1)
					return 0;
				if (!ND_TTEST2(*(p + offset), ssid.length))
					return 0;
				if (length < ssid.length)
					return 0;
				memcpy(&ssid.ssid, p + offset, ssid.length);
				offset += ssid.length;
				length -= ssid.length;
			}
			ssid.ssid[ssid.length] = '\0';
			/*
			 * Present and not truncated.
			 *
			 * If we haven't already seen an SSID IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 */
			if (!pbody->ssid_present) {
				pbody->ssid = ssid;
				pbody->ssid_present = 1;
			}
			break;
		case E_CHALLENGE:
			memcpy(&challenge, p + offset, 2);
			offset += 2;
			length -= 2;
			if (challenge.length != 0) {
				if (challenge.length >
				    sizeof(challenge.text) - 1)
					return 0;
				if (!ND_TTEST2(*(p + offset), challenge.length))
					return 0;
				if (length < challenge.length)
					return 0;
				memcpy(&challenge.text, p + offset,
				    challenge.length);
				offset += challenge.length;
				length -= challenge.length;
			}
			challenge.text[challenge.length] = '\0';
			/*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a challenge IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 */
			if (!pbody->challenge_present) {
				pbody->challenge = challenge;
				pbody->challenge_present = 1;
			}
			break;
		case E_RATES:
			memcpy(&rates, p + offset, 2);
			offset += 2;
			length -= 2;
			if (rates.length != 0) {
				if (rates.length > sizeof rates.rate)
					return 0;
				if (!ND_TTEST2(*(p + offset), rates.length))
					return 0;
				if (length < rates.length)
					return 0;
				memcpy(&rates.rate, p + offset, rates.length);
				offset += rates.length;
				length -= rates.length;
			}
			/*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a rates IE,
			 * copy this one if it's not zero-length,
			 * otherwise ignore this one, so we later
			 * report the first one we saw.
			 *
			 * We ignore zero-length rates IEs as some
			 * devices seem to put a zero-length rates
			 * IE, followed by an SSID IE, followed by
			 * a non-zero-length rates IE into frames,
			 * even though IEEE Std 802.11-2007 doesn't
			 * seem to indicate that a zero-length rates
			 * IE is valid.
			 */
			if (!pbody->rates_present && rates.length != 0) {
				pbody->rates = rates;
				pbody->rates_present = 1;
			}
			break;
		case E_DS:
			memcpy(&ds, p + offset, 2);
			offset += 2;
			length -= 2;
			if (ds.length != 1) {
				offset += ds.length;
				length -= ds.length;
				break;
			}
			ds.channel = *(p + offset);
			offset += 1;
			length -= 1;
			/*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a DS IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 */
			if (!pbody->ds_present) {
				pbody->ds = ds;
				pbody->ds_present = 1;
			}
			break;
		case E_CF:
			memcpy(&cf, p + offset, 2);
			offset += 2;
			length -= 2;
			if (cf.length != 6) {
				offset += cf.length;
				length -= cf.length;
				break;
			}
			memcpy(&cf.count, p + offset, 6);
			offset += 6;
			length -= 6;
			/*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a CF IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 */
			if (!pbody->cf_present) {
				pbody->cf = cf;
				pbody->cf_present = 1;
			}
			break;
		case E_TIM:
			memcpy(&tim, p + offset, 2);
			offset += 2;
			length -= 2;
			if (tim.length <= 3) {
				offset += tim.length;
				length -= tim.length;
				break;
			}
			if (tim.length - 3 > (int)sizeof tim.bitmap)
				return 0;
			memcpy(&tim.count, p + offset, 3);
			offset += 3;
			length -= 3;

			memcpy(tim.bitmap, p + offset + 3, tim.length - 3);
			offset += tim.length - 3;
			length -= tim.length - 3;
			/*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a TIM IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 */
			if (!pbody->tim_present) {
				pbody->tim = tim;
				pbody->tim_present = 1;
			}
			break;
		default:
#if 0
			ND_PRINT((ndo, ""(1) unhandled element_id (%d)  "",
			    *(p + offset)));
#endif
			offset += 2 + elementlen;
			length -= 2 + elementlen;
			break;
		}
	}

	/* No problems found. */
	return 1;
}",1,"['CWE-125', 'CWE-787']",tcpdump,5edf405d7ed9fc92f4f43e8a3d44baa4c6387562,123349842969196371328609288964025035106,223,"CVE-2017-13008/IEEE 802.11: Fix TIM bitmap copy to copy from p + offset.

offset has already been advanced to point to the bitmap; we shouldn't
add the amount to advance again.

This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.

Add a test using the capture file supplied by the reporter(s).

While we're at it, remove some redundant tests - we've already checked,
before the case statement, whether we have captured the entire
information element and whether the entire information element is
present in the on-the-wire packet; in the cases for particular IEs, we
only need to make sure we don't go past the end of the IE.",CVE-2017-13008,CVE-2017-13008,{'CWE-125'},6.4,The IEEE 802.11 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_11.c:parse_elements().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/5edf405d7ed9fc92f4f43e8a3d44baa4c6387562'},https://github.com/the-tcpdump-group/tcpdump/commit/5edf405d7ed9fc92f4f43e8a3d44baa4c6387562,SINGLE,['ca336198e8bebccc18502de27672fdbd6eb34856'],1,5edf405d7ed9fc92f4f43e8a3d44baa4c6387562,"03/06/2017, 17:42:49",5edf405d7ed9fc92f4f43e8a3d44baa4c6387562,['5edf405d7ed9fc92f4f43e8a3d44baa4c6387562'],Guy Harris,"CVE-2017-13008/IEEE 802.11: Fix TIM bitmap copy to copy from p + offset.

offset has already been advanced to point to the bitmap; we shouldn't
add the amount to advance again.

This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.

Add a test using the capture file supplied by the reporter(s).

While we're at it, remove some redundant tests - we've already checked,
before the case statement, whether we have captured the entire
information element and whether the entire information element is
present in the on-the-wire packet; in the cases for particular IEs, we
only need to make sure we don't go past the end of the IE.","{'print-802_11.c': {'additions': 1, 'deletions': 13, 'changes': 14, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5edf405d7ed9fc92f4f43e8a3d44baa4c6387562/print-802_11.c', 'patch': '@@ -1039,10 +1039,6 @@ parse_elements(netdissect_options *ndo,\n \t\t\tif (ssid.length != 0) {\n \t\t\t\tif (ssid.length > sizeof(ssid.ssid) - 1)\n \t\t\t\t\treturn 0;\n-\t\t\t\tif (!ND_TTEST2(*(p + offset), ssid.length))\n-\t\t\t\t\treturn 0;\n-\t\t\t\tif (length < ssid.length)\n-\t\t\t\t\treturn 0;\n \t\t\t\tmemcpy(&ssid.ssid, p + offset, ssid.length);\n \t\t\t\toffset += ssid.length;\n \t\t\t\tlength -= ssid.length;\n@@ -1068,10 +1064,6 @@ parse_elements(netdissect_options *ndo,\n \t\t\t\tif (challenge.length >\n \t\t\t\t    sizeof(challenge.text) - 1)\n \t\t\t\t\treturn 0;\n-\t\t\t\tif (!ND_TTEST2(*(p + offset), challenge.length))\n-\t\t\t\t\treturn 0;\n-\t\t\t\tif (length < challenge.length)\n-\t\t\t\t\treturn 0;\n \t\t\t\tmemcpy(&challenge.text, p + offset,\n \t\t\t\t    challenge.length);\n \t\t\t\toffset += challenge.length;\n@@ -1097,10 +1089,6 @@ parse_elements(netdissect_options *ndo,\n \t\t\tif (rates.length != 0) {\n \t\t\t\tif (rates.length > sizeof rates.rate)\n \t\t\t\t\treturn 0;\n-\t\t\t\tif (!ND_TTEST2(*(p + offset), rates.length))\n-\t\t\t\t\treturn 0;\n-\t\t\t\tif (length < rates.length)\n-\t\t\t\t\treturn 0;\n \t\t\t\tmemcpy(&rates.rate, p + offset, rates.length);\n \t\t\t\toffset += rates.length;\n \t\t\t\tlength -= rates.length;\n@@ -1189,7 +1177,7 @@ parse_elements(netdissect_options *ndo,\n \t\t\toffset += 3;\n \t\t\tlength -= 3;\n \n-\t\t\tmemcpy(tim.bitmap, p + offset + 3, tim.length - 3);\n+\t\t\tmemcpy(tim.bitmap, p + offset, tim.length - 3);\n \t\t\toffset += tim.length - 3;\n \t\t\tlength -= tim.length - 3;\n \t\t\t/*'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5edf405d7ed9fc92f4f43e8a3d44baa4c6387562/tests%2FTESTLIST', 'patch': '@@ -438,6 +438,7 @@ ipv6-rthdr-oobr\t\tipv6-rthdr-oobr.pcap\t\tipv6-rthdr-oobr.out\n ieee802.11_tim_ie_oobr\tieee802.11_tim_ie_oobr.pcap\tieee802.11_tim_ie_oobr.out\n decnet-shorthdr-oobr\tdecnet-shorthdr-oobr.pcap\tdecnet-shorthdr-oobr.out\n isakmp-3948-oobr-2\tisakmp-3948-oobr-2.pcap\t\tisakmp-3948-oobr-2.out\n+ieee802.11_rates_oobr\tieee802.11_rates_oobr.pcap\tieee802.11_rates_oobr.out\n \n # bad packets from Kamil Frankowicz\n snmp-heapoverflow-1\tsnmp-heapoverflow-1.pcap\tsnmp-heapoverflow-1.out'}, 'tests/ieee802.11_rates_oobr.out': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5edf405d7ed9fc92f4f43e8a3d44baa4c6387562/tests%2Fieee802.11_rates_oobr.out', 'patch': '@@ -0,0 +1 @@\n+fhset 48 fhpat 48 48dBm signal 48dB signal 48dB noise [|802.11]Beacon IBSS, PRIVACY[|802.11]'}, 'tests/ieee802.11_rates_oobr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5edf405d7ed9fc92f4f43e8a3d44baa4c6387562/tests%2Fieee802.11_rates_oobr.pcap', 'patch': None}}",,"{'additions': 3, 'deletions': 13, 'total': 16}","{'c', 'pcap', 'out'}",{'C/C++'}
"bittok2str_internal(register const struct tok *lp, register const char *fmt,
	   register u_int v, const char *sep)
{
        static char buf[256]; /* our stringbuffer */
        int buflen=0;
        register u_int rotbit; /* this is the bit we rotate through all bitpositions */
        register u_int tokval;
        const char * sepstr = """";

	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;   /* load our first value */
            rotbit=1;
            while (rotbit != 0) {
                /*
                 * lets AND the rotating bit with our token value
                 * and see if we have got a match
                 */
		if (tokval == (v&rotbit)) {
                    /* ok we have found something */
                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
                                     sepstr, lp->s);
                    sepstr = sep;
                    break;
                }
                rotbit=rotbit<<1; /* no match - lets shift and try again */
            }
            lp++;
	}

        if (buflen == 0)
            /* bummer - lets print the ""unknown"" message as advised in the fmt string if we got one */
            (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
        return (buf);
}",1,"['CWE-119', 'CWE-125']",tcpdump,9f0730bee3eb65d07b49fd468bc2f269173352fe,60198926611126741950689323312623606492,34,"CVE-2017-13011/Properly check for buffer overflow in bittok2str_internal().

Also, make the buffer bigger.

This fixes a buffer overflow discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.",CVE-2017-13011,CVE-2017-13011,{'CWE-119'},6.4,Several protocol parsers in tcpdump before 4.9.2 could cause a buffer overflow in util-print.c:bittok2str_internal().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/9f0730bee3eb65d07b49fd468bc2f269173352fe'},https://github.com/the-tcpdump-group/tcpdump/commit/9f0730bee3eb65d07b49fd468bc2f269173352fe,SINGLE,['93493458ca50fa3fa45be20e2ed087a5dc2c594d'],1,9f0730bee3eb65d07b49fd468bc2f269173352fe,"03/15/2017, 19:12:21",9f0730bee3eb65d07b49fd468bc2f269173352fe,['9f0730bee3eb65d07b49fd468bc2f269173352fe'],Guy Harris,"CVE-2017-13011/Properly check for buffer overflow in bittok2str_internal().

Also, make the buffer bigger.

This fixes a buffer overflow discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.","{'tests/TESTLIST': {'additions': 3, 'deletions': 0, 'changes': 3, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/9f0730bee3eb65d07b49fd468bc2f269173352fe/tests%2FTESTLIST', 'patch': '@@ -507,6 +507,9 @@ juniper_es\t\tjuniper_es.pcap\t\t\tjuniper_es.out\t-vvv -e\n l2tp-avp-overflow\tl2tp-avp-overflow.pcap\t\tl2tp-avp-overflow.out\t-v\n pktap-heap-overflow\tpktap-heap-overflow.pcap\tpktap-heap-overflow.out\t-v\n \n+# bad packets from Bhargava Shastry\n+lldp_asan\t\tlldp_asan.pcap\t\t\tlldp_asan.out\t-v\n+\n # RTP tests\n # fuzzed pcap\n rtp-seg-fault-1  rtp-seg-fault-1.pcap  rtp-seg-fault-1.out  -v -T rtp'}, 'tests/lldp_asan.out': {'additions': 14, 'deletions': 0, 'changes': 14, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/9f0730bee3eb65d07b49fd468bc2f269173352fe/tests%2Flldp_asan.out', 'patch': '@@ -0,0 +1,14 @@\n+LLDP, length 296\n+\tChassis ID TLV (1), length 6\n+\t  Subtype Network address (5): AFI IPv4 (1): 0.0.32.0\n+\tOrganization specific TLV (127), length 9: OUI IEEE 802.3 Private (0x00120f)\n+\t  MAC/PHY configuration/status Subtype (1)\n+\t    autonegotiation [none] (0x00)\n+\t    PMD autoneg capability [10BASE-T hdx, 10BASE-T fdx, 100BASE-T4, 100BASE-TX hdx, 100BASE-TX fdx, 100BASE-T2 hdx, 100BASE-T2 fdx, Pause for fdx links, Asym PAUSE for fdx, Sym PAUSE for fdx, Asym and Sym PAUSE for fdx, 1000BASE-{X LX SX CX} hdx, 1000BASE-{X LX SX CX} fdx, 1000BASE-T hdx, 1000BASE-T fdx] (0xffff)\n+\t    MAU type unknown (0x2000)\n+\tOrganization specific TLV (127), length 9: OUI IEEE 802.3 Private (0x00120f)\n+\t  MAC/PHY configuration/status Subtype (1)\n+\t    autonegotiation [none] (0x00)\n+\t    PMD autoneg capability [Pause for fdx links, Asym PAUSE for fdx, Sym PAUSE for fdx, Asym and Sym PAUSE for fdx, 1000BASE-{X LX SX CX} hdx, 1000BASE-{X LX SX CX} fdx, 1000BASE-T hdx] (0x00fe)\n+\t    MAU type unknown (0x0f00)\n+\tEnd TLV (0), length 0'}, 'tests/lldp_asan.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/9f0730bee3eb65d07b49fd468bc2f269173352fe/tests%2Flldp_asan.pcap', 'patch': None}, 'util-print.c': {'additions': 18, 'deletions': 5, 'changes': 23, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/9f0730bee3eb65d07b49fd468bc2f269173352fe/util-print.c', 'patch': '@@ -523,8 +523,9 @@ static char *\n bittok2str_internal(register const struct tok *lp, register const char *fmt,\n \t   register u_int v, const char *sep)\n {\n-        static char buf[256]; /* our stringbuffer */\n-        int buflen=0;\n+        static char buf[1024+1]; /* our string buffer */\n+        char *bufp = buf;\n+        size_t space_left = sizeof(buf), string_size;\n         register u_int rotbit; /* this is the bit we rotate through all bitpositions */\n         register u_int tokval;\n         const char * sepstr = """";\n@@ -539,8 +540,20 @@ bittok2str_internal(register const struct tok *lp, register const char *fmt,\n                  */\n \t\tif (tokval == (v&rotbit)) {\n                     /* ok we have found something */\n-                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",\n-                                     sepstr, lp->s);\n+                    if (space_left <= 1)\n+                        return (buf); /* only enough room left for NUL, if that */\n+                    string_size = strlcpy(bufp, sepstr, space_left);\n+                    if (string_size >= space_left)\n+                        return (buf);    /* we ran out of room */\n+                    bufp += string_size;\n+                    space_left -= string_size;\n+                    if (space_left <= 1)\n+                        return (buf); /* only enough room left for NUL, if that */\n+                    string_size = strlcpy(bufp, lp->s, space_left);\n+                    if (string_size >= space_left)\n+                        return (buf);    /* we ran out of room */\n+                    bufp += string_size;\n+                    space_left -= string_size;\n                     sepstr = sep;\n                     break;\n                 }\n@@ -549,7 +562,7 @@ bittok2str_internal(register const struct tok *lp, register const char *fmt,\n             lp++;\n \t}\n \n-        if (buflen == 0)\n+        if (bufp == buf)\n             /* bummer - lets print the ""unknown"" message as advised in the fmt string if we got one */\n             (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);\n         return (buf);'}}",,"{'additions': 35, 'deletions': 5, 'total': 40}","{'c', 'pcap', 'out'}",{'C/C++'}
"vqp_print(netdissect_options *ndo, register const u_char *pptr, register u_int len)
{
    const struct vqp_common_header_t *vqp_common_header;
    const struct vqp_obj_tlv_t *vqp_obj_tlv;

    const u_char *tptr;
    uint16_t vqp_obj_len;
    uint32_t vqp_obj_type;
    int tlen;
    uint8_t nitems;

    tptr=pptr;
    tlen = len;
    vqp_common_header = (const struct vqp_common_header_t *)pptr;
    ND_TCHECK(*vqp_common_header);

    /*
     * Sanity checking of the header.
     */
    if (VQP_EXTRACT_VERSION(vqp_common_header->version) != VQP_VERSION) {
	ND_PRINT((ndo, ""VQP version %u packet not supported"",
               VQP_EXTRACT_VERSION(vqp_common_header->version)));
	return;
    }

    /* in non-verbose mode just lets print the basic Message Type */
    if (ndo->ndo_vflag < 1) {
        ND_PRINT((ndo, ""VQPv%u %s Message, error-code %s (%u), length %u"",
               VQP_EXTRACT_VERSION(vqp_common_header->version),
               tok2str(vqp_msg_type_values, ""unknown (%u)"",vqp_common_header->msg_type),
               tok2str(vqp_error_code_values, ""unknown (%u)"",vqp_common_header->error_code),
	       vqp_common_header->error_code,
               len));
        return;
    }

    /* ok they seem to want to know everything - lets fully decode it */
    nitems = vqp_common_header->nitems;
    ND_PRINT((ndo, ""\n\tVQPv%u, %s Message, error-code %s (%u), seq 0x%08x, items %u, length %u"",
           VQP_EXTRACT_VERSION(vqp_common_header->version),
	   tok2str(vqp_msg_type_values, ""unknown (%u)"",vqp_common_header->msg_type),
	   tok2str(vqp_error_code_values, ""unknown (%u)"",vqp_common_header->error_code),
	   vqp_common_header->error_code,
           EXTRACT_32BITS(&vqp_common_header->sequence),
           nitems,
           len));

    /* skip VQP Common header */
    tptr+=sizeof(const struct vqp_common_header_t);
    tlen-=sizeof(const struct vqp_common_header_t);

    while (nitems > 0 && tlen > 0) {

        vqp_obj_tlv = (const struct vqp_obj_tlv_t *)tptr;
        vqp_obj_type = EXTRACT_32BITS(vqp_obj_tlv->obj_type);
        vqp_obj_len = EXTRACT_16BITS(vqp_obj_tlv->obj_length);
        tptr+=sizeof(struct vqp_obj_tlv_t);
        tlen-=sizeof(struct vqp_obj_tlv_t);

        ND_PRINT((ndo, ""\n\t  %s Object (0x%08x), length %u, value: "",
               tok2str(vqp_obj_values, ""Unknown"", vqp_obj_type),
               vqp_obj_type, vqp_obj_len));

        /* basic sanity check */
        if (vqp_obj_type == 0 || vqp_obj_len ==0) {
            return;
        }

        /* did we capture enough for fully decoding the object ? */
        ND_TCHECK2(*tptr, vqp_obj_len);

        switch(vqp_obj_type) {
	case VQP_OBJ_IP_ADDRESS:
            ND_PRINT((ndo, ""%s (0x%08x)"", ipaddr_string(ndo, tptr), EXTRACT_32BITS(tptr)));
            break;
            /* those objects have similar semantics - fall through */
        case VQP_OBJ_PORT_NAME:
	case VQP_OBJ_VLAN_NAME:
	case VQP_OBJ_VTP_DOMAIN:
	case VQP_OBJ_ETHERNET_PKT:
            safeputs(ndo, tptr, vqp_obj_len);
            break;
            /* those objects have similar semantics - fall through */
	case VQP_OBJ_MAC_ADDRESS:
	case VQP_OBJ_MAC_NULL:
	      ND_PRINT((ndo, ""%s"", etheraddr_string(ndo, tptr)));
              break;
        default:
            if (ndo->ndo_vflag <= 1)
                print_unknown_data(ndo,tptr, ""\n\t    "", vqp_obj_len);
            break;
        }
	tptr += vqp_obj_len;
	tlen -= vqp_obj_len;
	nitems--;
    }
    return;
trunc:
    ND_PRINT((ndo, ""\n\t[|VQP]""));
}",1,"['CWE-125', 'CWE-787']",tcpdump,3b36ec4e713dea9266db11975066c425aa669b6c,144842655624266427051578455690404196258,100,"CVE-2017-13045/VQP: add some bounds checks

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-13045,CVE-2017-13045,{'CWE-125'},6.4,The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/3b36ec4e713dea9266db11975066c425aa669b6c'},https://github.com/the-tcpdump-group/tcpdump/commit/3b36ec4e713dea9266db11975066c425aa669b6c,SINGLE,['c2f6833dddecf2d5fb89c9c898eee9981da342ed'],1,3b36ec4e713dea9266db11975066c425aa669b6c,"07/29/2017, 22:21:00",3b36ec4e713dea9266db11975066c425aa669b6c,['3b36ec4e713dea9266db11975066c425aa669b6c'],Denis Ovsienko,"CVE-2017-13045/VQP: add some bounds checks

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).","{'print-vqp.c': {'additions': 13, 'deletions': 1, 'changes': 14, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3b36ec4e713dea9266db11975066c425aa669b6c/print-vqp.c', 'patch': '@@ -26,6 +26,7 @@\n #include ""netdissect.h""\n #include ""extract.h""\n #include ""addrtoname.h""\n+#include ""ether.h""\n \n #define VQP_VERSION            \t\t1\n #define VQP_EXTRACT_VERSION(x) ((x)&0xFF)\n@@ -105,13 +106,15 @@ vqp_print(netdissect_options *ndo, register const u_char *pptr, register u_int l\n     const u_char *tptr;\n     uint16_t vqp_obj_len;\n     uint32_t vqp_obj_type;\n-    int tlen;\n+    u_int tlen;\n     uint8_t nitems;\n \n     tptr=pptr;\n     tlen = len;\n     vqp_common_header = (const struct vqp_common_header_t *)pptr;\n     ND_TCHECK(*vqp_common_header);\n+    if (sizeof(struct vqp_common_header_t) > tlen)\n+        goto trunc;\n \n     /*\n      * Sanity checking of the header.\n@@ -151,6 +154,9 @@ vqp_print(netdissect_options *ndo, register const u_char *pptr, register u_int l\n     while (nitems > 0 && tlen > 0) {\n \n         vqp_obj_tlv = (const struct vqp_obj_tlv_t *)tptr;\n+        ND_TCHECK(*vqp_obj_tlv);\n+        if (sizeof(struct vqp_obj_tlv_t) > tlen)\n+            goto trunc;\n         vqp_obj_type = EXTRACT_32BITS(vqp_obj_tlv->obj_type);\n         vqp_obj_len = EXTRACT_16BITS(vqp_obj_tlv->obj_length);\n         tptr+=sizeof(struct vqp_obj_tlv_t);\n@@ -167,9 +173,13 @@ vqp_print(netdissect_options *ndo, register const u_char *pptr, register u_int l\n \n         /* did we capture enough for fully decoding the object ? */\n         ND_TCHECK2(*tptr, vqp_obj_len);\n+        if (vqp_obj_len > tlen)\n+            goto trunc;\n \n         switch(vqp_obj_type) {\n \tcase VQP_OBJ_IP_ADDRESS:\n+            if (vqp_obj_len != 4)\n+                goto trunc;\n             ND_PRINT((ndo, ""%s (0x%08x)"", ipaddr_string(ndo, tptr), EXTRACT_32BITS(tptr)));\n             break;\n             /* those objects have similar semantics - fall through */\n@@ -182,6 +192,8 @@ vqp_print(netdissect_options *ndo, register const u_char *pptr, register u_int l\n             /* those objects have similar semantics - fall through */\n \tcase VQP_OBJ_MAC_ADDRESS:\n \tcase VQP_OBJ_MAC_NULL:\n+            if (vqp_obj_len != ETHER_ADDR_LEN)\n+                goto trunc;\n \t      ND_PRINT((ndo, ""%s"", etheraddr_string(ndo, tptr)));\n               break;\n         default:'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3b36ec4e713dea9266db11975066c425aa669b6c/tests%2FTESTLIST', 'patch': '@@ -562,6 +562,7 @@ isakmpv1-attr-oobr\tisakmpv1-attr-oobr.pcap\t\tisakmpv1-attr-oobr.out\t-v\n hncp_dhcpv6data-oobr\thncp_dhcpv6data-oobr.pcap\thncp_dhcpv6data-oobr.out -v -c1\n # Same comments apply to the case below.\n hncp_dhcpv4data-oobr\thncp_dhcpv4data-oobr.pcap\thncp_dhcpv4data-oobr.out -v -c1\n+vqp-oobr\t\tvqp-oobr.pcap\t\t\tvqp-oobr.out\t\t-v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out'}, 'tests/vqp-oobr.out': {'additions': 4, 'deletions': 0, 'changes': 4, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3b36ec4e713dea9266db11975066c425aa669b6c/tests%2Fvqp-oobr.out', 'patch': '@@ -0,0 +1,4 @@\n+IP (tos 0x0, ttl 17, id 40207, offset 0, flags [+, DF, rsvd], proto UDP (17), length 46, bad cksum 8f04 (->f897)!)\n+    0.0.128.20.1589 > 12.251.167.8.62720: \n+\tVQPv1, unknown (127) Message, error-code unknown (31) (31), seq 0x80f90000, items 27, length 18\n+\t[|VQP]'}, 'tests/vqp-oobr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/3b36ec4e713dea9266db11975066c425aa669b6c/tests%2Fvqp-oobr.pcap', 'patch': None}}",,"{'additions': 18, 'deletions': 1, 'total': 19}","{'c', 'pcap', 'out'}",{'C/C++'}
"dhcpv4_print(netdissect_options *ndo,
             const u_char *cp, u_int length, int indent)
{
    u_int i, t;
    const u_char *tlv, *value;
    uint8_t type, optlen;

    i = 0;
    while (i < length) {
        tlv = cp + i;
        type = (uint8_t)tlv[0];
        optlen = (uint8_t)tlv[1];
        value = tlv + 2;

        ND_PRINT((ndo, ""\n""));
        for (t = indent; t > 0; t--)
            ND_PRINT((ndo, ""\t""));

        ND_PRINT((ndo, ""%s"", tok2str(dh4opt_str, ""Unknown"", type)));
        ND_PRINT((ndo,"" (%u)"", optlen + 2 ));

        switch (type) {
        case DH4OPT_DNS_SERVERS:
        case DH4OPT_NTP_SERVERS: {
            if (optlen < 4 || optlen % 4 != 0) {
                return -1;
            }
            for (t = 0; t < optlen; t += 4)
                ND_PRINT((ndo, "" %s"", ipaddr_string(ndo, value + t)));
        }
            break;
        case DH4OPT_DOMAIN_SEARCH: {
            const u_char *tp = value;
            while (tp < value + optlen) {
                ND_PRINT((ndo, "" ""));
                if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)
                    return -1;
            }
        }
            break;
        }

        i += 2 + optlen;
    }
    return 0;
}",1,"['CWE-125', 'CWE-787']",tcpdump,c2f6833dddecf2d5fb89c9c898eee9981da342ed,241157474977261830158079971857650008737,46,"CVE-2017-13044/HNCP: add DHCPv4-Data bounds checks

dhcpv4_print() in print-hncp.c had the same bug as dhcpv6_print(), apply
a fix along the same lines.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-13044,CVE-2017-13044,{'CWE-125'},6.4,The HNCP parser in tcpdump before 4.9.2 has a buffer over-read in print-hncp.c:dhcpv4_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/c2f6833dddecf2d5fb89c9c898eee9981da342ed'},https://github.com/the-tcpdump-group/tcpdump/commit/c2f6833dddecf2d5fb89c9c898eee9981da342ed,SINGLE,['39582c04cc5e34054b2936b423072fb9df2ff6ef'],1,c2f6833dddecf2d5fb89c9c898eee9981da342ed,"07/29/2017, 20:45:35",c2f6833dddecf2d5fb89c9c898eee9981da342ed,['c2f6833dddecf2d5fb89c9c898eee9981da342ed'],Denis Ovsienko,"CVE-2017-13044/HNCP: add DHCPv4-Data bounds checks

dhcpv4_print() in print-hncp.c had the same bug as dhcpv6_print(), apply
a fix along the same lines.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).","{'print-hncp.c': {'additions': 4, 'deletions': 0, 'changes': 4, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/c2f6833dddecf2d5fb89c9c898eee9981da342ed/print-hncp.c', 'patch': '@@ -270,6 +270,8 @@ dhcpv4_print(netdissect_options *ndo,\n \n     i = 0;\n     while (i < length) {\n+        if (i + 2 > length)\n+            return -1;\n         tlv = cp + i;\n         type = (uint8_t)tlv[0];\n         optlen = (uint8_t)tlv[1];\n@@ -281,6 +283,8 @@ dhcpv4_print(netdissect_options *ndo,\n \n         ND_PRINT((ndo, ""%s"", tok2str(dh4opt_str, ""Unknown"", type)));\n         ND_PRINT((ndo,"" (%u)"", optlen + 2 ));\n+        if (i + 2 + optlen > length)\n+            return -1;\n \n         switch (type) {\n         case DH4OPT_DNS_SERVERS:'}, 'tests/TESTLIST': {'additions': 2, 'deletions': 0, 'changes': 2, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/c2f6833dddecf2d5fb89c9c898eee9981da342ed/tests%2FTESTLIST', 'patch': '@@ -560,6 +560,8 @@ isakmpv1-attr-oobr\tisakmpv1-attr-oobr.pcap\t\tisakmpv1-attr-oobr.out\t-v\n # code path and will not test the vulnerability unless modified respectively.\n # The .pcap file is truncated after the 1st packet.\n hncp_dhcpv6data-oobr\thncp_dhcpv6data-oobr.pcap\thncp_dhcpv6data-oobr.out -v -c1\n+# Same comments apply to the case below.\n+hncp_dhcpv4data-oobr\thncp_dhcpv4data-oobr.pcap\thncp_dhcpv4data-oobr.out -v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out'}, 'tests/hncp_dhcpv4data-oobr.out': {'additions': 4, 'deletions': 0, 'changes': 4, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/c2f6833dddecf2d5fb89c9c898eee9981da342ed/tests%2Fhncp_dhcpv4data-oobr.out', 'patch': '@@ -0,0 +1,4 @@\n+IP truncated-ip - 260 bytes missing! (tos 0x12,ECT(0), ttl 48, id 21323, offset 0, flags [+, DF, rsvd], proto UDP (17), length 296, bad cksum 8e0f (->cd08)!)\n+    1.2.7.0.1812 > 128.253.0.96.8231: hncp (268)\n+\tDHCPv4-Data (6)\n+\t\tDNS-server (98) (invalid)'}, 'tests/hncp_dhcpv4data-oobr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/c2f6833dddecf2d5fb89c9c898eee9981da342ed/tests%2Fhncp_dhcpv4data-oobr.pcap', 'patch': None}}",,"{'additions': 10, 'deletions': 0, 'total': 10}","{'c', 'pcap', 'out'}",{'C/C++'}
"mobility_opt_print(netdissect_options *ndo,
                   const u_char *bp, const unsigned len)
{
	unsigned i, optlen;

	for (i = 0; i < len; i += optlen) {
		ND_TCHECK(bp[i]);
		if (bp[i] == IP6MOPT_PAD1)
			optlen = 1;
		else {
			if (i + 1 < len) {
				ND_TCHECK(bp[i + 1]);
				optlen = bp[i + 1] + 2;
			}
			else
				goto trunc;
		}
		if (i + optlen > len)
			goto trunc;
		ND_TCHECK(bp[i + optlen]);

		switch (bp[i]) {
		case IP6MOPT_PAD1:
			ND_PRINT((ndo, ""(pad1)""));
			break;
		case IP6MOPT_PADN:
			if (len - i < IP6MOPT_MINLEN) {
				ND_PRINT((ndo, ""(padn: trunc)""));
				goto trunc;
			}
			ND_PRINT((ndo, ""(padn)""));
			break;
		case IP6MOPT_REFRESH:
			if (len - i < IP6MOPT_REFRESH_MINLEN) {
				ND_PRINT((ndo, ""(refresh: trunc)""));
				goto trunc;
			}
			/* units of 4 secs */
			ND_TCHECK_16BITS(&bp[i+2]);
			ND_PRINT((ndo, ""(refresh: %u)"",
				EXTRACT_16BITS(&bp[i+2]) << 2));
			break;
		case IP6MOPT_ALTCOA:
			if (len - i < IP6MOPT_ALTCOA_MINLEN) {
				ND_PRINT((ndo, ""(altcoa: trunc)""));
				goto trunc;
			}
			ND_PRINT((ndo, ""(alt-CoA: %s)"", ip6addr_string(ndo, &bp[i+2])));
			break;
		case IP6MOPT_NONCEID:
			if (len - i < IP6MOPT_NONCEID_MINLEN) {
				ND_PRINT((ndo, ""(ni: trunc)""));
				goto trunc;
			}
			ND_TCHECK_16BITS(&bp[i+2]);
			ND_TCHECK_16BITS(&bp[i+4]);
			ND_PRINT((ndo, ""(ni: ho=0x%04x co=0x%04x)"",
				EXTRACT_16BITS(&bp[i+2]),
				EXTRACT_16BITS(&bp[i+4])));
			break;
		case IP6MOPT_AUTH:
			if (len - i < IP6MOPT_AUTH_MINLEN) {
				ND_PRINT((ndo, ""(auth: trunc)""));
				goto trunc;
			}
			ND_PRINT((ndo, ""(auth)""));
			break;
		default:
			if (len - i < IP6MOPT_MINLEN) {
				ND_PRINT((ndo, ""(sopt_type %u: trunc)"", bp[i]));
				goto trunc;
			}
			ND_PRINT((ndo, ""(type-0x%02x: len=%u)"", bp[i], bp[i + 1]));
			break;
		}
	}
	return 0;

trunc:
	return 1;
}",1,"['CWE-125', 'CWE-787']",tcpdump,5338aac7b8b880b0c5e0c15e27dadc44c5559284,252707250989422627393599419479415937671,81,"CVE-2017-13025/IPv6 mobility: Add a bounds check before fetching data

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't cause 'tcpdump: pcap_loop: truncated dump file'",CVE-2017-13025,CVE-2017-13025,{'CWE-125'},6.4,The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_opt_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/5338aac7b8b880b0c5e0c15e27dadc44c5559284'},https://github.com/the-tcpdump-group/tcpdump/commit/5338aac7b8b880b0c5e0c15e27dadc44c5559284,SINGLE,['7d3aba9f06899d0128ef46e8a2fa143c6fad8f62'],1,5338aac7b8b880b0c5e0c15e27dadc44c5559284,"03/22/2017, 16:07:47",5338aac7b8b880b0c5e0c15e27dadc44c5559284,['5338aac7b8b880b0c5e0c15e27dadc44c5559284'],Francois-Xavier Le Bail,"CVE-2017-13025/IPv6 mobility: Add a bounds check before fetching data

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't cause 'tcpdump: pcap_loop: truncated dump file'","{'extract.h': {'additions': 3, 'deletions': 0, 'changes': 3, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5338aac7b8b880b0c5e0c15e27dadc44c5559284/extract.h', 'patch': '@@ -281,3 +281,6 @@ EXTRACT_64BITS(const void *p)\n \n #define ND_TTEST_64BITS(p) ND_TTEST2(*(p), 8)\n #define ND_TCHECK_64BITS(p) ND_TCHECK2(*(p), 8)\n+\n+#define ND_TTEST_128BITS(p) ND_TTEST2(*(p), 16)\n+#define ND_TCHECK_128BITS(p) ND_TCHECK2(*(p), 16)'}, 'print-mobility.c': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5338aac7b8b880b0c5e0c15e27dadc44c5559284/print-mobility.c', 'patch': '@@ -159,6 +159,7 @@ mobility_opt_print(netdissect_options *ndo,\n \t\t\t\tND_PRINT((ndo, ""(altcoa: trunc)""));\n \t\t\t\tgoto trunc;\n \t\t\t}\n+\t\t\tND_TCHECK_128BITS(&bp[i+2]);\n \t\t\tND_PRINT((ndo, ""(alt-CoA: %s)"", ip6addr_string(ndo, &bp[i+2])));\n \t\t\tbreak;\n \t\tcase IP6MOPT_NONCEID:'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5338aac7b8b880b0c5e0c15e27dadc44c5559284/tests%2FTESTLIST', 'patch': '@@ -526,6 +526,7 @@ icmp6_mobileprefix_asan\ticmp6_mobileprefix_asan.pcap\ticmp6_mobileprefix_asan.out\n ip_printroute_asan\tip_printroute_asan.pcap\t\tip_printroute_asan.out\t-v\n mobility_opt_asan\tmobility_opt_asan.pcap\t\tmobility_opt_asan.out\t-v\n mobility_opt_asan_2\tmobility_opt_asan_2.pcap\tmobility_opt_asan_2.out\t-v\n+mobility_opt_asan_3\tmobility_opt_asan_3.pcap\tmobility_opt_asan_3.out\t-v\n \n # RTP tests\n # fuzzed pcap'}, 'tests/mobility_opt_asan_3.out': {'additions': 2, 'deletions': 0, 'changes': 2, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5338aac7b8b880b0c5e0c15e27dadc44c5559284/tests%2Fmobility_opt_asan_3.out', 'patch': '@@ -0,0 +1,2 @@\n+IP6 (class 0x50, flowlabel 0x00004, hlim 0, next-header Mobile IP (old) (62) payload length: 7168) d400:7fa1:200:400::6238:2949 > 9675:86dd:7300:2c:1c7f:ffff:ffc3:b2a1: mobility: CoT nonce id=0x74 Care-of Init Cookie=80570f80:00000004[|MOBILITY]\n+IP6 (class 0x50, flowlabel 0x00004, hlim 0, next-header Mobile IP (old) (62) payload length: 7168) ffc3:b2a1:200:400::6238:2949 > 9675:86dd:73f0:2c:1c7f:ffff:ebc3:b2a1: mobility: BU seq#=39837 lifetime=261452[|MOBILITY]'}, 'tests/mobility_opt_asan_3.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5338aac7b8b880b0c5e0c15e27dadc44c5559284/tests%2Fmobility_opt_asan_3.pcap', 'patch': None}}",,"{'additions': 7, 'deletions': 0, 'total': 7}","{'c', 'pcap', 'h', 'out'}",{'C/C++'}
"decode_rt_routing_info(netdissect_options *ndo,
                       const u_char *pptr, char *buf, u_int buflen)
{
	uint8_t route_target[8];
	u_int plen;

	ND_TCHECK(pptr[0]);
	plen = pptr[0];   /* get prefix length */

	if (0 == plen) {
		snprintf(buf, buflen, ""default route target"");
		return 1;
	}

	if (32 > plen)
		return -1;

        plen-=32; /* adjust prefix length */

	if (64 < plen)
		return -1;

	memset(&route_target, 0, sizeof(route_target));
	ND_TCHECK2(pptr[1], (plen + 7) / 8);
	memcpy(&route_target, &pptr[1], (plen + 7) / 8);
	if (plen % 8) {
		((u_char *)&route_target)[(plen + 7) / 8 - 1] &=
			((0xff00 >> (plen % 8)) & 0xff);
	}
	snprintf(buf, buflen, ""origin AS: %s, route target %s"",
	    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),
	    bgp_vpn_rd_print(ndo, (u_char *)&route_target));

	return 5 + (plen + 7) / 8;

trunc:
	return -2;
}",1,"['CWE-125', 'CWE-787']",tcpdump,bd4e697ebd6c8457efa8f28f6831fc929b88a014,80982642083498313683808517638086294852,38,"CVE-2017-13053/BGP: fix VPN route target bounds checks

decode_rt_routing_info() didn't check bounds before fetching 4 octets of
the origin AS field and could over-read the input buffer, put it right.

It also fetched the varying number of octets of the route target field
from 4 octets lower than the correct offset, put it right.

It also used the same temporary buffer explicitly through as_printf()
and implicitly through bgp_vpn_rd_print() so the end result of snprintf()
was not what was originally intended.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-13053,CVE-2017-13053,{'CWE-125'},6.4,The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:decode_rt_routing_info().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/bd4e697ebd6c8457efa8f28f6831fc929b88a014'},https://github.com/the-tcpdump-group/tcpdump/commit/bd4e697ebd6c8457efa8f28f6831fc929b88a014,SINGLE,['e6511cc1a950fe1566b2236329d6b4bd0826cc7a'],1,bd4e697ebd6c8457efa8f28f6831fc929b88a014,"08/11/2017, 12:39:02",bd4e697ebd6c8457efa8f28f6831fc929b88a014,['bd4e697ebd6c8457efa8f28f6831fc929b88a014'],Denis Ovsienko,"CVE-2017-13053/BGP: fix VPN route target bounds checks

decode_rt_routing_info() didn't check bounds before fetching 4 octets of
the origin AS field and could over-read the input buffer, put it right.

It also fetched the varying number of octets of the route target field
from 4 octets lower than the correct offset, put it right.

It also used the same temporary buffer explicitly through as_printf()
and implicitly through bgp_vpn_rd_print() so the end result of snprintf()
was not what was originally intended.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).","{'print-bgp.c': {'additions': 19, 'deletions': 3, 'changes': 22, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/bd4e697ebd6c8457efa8f28f6831fc929b88a014/print-bgp.c', 'patch': '@@ -761,32 +761,48 @@ decode_rt_routing_info(netdissect_options *ndo,\n {\n \tuint8_t route_target[8];\n \tu_int plen;\n+\tchar asbuf[sizeof(astostr)]; /* bgp_vpn_rd_print() overwrites astostr */\n \n+\t/* NLRI ""prefix length"" from RFC 2858 Section 4. */\n \tND_TCHECK(pptr[0]);\n \tplen = pptr[0];   /* get prefix length */\n \n+\t/* NLRI ""prefix"" (ibid), valid lengths are { 0, 32, 33, ..., 96 } bits.\n+\t * RFC 4684 Section 4 defines the layout of ""origin AS"" and ""route\n+\t * target"" fields inside the ""prefix"" depending on its length.\n+\t */\n \tif (0 == plen) {\n+\t\t/* Without ""origin AS"", without ""route target"". */\n \t\tsnprintf(buf, buflen, ""default route target"");\n \t\treturn 1;\n \t}\n \n \tif (32 > plen)\n \t\treturn -1;\n \n+\t/* With at least ""origin AS"", possibly with ""route target"". */\n+\tND_TCHECK_32BITS(pptr + 1);\n+\tas_printf(ndo, asbuf, sizeof(asbuf), EXTRACT_32BITS(pptr + 1));\n+\n         plen-=32; /* adjust prefix length */\n \n \tif (64 < plen)\n \t\treturn -1;\n \n+\t/* From now on (plen + 7) / 8 evaluates to { 0, 1, 2, ..., 8 }\n+\t * and gives the number of octets in the variable-length ""route\n+\t * target"" field inside this NLRI ""prefix"". Look for it.\n+\t */\n \tmemset(&route_target, 0, sizeof(route_target));\n-\tND_TCHECK2(pptr[1], (plen + 7) / 8);\n-\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);\n+\tND_TCHECK2(pptr[5], (plen + 7) / 8);\n+\tmemcpy(&route_target, &pptr[5], (plen + 7) / 8);\n+\t/* Which specification says to do this? */\n \tif (plen % 8) {\n \t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n \t\t\t((0xff00 >> (plen % 8)) & 0xff);\n \t}\n \tsnprintf(buf, buflen, ""origin AS: %s, route target %s"",\n-\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n+\t    asbuf,\n \t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n \n \treturn 5 + (plen + 7) / 8;'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/bd4e697ebd6c8457efa8f28f6831fc929b88a014/tests%2FTESTLIST', 'patch': '@@ -572,6 +572,7 @@ rsvp_uni-oobr-2\trsvp_uni-oobr-2.pcap\trsvp_uni-oobr-2.out\t-v -c1\n rsvp_uni-oobr-3\trsvp_uni-oobr-3.pcap\trsvp_uni-oobr-3.out\t-v -c3\n rpki-rtr-oob\t\trpki-rtr-oob.pcap\trpki-rtr-oob.out\t-v -c1\n lldp_8023_mtu-oobr\tlldp_8023_mtu-oobr.pcap\tlldp_8023_mtu-oobr.out\t-v -c1\n+bgp_vpn_rt-oobr\tbgp_vpn_rt-oobr.pcap\tbgp_vpn_rt-oobr.out\t-v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out'}, 'tests/bgp_vpn_rt-oobr.out': {'additions': 43, 'deletions': 0, 'changes': 43, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/bd4e697ebd6c8457efa8f28f6831fc929b88a014/tests%2Fbgp_vpn_rt-oobr.out', 'patch': '@@ -0,0 +1,43 @@\n+IP (tos 0xc, ttl 254, id 21263, offset 0, flags [rsvd], proto TCP (6), length 60165, bad cksum 8e15 (->9eb8)!)\n+    241.0.128.19.179 > 239.8.0.1.0: Flags [none], seq 2146695561:2146755682, win 56026, options [unknown-161,eol], length 60121: BGP\n+\tUpdate Message (2), length: 45\n+\t  Withdrawn routes: 3 bytes\n+\t  Attribute Set (128), length: 7, Flags [OTPE+f]: \n+\t    Origin AS: 0\n+\t      Multi-Protocol Unreach NLRI (15), length: 227, Flags [T+6]: \n+\t    AFI: IPv6 (2), SAFI: Multicast VPN (5)\n+\t      Route-Type: Source-Active (5), length: 5, RD: unknown RD format, Group bogus address length 127\n+\t      Route-Type: Unknown (142), length: 142\n+\t      Route-Type: Unknown (0), length: 0\n+\t      Route-Type: Unknown (33), length: 0\n+\t      Route-Type: Unknown (0), length: 0[|BGP] [|BGP]\n+\tUpdate Message (2), length: 45[|BGP] [|BGP]\n+\tUpdate Message (2), length: 45\n+\t  Withdrawn routes: 3 bytes\n+\t  Attribute Set (128), length: 7, Flags [OTPE+f]: \n+\t    Origin AS: 0\n+\t      Multi-Protocol Reach NLRI (14), length: 227, Flags [T+6]: \n+\t    AFI: IPv4 (1), vendor specific SAFI: Route Target Routing Information (132)\n+\t    nexthop: invalid len, nh-length: 1, no SNPA\n+\t      origin AS: 0, route target 0:0 (= 0.0.0.0)\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target[|BGP]'}, 'tests/bgp_vpn_rt-oobr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/bd4e697ebd6c8457efa8f28f6831fc929b88a014/tests%2Fbgp_vpn_rt-oobr.pcap', 'patch': None}}",,"{'additions': 63, 'deletions': 3, 'total': 66}","{'c', 'pcap', 'out'}",{'C/C++'}
"nfs_printfh(netdissect_options *ndo,
            register const uint32_t *dp, const u_int len)
{
	my_fsid fsid;
	uint32_t ino;
	const char *sfsname = NULL;
	char *spacep;

	if (ndo->ndo_uflag) {
		u_int i;
		char const *sep = """";

		ND_PRINT((ndo, "" fh[""));
		for (i=0; i<len; i++) {
			ND_PRINT((ndo, ""%s%x"", sep, dp[i]));
			sep = "":"";
		}
		ND_PRINT((ndo, ""]""));
		return;
	}

	Parse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);

	if (sfsname) {
		/* file system ID is ASCII, not numeric, for this server OS */
		static char temp[NFSX_V3FHMAX+1];

		/* Make sure string is null-terminated */
		strncpy(temp, sfsname, NFSX_V3FHMAX);
		temp[sizeof(temp) - 1] = '\0';
		/* Remove trailing spaces */
		spacep = strchr(temp, ' ');
		if (spacep)
			*spacep = '\0';

		ND_PRINT((ndo, "" fh %s/"", temp));
	} else {
		ND_PRINT((ndo, "" fh %d,%d/"",
			     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));
	}

	if(fsid.Fsid_dev.Minor == 257)
		/* Print the undecoded handle */
		ND_PRINT((ndo, ""%s"", fsid.Opaque_Handle));
	else
		ND_PRINT((ndo, ""%ld"", (long) ino));
}",1,"['CWE-125', 'CWE-787']",tcpdump,7a923447fd49a069a0fd3b6c3547438ab5ee2123,9274937499444375518847855010374150327,47,"CVE-2017-13001/NFS: Don't copy more data than is in the file handle.

Also, put the buffer on the stack; no reason to make it static.  (65
bytes isn't a lot.)

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-13001,CVE-2017-13001,{'CWE-125'},6.4,The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:nfs_printfh().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/7a923447fd49a069a0fd3b6c3547438ab5ee2123'},https://github.com/the-tcpdump-group/tcpdump/commit/7a923447fd49a069a0fd3b6c3547438ab5ee2123,SINGLE,['8512734883227c11568bb35da1d48b9f8466f43f'],1,7a923447fd49a069a0fd3b6c3547438ab5ee2123,"02/19/2017, 21:56:12",7a923447fd49a069a0fd3b6c3547438ab5ee2123,['7a923447fd49a069a0fd3b6c3547438ab5ee2123'],Guy Harris,"CVE-2017-13001/NFS: Don't copy more data than is in the file handle.

Also, put the buffer on the stack; no reason to make it static.  (65
bytes isn't a lot.)

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add a test using the capture file supplied by the reporter(s).","{'print-nfs.c': {'additions': 7, 'deletions': 3, 'changes': 10, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/7a923447fd49a069a0fd3b6c3547438ab5ee2123/print-nfs.c', 'patch': ""@@ -807,11 +807,15 @@ nfs_printfh(netdissect_options *ndo,\n \n \tif (sfsname) {\n \t\t/* file system ID is ASCII, not numeric, for this server OS */\n-\t\tstatic char temp[NFSX_V3FHMAX+1];\n+\t\tchar temp[NFSX_V3FHMAX+1];\n+\t\tu_int stringlen;\n \n \t\t/* Make sure string is null-terminated */\n-\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n-\t\ttemp[sizeof(temp) - 1] = '\\0';\n+\t\tstringlen = len;\n+\t\tif (stringlen > NFSX_V3FHMAX)\n+\t\t\tstringlen = NFSX_V3FHMAX;\n+\t\tstrncpy(temp, sfsname, stringlen);\n+\t\ttemp[stringlen] = '\\0';\n \t\t/* Remove trailing spaces */\n \t\tspacep = strchr(temp, ' ');\n \t\tif (spacep)""}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/7a923447fd49a069a0fd3b6c3547438ab5ee2123/tests%2FTESTLIST', 'patch': '@@ -458,6 +458,7 @@ hoobr_parse_field\thoobr_parse_field.pcap\t\thoobr_parse_field.out\n hoobr_chdlc_print\thoobr_chdlc_print.pcap\t\thoobr_chdlc_print.out\n hoobr_lookup_nsap\thoobr_lookup_nsap.pcap\t\thoobr_lookup_nsap.out\n hoobr_rt6_print\t\thoobr_rt6_print.pcap\t\thoobr_rt6_print.out\n+hoobr_nfs_printfh\thoobr_nfs_printfh.pcap\t\thoobr_nfs_printfh.out\n \n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve'}, 'tests/hoobr_nfs_printfh.out': {'additions': 104, 'deletions': 0, 'changes': 104, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/7a923447fd49a069a0fd3b6c3547438ab5ee2123/tests%2Fhoobr_nfs_printfh.out', 'patch': '@@ -0,0 +1,104 @@\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00d0:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030                      00000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00d0:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030                                0000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030                                0000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00d0:  3030 3030 3030 3030 3030 3030            000000000000\n+IP 48.48.48.48.12336 > 48.48.48.48.2049: Flags [.U], seq 808464432:808476728, ack 808464432, win 12336, urg 12336, length 12296: NFS request xid 808464432 12292 readlink fh 00000000/808464432'}, 'tests/hoobr_nfs_printfh.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/7a923447fd49a069a0fd3b6c3547438ab5ee2123/tests%2Fhoobr_nfs_printfh.pcap', 'patch': None}}",,"{'additions': 112, 'deletions': 3, 'total': 115}","{'c', 'pcap', 'out'}",{'C/C++'}
"dhcpv6_print(netdissect_options *ndo,
             const u_char *cp, u_int length, int indent)
{
    u_int i, t;
    const u_char *tlv, *value;
    uint16_t type, optlen;

    i = 0;
    while (i < length) {
        tlv = cp + i;
        type = EXTRACT_16BITS(tlv);
        optlen = EXTRACT_16BITS(tlv + 2);
        value = tlv + 4;

        ND_PRINT((ndo, ""\n""));
        for (t = indent; t > 0; t--)
            ND_PRINT((ndo, ""\t""));

        ND_PRINT((ndo, ""%s"", tok2str(dh6opt_str, ""Unknown"", type)));
        ND_PRINT((ndo,"" (%u)"", optlen + 4 ));

        switch (type) {
            case DH6OPT_DNS_SERVERS:
            case DH6OPT_SNTP_SERVERS: {
                if (optlen % 16 != 0) {
                    ND_PRINT((ndo, "" %s"", istr));
                    return -1;
                }
                for (t = 0; t < optlen; t += 16)
                    ND_PRINT((ndo, "" %s"", ip6addr_string(ndo, value + t)));
            }
                break;
            case DH6OPT_DOMAIN_LIST: {
                const u_char *tp = value;
                while (tp < value + optlen) {
                    ND_PRINT((ndo, "" ""));
                    if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)
                        return -1;
                }
            }
                break;
        }

        i += 4 + optlen;
    }
    return 0;
}",1,"['CWE-125', 'CWE-787']",tcpdump,39582c04cc5e34054b2936b423072fb9df2ff6ef,107072271385652405622684879306074773896,47,"CVE-2017-13042/HNCP: add DHCPv6-Data bounds checks

hncp_print_rec() validates each HNCP TLV to be within the declared as
well as the on-the-wire packet space. However, dhcpv6_print() in the same
file didn't do the same for the DHCPv6 options within the HNCP
DHCPv6-Data TLV value, which could cause an out-of-bounds read when
decoding an invalid packet. Add missing checks to dhcpv6_print().

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-13042,CVE-2017-13042,{'CWE-125'},6.4,The HNCP parser in tcpdump before 4.9.2 has a buffer over-read in print-hncp.c:dhcpv6_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/39582c04cc5e34054b2936b423072fb9df2ff6ef'},https://github.com/the-tcpdump-group/tcpdump/commit/39582c04cc5e34054b2936b423072fb9df2ff6ef,SINGLE,['f4b9e24c7384d882a7f434cc7413925bf871d63e'],1,39582c04cc5e34054b2936b423072fb9df2ff6ef,"07/29/2017, 17:52:38",39582c04cc5e34054b2936b423072fb9df2ff6ef,['39582c04cc5e34054b2936b423072fb9df2ff6ef'],Denis Ovsienko,"CVE-2017-13042/HNCP: add DHCPv6-Data bounds checks

hncp_print_rec() validates each HNCP TLV to be within the declared as
well as the on-the-wire packet space. However, dhcpv6_print() in the same
file didn't do the same for the DHCPv6 options within the HNCP
DHCPv6-Data TLV value, which could cause an out-of-bounds read when
decoding an invalid packet. Add missing checks to dhcpv6_print().

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).","{'print-hncp.c': {'additions': 4, 'deletions': 0, 'changes': 4, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/39582c04cc5e34054b2936b423072fb9df2ff6ef/print-hncp.c', 'patch': '@@ -318,6 +318,8 @@ dhcpv6_print(netdissect_options *ndo,\n \n     i = 0;\n     while (i < length) {\n+        if (i + 4 > length)\n+            return -1;\n         tlv = cp + i;\n         type = EXTRACT_16BITS(tlv);\n         optlen = EXTRACT_16BITS(tlv + 2);\n@@ -329,6 +331,8 @@ dhcpv6_print(netdissect_options *ndo,\n \n         ND_PRINT((ndo, ""%s"", tok2str(dh6opt_str, ""Unknown"", type)));\n         ND_PRINT((ndo,"" (%u)"", optlen + 4 ));\n+        if (i + 4 + optlen > length)\n+            return -1;\n \n         switch (type) {\n             case DH6OPT_DNS_SERVERS:'}, 'tests/TESTLIST': {'additions': 6, 'deletions': 0, 'changes': 6, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/39582c04cc5e34054b2936b423072fb9df2ff6ef/tests%2FTESTLIST', 'patch': '@@ -554,6 +554,12 @@ radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n ospf6_decode_v3_asan\tospf6_decode_v3_asan.pcap\tospf6_decode_v3_asan.out -v\n ip_ts_opts_asan\t\tip_ts_opts_asan.pcap\t\tip_ts_opts_asan.out\t-v\n isakmpv1-attr-oobr\tisakmpv1-attr-oobr.pcap\t\tisakmpv1-attr-oobr.out\t-v\n+# The case below depends on the bug in print-hncp.c, which at the time of\n+# discovery had codepoints for DHCPv6-Data and DHCPv4-Data swapped around.\n+# After the bugfix the output will be different because of the different\n+# code path and will not test the vulnerability unless modified respectively.\n+# The .pcap file is truncated after the 1st packet.\n+hncp_dhcpv6data-oobr\thncp_dhcpv6data-oobr.pcap\thncp_dhcpv6data-oobr.out -v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out'}, 'tests/hncp_dhcpv6data-oobr.out': {'additions': 7, 'deletions': 0, 'changes': 7, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/39582c04cc5e34054b2936b423072fb9df2ff6ef/tests%2Fhncp_dhcpv6data-oobr.out', 'patch': '@@ -0,0 +1,7 @@\n+IP6 (flowlabel 0x01cc3, hlim 234, next-header UDP (17) payload length: 11025) 400::e4ff:ffff:adf9:8900:0.1646 > 62:9de3:ff47:ebec:8206:ff00:ad:ff00.8231: hncp (11017)\n+\tFuture use: type=16384 (5)\n+\tDHCPv6-Data (25)\n+\t\tUnknown (4)\n+\t\tUnknown (4)\n+\t\tSNTP-servers (61956)  (invalid)\n+\t[|hncp]'}, 'tests/hncp_dhcpv6data-oobr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/39582c04cc5e34054b2936b423072fb9df2ff6ef/tests%2Fhncp_dhcpv6data-oobr.pcap', 'patch': None}}",,"{'additions': 17, 'deletions': 0, 'total': 17}","{'c', 'pcap', 'out'}",{'C/C++'}
"mobility_print(netdissect_options *ndo,
               const u_char *bp, const u_char *bp2 _U_)
{
	const struct ip6_mobility *mh;
	const u_char *ep;
	unsigned mhlen, hlen;
	uint8_t type;

	mh = (const struct ip6_mobility *)bp;

	/* 'ep' points to the end of available data. */
	ep = ndo->ndo_snapend;

	if (!ND_TTEST(mh->ip6m_len)) {
		/*
		 * There's not enough captured data to include the
		 * mobility header length.
		 *
		 * Our caller expects us to return the length, however,
		 * so return a value that will run to the end of the
		 * captured data.
		 *
		 * XXX - ""ip6_print()"" doesn't do anything with the
		 * returned length, however, as it breaks out of the
		 * header-processing loop.
		 */
		mhlen = ep - bp;
		goto trunc;
	}
	mhlen = (mh->ip6m_len + 1) << 3;

	/* XXX ip6m_cksum */

	ND_TCHECK(mh->ip6m_type);
	type = mh->ip6m_type;
	if (type <= IP6M_MAX && mhlen < ip6m_hdrlen[type]) {
		ND_PRINT((ndo, ""(header length %u is too small for type %u)"", mhlen, type));
		goto trunc;
	}
	ND_PRINT((ndo, ""mobility: %s"", tok2str(ip6m_str, ""type-#%u"", type)));
	switch (type) {
	case IP6M_BINDING_REQUEST:
		hlen = IP6M_MINLEN;
		break;
	case IP6M_HOME_TEST_INIT:
	case IP6M_CAREOF_TEST_INIT:
		hlen = IP6M_MINLEN;
		if (ndo->ndo_vflag) {
			ND_TCHECK2(*mh, hlen + 8);
			ND_PRINT((ndo, "" %s Init Cookie=%08x:%08x"",
			       type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"",
			       EXTRACT_32BITS(&bp[hlen]),
			       EXTRACT_32BITS(&bp[hlen + 4])));
		}
		hlen += 8;
		break;
	case IP6M_HOME_TEST:
	case IP6M_CAREOF_TEST:
		ND_TCHECK(mh->ip6m_data16[0]);
		ND_PRINT((ndo, "" nonce id=0x%x"", EXTRACT_16BITS(&mh->ip6m_data16[0])));
		hlen = IP6M_MINLEN;
		if (ndo->ndo_vflag) {
			ND_TCHECK2(*mh, hlen + 8);
			ND_PRINT((ndo, "" %s Init Cookie=%08x:%08x"",
			       type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"",
			       EXTRACT_32BITS(&bp[hlen]),
			       EXTRACT_32BITS(&bp[hlen + 4])));
		}
		hlen += 8;
		if (ndo->ndo_vflag) {
			ND_TCHECK2(*mh, hlen + 8);
			ND_PRINT((ndo, "" %s Keygen Token=%08x:%08x"",
			       type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"",
			       EXTRACT_32BITS(&bp[hlen]),
			       EXTRACT_32BITS(&bp[hlen + 4])));
		}
		hlen += 8;
		break;
	case IP6M_BINDING_UPDATE:
		ND_TCHECK(mh->ip6m_data16[0]);
		ND_PRINT((ndo, "" seq#=%u"", EXTRACT_16BITS(&mh->ip6m_data16[0])));
		hlen = IP6M_MINLEN;
		ND_TCHECK2(*mh, hlen + 1);
		if (bp[hlen] & 0xf0)
			ND_PRINT((ndo, "" ""));
		if (bp[hlen] & 0x80)
			ND_PRINT((ndo, ""A""));
		if (bp[hlen] & 0x40)
			ND_PRINT((ndo, ""H""));
		if (bp[hlen] & 0x20)
			ND_PRINT((ndo, ""L""));
		if (bp[hlen] & 0x10)
			ND_PRINT((ndo, ""K""));
		/* Reserved (4bits) */
		hlen += 1;
		/* Reserved (8bits) */
		hlen += 1;
		ND_TCHECK2(*mh, hlen + 2);
		/* units of 4 secs */
		ND_PRINT((ndo, "" lifetime=%u"", EXTRACT_16BITS(&bp[hlen]) << 2));
		hlen += 2;
		break;
	case IP6M_BINDING_ACK:
		ND_TCHECK(mh->ip6m_data8[0]);
		ND_PRINT((ndo, "" status=%u"", mh->ip6m_data8[0]));
		if (mh->ip6m_data8[1] & 0x80)
			ND_PRINT((ndo, "" K""));
		/* Reserved (7bits) */
		hlen = IP6M_MINLEN;
		ND_TCHECK2(*mh, hlen + 2);
		ND_PRINT((ndo, "" seq#=%u"", EXTRACT_16BITS(&bp[hlen])));
		hlen += 2;
		ND_TCHECK2(*mh, hlen + 2);
		/* units of 4 secs */
		ND_PRINT((ndo, "" lifetime=%u"", EXTRACT_16BITS(&bp[hlen]) << 2));
		hlen += 2;
		break;
	case IP6M_BINDING_ERROR:
		ND_TCHECK(mh->ip6m_data8[0]);
		ND_PRINT((ndo, "" status=%u"", mh->ip6m_data8[0]));
		/* Reserved */
		hlen = IP6M_MINLEN;
		ND_TCHECK2(*mh, hlen + 16);
		ND_PRINT((ndo, "" homeaddr %s"", ip6addr_string(ndo, &bp[hlen])));
		hlen += 16;
		break;
	default:
		ND_PRINT((ndo, "" len=%u"", mh->ip6m_len));
		return(mhlen);
		break;
	}
	if (ndo->ndo_vflag)
		if (mobility_opt_print(ndo, &bp[hlen], mhlen - hlen))
			goto trunc;

	return(mhlen);

 trunc:
	ND_PRINT((ndo, ""%s"", tstr));
	return(-1);
}",1,['CWE-125'],tcpdump,db8c799f6dfc68765c9451fcbfca06e662f5bd5f,244818265819382595252001017766666669750,141,"CVE-2017-13009/IPv6 mobility: Add a bounds check.

This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.

Add a test using the capture file supplied by the reporter(s).

While we're at it:

Add a comment giving the RFC for IPv6 mobility headers.

Clean up some bounds checks to make it clearer what they're checking, by
matching the subsequent EXTRACT_ calls or memcpy.

For the binding update, if none of the flag bits are set, don't check
the individual flag bits.",CVE-2017-13009,CVE-2017-13009,{'CWE-125'},6.4,The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/db8c799f6dfc68765c9451fcbfca06e662f5bd5f'},https://github.com/the-tcpdump-group/tcpdump/commit/db8c799f6dfc68765c9451fcbfca06e662f5bd5f,SINGLE,['5edf405d7ed9fc92f4f43e8a3d44baa4c6387562'],1,db8c799f6dfc68765c9451fcbfca06e662f5bd5f,"03/06/2017, 18:13:22",db8c799f6dfc68765c9451fcbfca06e662f5bd5f,['db8c799f6dfc68765c9451fcbfca06e662f5bd5f'],Guy Harris,"CVE-2017-13009/IPv6 mobility: Add a bounds check.

This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.

Add a test using the capture file supplied by the reporter(s).

While we're at it:

Add a comment giving the RFC for IPv6 mobility headers.

Clean up some bounds checks to make it clearer what they're checking, by
matching the subsequent EXTRACT_ calls or memcpy.

For the binding update, if none of the flag bits are set, don't check
the individual flag bits.","{'print-mobility.c': {'additions': 20, 'deletions': 17, 'changes': 37, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/db8c799f6dfc68765c9451fcbfca06e662f5bd5f/print-mobility.c', 'patch': '@@ -28,6 +28,7 @@\n  */\n \n /* \\summary: IPv6 mobility printer */\n+/* RFC 3775 */\n \n #ifdef HAVE_CONFIG_H\n #include ""config.h""\n@@ -241,7 +242,7 @@ mobility_print(netdissect_options *ndo,\n \tcase IP6M_CAREOF_TEST_INIT:\n \t\thlen = IP6M_MINLEN;\n \t\tif (ndo->ndo_vflag) {\n-\t\t\tND_TCHECK2(*mh, hlen + 8);\n+\t\t\tND_TCHECK_32BITS(&bp[hlen + 4]);\n \t\t\tND_PRINT((ndo, "" %s Init Cookie=%08x:%08x"",\n \t\t\t       type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"",\n \t\t\t       EXTRACT_32BITS(&bp[hlen]),\n@@ -255,15 +256,15 @@ mobility_print(netdissect_options *ndo,\n \t\tND_PRINT((ndo, "" nonce id=0x%x"", EXTRACT_16BITS(&mh->ip6m_data16[0])));\n \t\thlen = IP6M_MINLEN;\n \t\tif (ndo->ndo_vflag) {\n-\t\t\tND_TCHECK2(*mh, hlen + 8);\n+\t\t\tND_TCHECK_32BITS(&bp[hlen + 4]);\n \t\t\tND_PRINT((ndo, "" %s Init Cookie=%08x:%08x"",\n \t\t\t       type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"",\n \t\t\t       EXTRACT_32BITS(&bp[hlen]),\n \t\t\t       EXTRACT_32BITS(&bp[hlen + 4])));\n \t\t}\n \t\thlen += 8;\n \t\tif (ndo->ndo_vflag) {\n-\t\t\tND_TCHECK2(*mh, hlen + 8);\n+\t\t\tND_TCHECK_32BITS(&bp[hlen + 4]);\n \t\t\tND_PRINT((ndo, "" %s Keygen Token=%08x:%08x"",\n \t\t\t       type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"",\n \t\t\t       EXTRACT_32BITS(&bp[hlen]),\n@@ -275,37 +276,39 @@ mobility_print(netdissect_options *ndo,\n \t\tND_TCHECK(mh->ip6m_data16[0]);\n \t\tND_PRINT((ndo, "" seq#=%u"", EXTRACT_16BITS(&mh->ip6m_data16[0])));\n \t\thlen = IP6M_MINLEN;\n-\t\tND_TCHECK2(*mh, hlen + 1);\n-\t\tif (bp[hlen] & 0xf0)\n+\t\tND_TCHECK_16BITS(&bp[hlen]);\n+\t\tif (bp[hlen] & 0xf0) {\n \t\t\tND_PRINT((ndo, "" ""));\n-\t\tif (bp[hlen] & 0x80)\n-\t\t\tND_PRINT((ndo, ""A""));\n-\t\tif (bp[hlen] & 0x40)\n-\t\t\tND_PRINT((ndo, ""H""));\n-\t\tif (bp[hlen] & 0x20)\n-\t\t\tND_PRINT((ndo, ""L""));\n-\t\tif (bp[hlen] & 0x10)\n-\t\t\tND_PRINT((ndo, ""K""));\n+\t\t\tif (bp[hlen] & 0x80)\n+\t\t\t\tND_PRINT((ndo, ""A""));\n+\t\t\tif (bp[hlen] & 0x40)\n+\t\t\t\tND_PRINT((ndo, ""H""));\n+\t\t\tif (bp[hlen] & 0x20)\n+\t\t\t\tND_PRINT((ndo, ""L""));\n+\t\t\tif (bp[hlen] & 0x10)\n+\t\t\t\tND_PRINT((ndo, ""K""));\n+\t\t}\n \t\t/* Reserved (4bits) */\n \t\thlen += 1;\n \t\t/* Reserved (8bits) */\n \t\thlen += 1;\n-\t\tND_TCHECK2(*mh, hlen + 2);\n+\t\tND_TCHECK_16BITS(&bp[hlen]);\n \t\t/* units of 4 secs */\n \t\tND_PRINT((ndo, "" lifetime=%u"", EXTRACT_16BITS(&bp[hlen]) << 2));\n \t\thlen += 2;\n \t\tbreak;\n \tcase IP6M_BINDING_ACK:\n \t\tND_TCHECK(mh->ip6m_data8[0]);\n \t\tND_PRINT((ndo, "" status=%u"", mh->ip6m_data8[0]));\n+\t\tND_TCHECK(mh->ip6m_data8[1]);\n \t\tif (mh->ip6m_data8[1] & 0x80)\n \t\t\tND_PRINT((ndo, "" K""));\n \t\t/* Reserved (7bits) */\n \t\thlen = IP6M_MINLEN;\n-\t\tND_TCHECK2(*mh, hlen + 2);\n+\t\tND_TCHECK_16BITS(&bp[hlen]);\n \t\tND_PRINT((ndo, "" seq#=%u"", EXTRACT_16BITS(&bp[hlen])));\n \t\thlen += 2;\n-\t\tND_TCHECK2(*mh, hlen + 2);\n+\t\tND_TCHECK_16BITS(&bp[hlen]);\n \t\t/* units of 4 secs */\n \t\tND_PRINT((ndo, "" lifetime=%u"", EXTRACT_16BITS(&bp[hlen]) << 2));\n \t\thlen += 2;\n@@ -315,7 +318,7 @@ mobility_print(netdissect_options *ndo,\n \t\tND_PRINT((ndo, "" status=%u"", mh->ip6m_data8[0]));\n \t\t/* Reserved */\n \t\thlen = IP6M_MINLEN;\n-\t\tND_TCHECK2(*mh, hlen + 16);\n+\t\tND_TCHECK2(bp[hlen], 16);\n \t\tND_PRINT((ndo, "" homeaddr %s"", ip6addr_string(ndo, &bp[hlen])));\n \t\thlen += 16;\n \t\tbreak;'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/db8c799f6dfc68765c9451fcbfca06e662f5bd5f/tests%2FTESTLIST', 'patch': '@@ -439,6 +439,7 @@ ieee802.11_tim_ie_oobr\tieee802.11_tim_ie_oobr.pcap\tieee802.11_tim_ie_oobr.out\n decnet-shorthdr-oobr\tdecnet-shorthdr-oobr.pcap\tdecnet-shorthdr-oobr.out\n isakmp-3948-oobr-2\tisakmp-3948-oobr-2.pcap\t\tisakmp-3948-oobr-2.out\n ieee802.11_rates_oobr\tieee802.11_rates_oobr.pcap\tieee802.11_rates_oobr.out\n+ipv6-mobility-header-oobr\tipv6-mobility-header-oobr.pcap\tipv6-mobility-header-oobr.out\n \n # bad packets from Kamil Frankowicz\n snmp-heapoverflow-1\tsnmp-heapoverflow-1.pcap\tsnmp-heapoverflow-1.out'}, 'tests/ipv6-mobility-header-oobr.out': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/db8c799f6dfc68765c9451fcbfca06e662f5bd5f/tests%2Fipv6-mobility-header-oobr.out', 'patch': '@@ -0,0 +1 @@\n+IP6 3030:3030:3030:3030:3030:3030:3030:3030 > 3030:3030:3030:3030:3030:3030:3030:3030: mobility: BA status=48[|MOBILITY]'}, 'tests/ipv6-mobility-header-oobr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/db8c799f6dfc68765c9451fcbfca06e662f5bd5f/tests%2Fipv6-mobility-header-oobr.pcap', 'patch': None}}",,"{'additions': 22, 'deletions': 17, 'total': 39}","{'c', 'pcap', 'out'}",{'C/C++'}
"telnet_parse(netdissect_options *ndo, const u_char *sp, u_int length, int print)
{
	int i, x;
	u_int c;
	const u_char *osp, *p;
#define FETCH(c, sp, length) \
	do { \
		if (length < 1) \
			goto pktend; \
		ND_TCHECK(*sp); \
		c = *sp++; \
		length--; \
	} while (0)

	osp = sp;

	FETCH(c, sp, length);
	if (c != IAC)
		goto pktend;
	FETCH(c, sp, length);
	if (c == IAC) {		/* <IAC><IAC>! */
		if (print)
			ND_PRINT((ndo, ""IAC IAC""));
		goto done;
	}

	i = c - TELCMD_FIRST;
	if (i < 0 || i > IAC - TELCMD_FIRST)
		goto pktend;

	switch (c) {
	case DONT:
	case DO:
	case WONT:
	case WILL:
	case SB:
		/* DONT/DO/WONT/WILL x */
		FETCH(x, sp, length);
		if (x >= 0 && x < NTELOPTS) {
			if (print)
				ND_PRINT((ndo, ""%s %s"", telcmds[i], telopts[x]));
		} else {
			if (print)
				ND_PRINT((ndo, ""%s %#x"", telcmds[i], x));
		}
		if (c != SB)
			break;
		/* IAC SB .... IAC SE */
		p = sp;
		while (length > (u_int)(p + 1 - sp)) {
			ND_TCHECK2(*p, 2);
			if (p[0] == IAC && p[1] == SE)
				break;
			p++;
		}
		if (*p != IAC)
			goto pktend;

		switch (x) {
		case TELOPT_AUTHENTICATION:
			if (p <= sp)
				break;
			FETCH(c, sp, length);
			if (print)
				ND_PRINT((ndo, "" %s"", STR_OR_ID(c, authcmd)));
			if (p <= sp)
				break;
			FETCH(c, sp, length);
			if (print)
				ND_PRINT((ndo, "" %s"", STR_OR_ID(c, authtype)));
			break;
		case TELOPT_ENCRYPT:
			if (p <= sp)
				break;
			FETCH(c, sp, length);
			if (print)
				ND_PRINT((ndo, "" %s"", STR_OR_ID(c, enccmd)));
			if (p <= sp)
				break;
			FETCH(c, sp, length);
			if (print)
				ND_PRINT((ndo, "" %s"", STR_OR_ID(c, enctype)));
			break;
		default:
			if (p <= sp)
				break;
			FETCH(c, sp, length);
			if (print)
				ND_PRINT((ndo, "" %s"", STR_OR_ID(c, cmds)));
			break;
		}
		while (p > sp) {
			FETCH(x, sp, length);
			if (print)
				ND_PRINT((ndo, "" %#x"", x));
		}
		/* terminating IAC SE */
		if (print)
			ND_PRINT((ndo, "" SE""));
		sp += 2;
		break;
	default:
		if (print)
			ND_PRINT((ndo, ""%s"", telcmds[i]));
		goto done;
	}

done:
	return sp - osp;

trunc:
	ND_PRINT((ndo, ""%s"", tstr));
pktend:
	return -1;
#undef FETCH
}",1,"['CWE-125', 'CWE-787']",tcpdump,8934a7d6307267d301182f19ed162563717e29e3,63633160340098841772242357153640194563,116,"CVE-2017-12988/TELNET: Add a missing bounds check.

This fixes a buffer over-read discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomäki.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-12988,CVE-2017-12988,{'CWE-125'},6.4,The telnet parser in tcpdump before 4.9.2 has a buffer over-read in print-telnet.c:telnet_parse().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/8934a7d6307267d301182f19ed162563717e29e3'},https://github.com/the-tcpdump-group/tcpdump/commit/8934a7d6307267d301182f19ed162563717e29e3,SINGLE,['c2ef693866beae071a24b45c49f9674af1df4028'],1,8934a7d6307267d301182f19ed162563717e29e3,"02/06/2017, 23:13:05",8934a7d6307267d301182f19ed162563717e29e3,['8934a7d6307267d301182f19ed162563717e29e3'],Guy Harris,"CVE-2017-12988/TELNET: Add a missing bounds check.

This fixes a buffer over-read discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomäki.

Add a test using the capture file supplied by the reporter(s).","{'print-telnet.c': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/8934a7d6307267d301182f19ed162563717e29e3/print-telnet.c', 'patch': '@@ -442,6 +442,7 @@ telnet_parse(netdissect_options *ndo, const u_char *sp, u_int length, int print)\n \t\t\t\tbreak;\n \t\t\tp++;\n \t\t}\n+\t\tND_TCHECK(*p);\n \t\tif (*p != IAC)\n \t\t\tgoto pktend;'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/8934a7d6307267d301182f19ed162563717e29e3/tests%2FTESTLIST', 'patch': '@@ -466,6 +466,7 @@ eigrp-tlv-oobr\t\teigrp-tlv-oobr.pcap\t\teigrp-tlv-oobr.out\t-vvv -e\n zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n bgp-as-path-oobr\tbgp-as-path-oobr.pcap\t\tbgp-as-path-oobr.out\t-vvv -e\n isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n+telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap'}, 'tests/telnet-iac-check-oobr.out': {'additions': 2, 'deletions': 0, 'changes': 2, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/8934a7d6307267d301182f19ed162563717e29e3/tests%2Ftelnet-iac-check-oobr.out', 'patch': None}, 'tests/telnet-iac-check-oobr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/8934a7d6307267d301182f19ed162563717e29e3/tests%2Ftelnet-iac-check-oobr.pcap', 'patch': None}}",,"{'additions': 4, 'deletions': 0, 'total': 4}","{'c', 'pcap', 'out'}",{'C/C++'}
"frag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)
{
	register const struct ip6_frag *dp;
	register const struct ip6_hdr *ip6;

	dp = (const struct ip6_frag *)bp;
	ip6 = (const struct ip6_hdr *)bp2;

	ND_TCHECK(dp->ip6f_offlg);

	if (ndo->ndo_vflag) {
		ND_PRINT((ndo, ""frag (0x%08x:%d|%ld)"",
		       EXTRACT_32BITS(&dp->ip6f_ident),
		       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,
		       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -
			       (long)(bp - bp2) - sizeof(struct ip6_frag)));
	} else {
		ND_PRINT((ndo, ""frag (%d|%ld)"",
		       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,
		       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -
			       (long)(bp - bp2) - sizeof(struct ip6_frag)));
	}

	/* it is meaningless to decode non-first fragment */
	if ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)
		return -1;
	else
	{
		ND_PRINT((ndo, "" ""));
		return sizeof(struct ip6_frag);
	}
trunc:
	ND_PRINT((ndo, ""[|frag]""));
	return -1;
}",1,"['CWE-125', 'CWE-787']",tcpdump,2d669862df7cd17f539129049f6fb70d17174125,282174911102190370662913308615639737307,35,"CVE-2017-13031/Check for the presence of the entire IPv6 fragment header.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.

Clean up some whitespace in tests/TESTLIST while we're at it.",CVE-2017-13031,CVE-2017-13031,{'CWE-125'},6.4,The IPv6 fragmentation header parser in tcpdump before 4.9.2 has a buffer over-read in print-frag6.c:frag6_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/2d669862df7cd17f539129049f6fb70d17174125'},https://github.com/the-tcpdump-group/tcpdump/commit/2d669862df7cd17f539129049f6fb70d17174125,SINGLE,['eb8c0d4636363c881503d9c091604fbf785725eb'],1,2d669862df7cd17f539129049f6fb70d17174125,"03/22/2017, 21:55:12",2d669862df7cd17f539129049f6fb70d17174125,['2d669862df7cd17f539129049f6fb70d17174125'],Guy Harris,"CVE-2017-13031/Check for the presence of the entire IPv6 fragment header.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.

Clean up some whitespace in tests/TESTLIST while we're at it.","{'print-frag6.c': {'additions': 1, 'deletions': 1, 'changes': 2, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/2d669862df7cd17f539129049f6fb70d17174125/print-frag6.c', 'patch': '@@ -41,7 +41,7 @@ frag6_print(netdissect_options *ndo, register const u_char *bp, register const u\n \tdp = (const struct ip6_frag *)bp;\n \tip6 = (const struct ip6_hdr *)bp2;\n \n-\tND_TCHECK(dp->ip6f_offlg);\n+\tND_TCHECK(*dp);\n \n \tif (ndo->ndo_vflag) {\n \t\tND_PRINT((ndo, ""frag (0x%08x:%d|%ld)"",'}, 'tests/TESTLIST': {'additions': 4, 'deletions': 3, 'changes': 7, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/2d669862df7cd17f539129049f6fb70d17174125/tests%2FTESTLIST', 'patch': '@@ -536,9 +536,10 @@ isis_stlv_asan-4\tisis_stlv_asan-4.pcap\t\tisis_stlv_asan-4.out\t-v\n lldp_mgmt_addr_tlv_asan\tlldp_mgmt_addr_tlv_asan.pcap\tlldp_mgmt_addr_tlv_asan.out\t-v\n bootp_asan\t\tbootp_asan.pcap\t\t\tbootp_asan.out\t\t-v\n ppp_ccp_config_deflate_option_asan\tppp_ccp_config_deflate_option_asan.pcap\tppp_ccp_config_deflate_option_asan.out\t-v\n-pim_header_asan\t\tpim_header_asan.pcap\t\tpim_header_asan.out\t\t-v\n-pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t\t-v\n-pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t\t-v\n+pim_header_asan\t\tpim_header_asan.pcap\t\tpim_header_asan.out\t-v\n+pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t-v\n+pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t-v\n+ip6_frag_asan\t\tip6_frag_asan.pcap\t\tip6_frag_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap'}, 'tests/ip6_frag_asan.out': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/2d669862df7cd17f539129049f6fb70d17174125/tests%2Fip6_frag_asan.out', 'patch': '@@ -0,0 +1 @@\n+IP6 (class 0x51, flowlabel 0xb2100, hlim 16, next-header Fragment (44) payload length: 27136) 452:22:19:0:41a:e4ff:10ff:484d > 2243:80:1400:100:19:ffff:ffff:fffb: [|frag]'}, 'tests/ip6_frag_asan.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/2d669862df7cd17f539129049f6fb70d17174125/tests%2Fip6_frag_asan.pcap', 'patch': None}}",,"{'additions': 6, 'deletions': 4, 'total': 10}","{'c', 'pcap', 'out'}",{'C/C++'}
"xid_map_enter(netdissect_options *ndo,
              const struct sunrpc_msg *rp, const u_char *bp)
{
	const struct ip *ip = NULL;
	const struct ip6_hdr *ip6 = NULL;
	struct xid_map_entry *xmep;

	if (!ND_TTEST(rp->rm_call.cb_vers))
		return (0);
	switch (IP_V((const struct ip *)bp)) {
	case 4:
		ip = (const struct ip *)bp;
		break;
	case 6:
		ip6 = (const struct ip6_hdr *)bp;
		break;
	default:
		return (1);
	}

	xmep = &xid_map[xid_map_next];

	if (++xid_map_next >= XIDMAPSIZE)
		xid_map_next = 0;

	UNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));
	if (ip) {
		xmep->ipver = 4;
		UNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));
		UNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));
	}
	else if (ip6) {
		xmep->ipver = 6;
		UNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));
		UNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));
	}
	xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
	return (1);
}",1,"['CWE-125', 'CWE-787']",tcpdump,b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd,167922544407469853070640884160752053478,40,"CVE-2017-13005/NFS: Add two bounds checks before fetching data

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-13005,CVE-2017-13005,{'CWE-125'},6.4,The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:xid_map_enter().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd'},https://github.com/the-tcpdump-group/tcpdump/commit/b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd,SINGLE,['35d146b7a66496d72cdeb95ccb33ab80a265ce90'],1,b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd,"02/23/2017, 15:50:18",b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd,['b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd'],Francois-Xavier Le Bail,"CVE-2017-13005/NFS: Add two bounds checks before fetching data

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add a test using the capture file supplied by the reporter(s).","{'print-nfs.c': {'additions': 4, 'deletions': 0, 'changes': 4, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd/print-nfs.c', 'patch': '@@ -899,7 +899,11 @@ xid_map_enter(netdissect_options *ndo,\n \t\tUNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));\n \t\tUNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));\n \t}\n+\tif (!ND_TTEST(rp->rm_call.cb_proc))\n+\t\treturn (0);\n \txmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);\n+\tif (!ND_TTEST(rp->rm_call.cb_vers))\n+\t\treturn (0);\n \txmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);\n \treturn (1);\n }'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd/tests%2FTESTLIST', 'patch': '@@ -461,6 +461,7 @@ hoobr_lookup_nsap\thoobr_lookup_nsap.pcap\t\thoobr_lookup_nsap.out\n hoobr_rt6_print\t\thoobr_rt6_print.pcap\t\thoobr_rt6_print.out\n hoobr_nfs_printfh\thoobr_nfs_printfh.pcap\t\thoobr_nfs_printfh.out\n hoobr_aodv_extension\thoobr_aodv_extension.pcap\thoobr_aodv_extension.out\n+hoobr_nfs_xid_map_enter hoobr_nfs_xid_map_enter.pcap    hoobr_nfs_xid_map_enter.out\n \n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve'}, 'tests/hoobr_nfs_xid_map_enter.out': {'additions': 41, 'deletions': 0, 'changes': 41, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd/tests%2Fhoobr_nfs_xid_map_enter.out', 'patch': '@@ -0,0 +1,41 @@\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+IP 48.48.48.48.12336 > 48.48.48.48.2049: NFS request xid 808464432 12308 [|nfs]'}, 'tests/hoobr_nfs_xid_map_enter.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd/tests%2Fhoobr_nfs_xid_map_enter.pcap', 'patch': None}}",,"{'additions': 46, 'deletions': 0, 'total': 46}","{'c', 'pcap', 'out'}",{'C/C++'}
"ikev1_id_print(netdissect_options *ndo, u_char tpay _U_,
	       const struct isakmp_gen *ext, u_int item_len,
	       const u_char *ep _U_, uint32_t phase, uint32_t doi _U_,
	       uint32_t proto _U_, int depth _U_)
{
#define USE_IPSECDOI_IN_PHASE1	1
	const struct ikev1_pl_id *p;
	struct ikev1_pl_id id;
	static const char *idtypestr[] = {
		""IPv4"", ""IPv4net"", ""IPv6"", ""IPv6net"",
	};
	static const char *ipsecidtypestr[] = {
		NULL, ""IPv4"", ""FQDN"", ""user FQDN"", ""IPv4net"", ""IPv6"",
		""IPv6net"", ""IPv4range"", ""IPv6range"", ""ASN1 DN"", ""ASN1 GN"",
		""keyid"",
	};
	int len;
	const u_char *data;

	ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_ID)));

	p = (const struct ikev1_pl_id *)ext;
	ND_TCHECK(*p);
	UNALIGNED_MEMCPY(&id, ext, sizeof(id));
	if (sizeof(*p) < item_len) {
		data = (const u_char *)(p + 1);
		len = item_len - sizeof(*p);
	} else {
		data = NULL;
		len = 0;
	}

#if 0 /*debug*/
	ND_PRINT((ndo,"" [phase=%d doi=%d proto=%d]"", phase, doi, proto));
#endif
	switch (phase) {
#ifndef USE_IPSECDOI_IN_PHASE1
	case 1:
#endif
	default:
		ND_PRINT((ndo,"" idtype=%s"", STR_OR_ID(id.d.id_type, idtypestr)));
		ND_PRINT((ndo,"" doi_data=%u"",
			  (uint32_t)(ntohl(id.d.doi_data) & 0xffffff)));
		break;

#ifdef USE_IPSECDOI_IN_PHASE1
	case 1:
#endif
	case 2:
	    {
		const struct ipsecdoi_id *doi_p;
		struct ipsecdoi_id doi_id;
		const char *p_name;

		doi_p = (const struct ipsecdoi_id *)ext;
		ND_TCHECK(*doi_p);
		UNALIGNED_MEMCPY(&doi_id, ext, sizeof(doi_id));
		ND_PRINT((ndo,"" idtype=%s"", STR_OR_ID(doi_id.type, ipsecidtypestr)));
		/* A protocol ID of 0 DOES NOT mean IPPROTO_IP! */
		if (!ndo->ndo_nflag && doi_id.proto_id && (p_name = netdb_protoname(doi_id.proto_id)) != NULL)
			ND_PRINT((ndo,"" protoid=%s"", p_name));
		else
			ND_PRINT((ndo,"" protoid=%u"", doi_id.proto_id));
		ND_PRINT((ndo,"" port=%d"", ntohs(doi_id.port)));
		if (!len)
			break;
		if (data == NULL)
			goto trunc;
		ND_TCHECK2(*data, len);
		switch (doi_id.type) {
		case IPSECDOI_ID_IPV4_ADDR:
			if (len < 4)
				ND_PRINT((ndo,"" len=%d [bad: < 4]"", len));
			else
				ND_PRINT((ndo,"" len=%d %s"", len, ipaddr_string(ndo, data)));
			len = 0;
			break;
		case IPSECDOI_ID_FQDN:
		case IPSECDOI_ID_USER_FQDN:
		    {
			int i;
			ND_PRINT((ndo,"" len=%d "", len));
			for (i = 0; i < len; i++)
				safeputchar(ndo, data[i]);
			len = 0;
			break;
		    }
		case IPSECDOI_ID_IPV4_ADDR_SUBNET:
		    {
			const u_char *mask;
			if (len < 8)
				ND_PRINT((ndo,"" len=%d [bad: < 8]"", len));
			else {
				mask = data + sizeof(struct in_addr);
				ND_PRINT((ndo,"" len=%d %s/%u.%u.%u.%u"", len,
					  ipaddr_string(ndo, data),
					  mask[0], mask[1], mask[2], mask[3]));
			}
			len = 0;
			break;
		    }
		case IPSECDOI_ID_IPV6_ADDR:
			if (len < 16)
				ND_PRINT((ndo,"" len=%d [bad: < 16]"", len));
			else
				ND_PRINT((ndo,"" len=%d %s"", len, ip6addr_string(ndo, data)));
			len = 0;
			break;
		case IPSECDOI_ID_IPV6_ADDR_SUBNET:
		    {
			const u_char *mask;
			if (len < 20)
				ND_PRINT((ndo,"" len=%d [bad: < 20]"", len));
			else {
				mask = (const u_char *)(data + sizeof(struct in6_addr));
				/*XXX*/
				ND_PRINT((ndo,"" len=%d %s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"", len,
					  ip6addr_string(ndo, data),
					  mask[0], mask[1], mask[2], mask[3],
					  mask[4], mask[5], mask[6], mask[7],
					  mask[8], mask[9], mask[10], mask[11],
					  mask[12], mask[13], mask[14], mask[15]));
			}
			len = 0;
			break;
		    }
		case IPSECDOI_ID_IPV4_ADDR_RANGE:
			if (len < 8)
				ND_PRINT((ndo,"" len=%d [bad: < 8]"", len));
			else {
				ND_PRINT((ndo,"" len=%d %s-%s"", len,
					  ipaddr_string(ndo, data),
					  ipaddr_string(ndo, data + sizeof(struct in_addr))));
			}
			len = 0;
			break;
		case IPSECDOI_ID_IPV6_ADDR_RANGE:
			if (len < 32)
				ND_PRINT((ndo,"" len=%d [bad: < 32]"", len));
			else {
				ND_PRINT((ndo,"" len=%d %s-%s"", len,
					  ip6addr_string(ndo, data),
					  ip6addr_string(ndo, data + sizeof(struct in6_addr))));
			}
			len = 0;
			break;
		case IPSECDOI_ID_DER_ASN1_DN:
		case IPSECDOI_ID_DER_ASN1_GN:
		case IPSECDOI_ID_KEY_ID:
			break;
		}
		break;
	    }
	}
	if (data && len) {
		ND_PRINT((ndo,"" len=%d"", len));
		if (2 < ndo->ndo_vflag) {
			ND_PRINT((ndo,"" ""));
			if (!rawprint(ndo, (const uint8_t *)data, len))
				goto trunc;
		}
	}
	return (const u_char *)ext + item_len;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_ID)));
	return NULL;
}",1,"['CWE-125', 'CWE-787']",tcpdump,061e7371a944588f231cb1b66d6fb070b646e376,104053946992579029069224501976059159802,167,"CVE-2017-13689/IKEv1: Fix addr+subnet length check.

An IPv6 address plus subnet mask is 32 bytes, not 20 bytes.
16 bytes of IPv6 address, 16 bytes of subnet mask.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-13689,CVE-2017-13689,{'CWE-125'},6.4,The IKEv1 parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c:ikev1_id_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/061e7371a944588f231cb1b66d6fb070b646e376'},https://github.com/the-tcpdump-group/tcpdump/commit/061e7371a944588f231cb1b66d6fb070b646e376,SINGLE,['0cb1b8a434b599b8d636db029aadb757c24e39d6'],1,061e7371a944588f231cb1b66d6fb070b646e376,"08/24/2017, 03:45:39",061e7371a944588f231cb1b66d6fb070b646e376,['061e7371a944588f231cb1b66d6fb070b646e376'],Guy Harris,"CVE-2017-13689/IKEv1: Fix addr+subnet length check.

An IPv6 address plus subnet mask is 32 bytes, not 20 bytes.
16 bytes of IPv6 address, 16 bytes of subnet mask.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).","{'print-isakmp.c': {'additions': 2, 'deletions': 2, 'changes': 4, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/061e7371a944588f231cb1b66d6fb070b646e376/print-isakmp.c', 'patch': '@@ -1435,8 +1435,8 @@ ikev1_id_print(netdissect_options *ndo, u_char tpay _U_,\n \t\tcase IPSECDOI_ID_IPV6_ADDR_SUBNET:\n \t\t    {\n \t\t\tconst u_char *mask;\n-\t\t\tif (len < 20)\n-\t\t\t\tND_PRINT((ndo,"" len=%d [bad: < 20]"", len));\n+\t\t\tif (len < 32)\n+\t\t\t\tND_PRINT((ndo,"" len=%d [bad: < 32]"", len));\n \t\t\telse {\n \t\t\t\tmask = (const u_char *)(data + sizeof(struct in6_addr));\n \t\t\t\t/*XXX*/'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/061e7371a944588f231cb1b66d6fb070b646e376/tests%2FTESTLIST', 'patch': '@@ -577,6 +577,7 @@ cfm_sender_id-oobr\tcfm_sender_id-oobr.pcap\tcfm_sender_id-oobr.out\t-v -c1\n isis-extd-isreach-oobr\tisis-extd-isreach-oobr.pcap\tisis-extd-isreach-oobr.out -v -c4\n olsr-oobr-1\t\tolsr-oobr-1.pcap\t\tolsr-oobr-1.out\t-v\n olsr-oobr-2\t\tolsr-oobr-2.pcap\t\tolsr-oobr-2.out\t-v\n+ikev1_id_ipv6_addr_subnet-oobr\tikev1_id_ipv6_addr_subnet-oobr.pcap\tikev1_id_ipv6_addr_subnet-oobr.out\t-v\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out'}, 'tests/ikev1_id_ipv6_addr_subnet-oobr.out': {'additions': 3, 'deletions': 0, 'changes': 3, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/061e7371a944588f231cb1b66d6fb070b646e376/tests%2Fikev1_id_ipv6_addr_subnet-oobr.out', 'patch': '@@ -0,0 +1,3 @@\n+IP (tos 0x0, ttl 100, id 40207, offset 0, flags [+, DF, rsvd], proto UDP (17), length 32808, bad cksum 8e7f (->bc78)!)\n+    16.0.128.20.500 > 12.251.0.45.0: isakmp 1.0 msgid 0d101010: phase 2/others ? #16[]:\n+    (id: idtype=IPv6net protoid=16 port=4112 len=24 [bad: < 32]) [|#145] (len mismatch: isakmp 4278190080/ip 4856)'}, 'tests/ikev1_id_ipv6_addr_subnet-oobr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/061e7371a944588f231cb1b66d6fb070b646e376/tests%2Fikev1_id_ipv6_addr_subnet-oobr.pcap', 'patch': None}}",,"{'additions': 6, 'deletions': 2, 'total': 8}","{'c', 'pcap', 'out'}",{'C/C++'}
"ospf6_decode_v3(netdissect_options *ndo,
                register const struct ospf6hdr *op,
                register const u_char *dataend)
{
	register const rtrid_t *ap;
	register const struct lsr6 *lsrp;
	register const struct lsa6_hdr *lshp;
	register const struct lsa6 *lsap;
	register int i;

	switch (op->ospf6_type) {

	case OSPF_TYPE_HELLO: {
		register const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);

		ND_PRINT((ndo, ""\n\tOptions [%s]"",
		          bittok2str(ospf6_option_values, ""none"",
		          EXTRACT_32BITS(&hellop->hello_options))));

		ND_TCHECK(hellop->hello_deadint);
		ND_PRINT((ndo, ""\n\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u"",
		          EXTRACT_16BITS(&hellop->hello_helloint),
		          EXTRACT_16BITS(&hellop->hello_deadint),
		          ipaddr_string(ndo, &hellop->hello_ifid),
		          hellop->hello_priority));

		ND_TCHECK(hellop->hello_dr);
		if (EXTRACT_32BITS(&hellop->hello_dr) != 0)
			ND_PRINT((ndo, ""\n\t  Designated Router %s"",
			    ipaddr_string(ndo, &hellop->hello_dr)));
		ND_TCHECK(hellop->hello_bdr);
		if (EXTRACT_32BITS(&hellop->hello_bdr) != 0)
			ND_PRINT((ndo, "", Backup Designated Router %s"",
			    ipaddr_string(ndo, &hellop->hello_bdr)));
		if (ndo->ndo_vflag > 1) {
			ND_PRINT((ndo, ""\n\t  Neighbor List:""));
			ap = hellop->hello_neighbor;
			while ((const u_char *)ap < dataend) {
				ND_TCHECK(*ap);
				ND_PRINT((ndo, ""\n\t    %s"", ipaddr_string(ndo, ap)));
				++ap;
			}
		}
		break;	/* HELLO */
	}

	case OSPF_TYPE_DD: {
		register const struct dd6 *ddp = (const struct dd6 *)((const uint8_t *)op + OSPF6HDR_LEN);

		ND_TCHECK(ddp->db_options);
		ND_PRINT((ndo, ""\n\tOptions [%s]"",
		          bittok2str(ospf6_option_values, ""none"",
		          EXTRACT_32BITS(&ddp->db_options))));
		ND_TCHECK(ddp->db_flags);
		ND_PRINT((ndo, "", DD Flags [%s]"",
		          bittok2str(ospf6_dd_flag_values,""none"",ddp->db_flags)));

		ND_TCHECK(ddp->db_seq);
		ND_PRINT((ndo, "", MTU %u, DD-Sequence 0x%08x"",
                       EXTRACT_16BITS(&ddp->db_mtu),
                       EXTRACT_32BITS(&ddp->db_seq)));
		if (ndo->ndo_vflag > 1) {
			/* Print all the LS adv's */
			lshp = ddp->db_lshdr;
			while ((const u_char *)lshp < dataend) {
				if (ospf6_print_lshdr(ndo, lshp++, dataend))
					goto trunc;
			}
		}
		break;
	}

	case OSPF_TYPE_LS_REQ:
		if (ndo->ndo_vflag > 1) {
			lsrp = (const struct lsr6 *)((const uint8_t *)op + OSPF6HDR_LEN);
			while ((const u_char *)lsrp < dataend) {
				ND_TCHECK(*lsrp);
				ND_PRINT((ndo, ""\n\t  Advertising Router %s"",
				          ipaddr_string(ndo, &lsrp->ls_router)));
				ospf6_print_ls_type(ndo, EXTRACT_16BITS(&lsrp->ls_type),
                                                    &lsrp->ls_stateid);
				++lsrp;
			}
		}
		break;

	case OSPF_TYPE_LS_UPDATE:
		if (ndo->ndo_vflag > 1) {
			register const struct lsu6 *lsup = (const struct lsu6 *)((const uint8_t *)op + OSPF6HDR_LEN);

			ND_TCHECK(lsup->lsu_count);
			i = EXTRACT_32BITS(&lsup->lsu_count);
			lsap = lsup->lsu_lsa;
			while ((const u_char *)lsap < dataend && i--) {
				if (ospf6_print_lsa(ndo, lsap, dataend))
					goto trunc;
				lsap = (const struct lsa6 *)((const u_char *)lsap +
				    EXTRACT_16BITS(&lsap->ls_hdr.ls_length));
			}
		}
		break;

	case OSPF_TYPE_LS_ACK:
		if (ndo->ndo_vflag > 1) {
			lshp = (const struct lsa6_hdr *)((const uint8_t *)op + OSPF6HDR_LEN);
			while ((const u_char *)lshp < dataend) {
				if (ospf6_print_lshdr(ndo, lshp++, dataend))
					goto trunc;
			}
		}
		break;

	default:
		break;
	}
	return (0);
trunc:
	return (1);
}",1,"['CWE-125', 'CWE-787']",tcpdump,88b2dac837e81cf56dce05e6e7b5989332c0092d,11393459653694775097808715840371594183,119,"CVE-2017-13036/OSPFv3: Add a bounds check before fetching data

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.",CVE-2017-13036,CVE-2017-13036,{'CWE-125'},6.4,The OSPFv3 parser in tcpdump before 4.9.2 has a buffer over-read in print-ospf6.c:ospf6_decode_v3().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/88b2dac837e81cf56dce05e6e7b5989332c0092d'},https://github.com/the-tcpdump-group/tcpdump/commit/88b2dac837e81cf56dce05e6e7b5989332c0092d,SINGLE,['571a6f33f47e7a2394fa08f925e534135c29cf1e'],1,88b2dac837e81cf56dce05e6e7b5989332c0092d,"03/23/2017, 23:55:18",88b2dac837e81cf56dce05e6e7b5989332c0092d,['88b2dac837e81cf56dce05e6e7b5989332c0092d'],Francois-Xavier Le Bail,"CVE-2017-13036/OSPFv3: Add a bounds check before fetching data

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.","{'print-ospf6.c': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/88b2dac837e81cf56dce05e6e7b5989332c0092d/print-ospf6.c', 'patch': '@@ -735,6 +735,7 @@ ospf6_decode_v3(netdissect_options *ndo,\n \tcase OSPF_TYPE_HELLO: {\n \t\tregister const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n \n+\t\tND_TCHECK_32BITS(&hellop->hello_options);\n \t\tND_PRINT((ndo, ""\\n\\tOptions [%s]"",\n \t\t          bittok2str(ospf6_option_values, ""none"",\n \t\t          EXTRACT_32BITS(&hellop->hello_options))));'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/88b2dac837e81cf56dce05e6e7b5989332c0092d/tests%2FTESTLIST', 'patch': '@@ -549,6 +549,7 @@ pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t-v\n pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t-v\n ip6_frag_asan\t\tip6_frag_asan.pcap\t\tip6_frag_asan.out\t-v\n radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n+ospf6_decode_v3_asan\tospf6_decode_v3_asan.pcap\tospf6_decode_v3_asan.out -v\n \n # RTP tests\n # fuzzed pcap'}, 'tests/ospf6_decode_v3_asan.out': {'additions': 2, 'deletions': 0, 'changes': 2, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/88b2dac837e81cf56dce05e6e7b5989332c0092d/tests%2Fospf6_decode_v3_asan.out', 'patch': '@@ -0,0 +1,2 @@\n+IP6 (class 0x76, flowlabel 0xf6701, hlim 109, next-header OSPF (89) payload length: 30311) 6767:6780:6767:a102:4:b6:5853:f040 > 1000:a32:8847:1::116: OSPFv3, Hello, length 30311\n+\tRouter-ID 1.1.0.34, Area 0.255.2.2, Instance 82 [|ospf3]'}, 'tests/ospf6_decode_v3_asan.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/88b2dac837e81cf56dce05e6e7b5989332c0092d/tests%2Fospf6_decode_v3_asan.pcap', 'patch': None}}",,"{'additions': 4, 'deletions': 0, 'total': 4}","{'c', 'pcap', 'out'}",{'C/C++'}
"resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)
{
    int result;
    u_char c;
    int saw_digit;
    int neg;
    int too_large;

    if (len == 0)
        goto trunc;
    ND_TCHECK(*bp);
    too_large = 0;
    neg = 0;
    if (*bp == '-') {
        neg = 1;
        bp++;
        len--;
    }
    result = 0;
    saw_digit = 0;

    for (;;) {
        if (len == 0)
            goto trunc;
        ND_TCHECK(*bp);
        c = *bp;
        if (!(c >= '0' && c <= '9')) {
            if (!saw_digit)
                goto invalid;
            break;
        }
        c -= '0';
        if (result > (INT_MAX / 10)) {
            /* This will overflow an int when we multiply it by 10. */
            too_large = 1;
        } else {
            result *= 10;
            if (result == INT_MAX && c > (INT_MAX % 10)) {
                /* This will overflow an int when we add c */
                too_large = 1;
            } else
                result += c;
        }
        bp++;
        len--;
        saw_digit = 1;
    }
    if (!saw_digit)
        goto invalid;

    /*
     * OK, the next thing should be \r\n.
     */
    if (len == 0)
        goto trunc;
    ND_TCHECK(*bp);
    if (*bp != '\r')
        goto invalid;
    bp++;
    len--;
    if (len == 0)
        goto trunc;
    ND_TCHECK(*bp);
    if (*bp != '\n')
        goto invalid;
    bp++;
    len--;
    *endp = bp;
    if (neg) {
        /* -1 means ""null"", anything else is invalid */
        if (too_large || result != 1)
            return (-4);
        result = -1;
    }
    return (too_large ? -3 : result);

trunc:
    return (-2);

invalid:
    return (-5);
}",1,"['CWE-399', 'CWE-835']",tcpdump,db24063b01cba8e9d4d88b7d8ac70c9000c104e4,180203543260106666410980288455093949710,82,"CVE-2017-12989/RESP: Make sure resp_get_length() advances the pointer for invalid lengths.

Make sure that it always sends *endp before returning and that, for
invalid lengths where we don't like a character in the length string,
what it sets *endp to is past the character in question, so we don't
run the risk of infinitely looping (or doing something else random) if a
character in the length is invalid.

This fixes an infinite loop discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomäki.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-12989,CVE-2017-12989,{'CWE-835'},2.9,The RESP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-resp.c:resp_get_length().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/db24063b01cba8e9d4d88b7d8ac70c9000c104e4'},https://github.com/the-tcpdump-group/tcpdump/commit/db24063b01cba8e9d4d88b7d8ac70c9000c104e4,SINGLE,['2ecb9d2c67d9119250c54811a6ce4d0f2ddf44f1'],1,db24063b01cba8e9d4d88b7d8ac70c9000c104e4,"02/07/2017, 08:13:33",db24063b01cba8e9d4d88b7d8ac70c9000c104e4,['db24063b01cba8e9d4d88b7d8ac70c9000c104e4'],Guy Harris,"CVE-2017-12989/RESP: Make sure resp_get_length() advances the pointer for invalid lengths.

Make sure that it always sends *endp before returning and that, for
invalid lengths where we don't like a character in the length string,
what it sets *endp to is past the character in question, so we don't
run the risk of infinitely looping (or doing something else random) if a
character in the length is invalid.

This fixes an infinite loop discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomäki.

Add a test using the capture file supplied by the reporter(s).","{'print-resp.c': {'additions': 11, 'deletions': 3, 'changes': 14, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/db24063b01cba8e9d4d88b7d8ac70c9000c104e4/print-resp.c', 'patch': ""@@ -481,8 +481,10 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con\n         ND_TCHECK(*bp);\n         c = *bp;\n         if (!(c >= '0' && c <= '9')) {\n-            if (!saw_digit)\n+            if (!saw_digit) {\n+                bp++;\n                 goto invalid;\n+            }\n             break;\n         }\n         c -= '0';\n@@ -510,15 +512,19 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n-    if (*bp != '\\r')\n+    if (*bp != '\\r') {\n+        bp++;\n         goto invalid;\n+    }\n     bp++;\n     len--;\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n-    if (*bp != '\\n')\n+    if (*bp != '\\n') {\n+        bp++;\n         goto invalid;\n+    }\n     bp++;\n     len--;\n     *endp = bp;\n@@ -531,8 +537,10 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con\n     return (too_large ? -3 : result);\n \n trunc:\n+    *endp = bp;\n     return (-2);\n \n invalid:\n+    *endp = bp;\n     return (-5);\n }""}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/db24063b01cba8e9d4d88b7d8ac70c9000c104e4/tests%2FTESTLIST', 'patch': '@@ -468,6 +468,7 @@ zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n bgp-as-path-oobr\tbgp-as-path-oobr.pcap\t\tbgp-as-path-oobr.out\t-vvv -e\n isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n+resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap'}, 'tests/resp_4_infiniteloop.out': {'additions': 2, 'deletions': 0, 'changes': 2, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/db24063b01cba8e9d4d88b7d8ac70c9000c104e4/tests%2Fresp_4_infiniteloop.out', 'patch': '@@ -0,0 +1,2 @@\n+00:50:56:b4:08:69 > 00:50:56:b4:4c:2a, ethertype IPv4 (0x0800), length 920: (tos 0x0, ttl 64, id 27576, offset 0, flags [DF], proto TCP (6), length 906)\n+    172.16.8.77.33926 > 172.16.8.149.6379: Flags [P.], cksum 0xa129 (incorrect -> 0xaaa0), seq 3839414413:3839415267, ack 2526552240, win 229, options [nop,nop,TS val 2407226 ecr 24894817], length 854: RESP length negative and not -1 invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid ""4"" ""EVAL"" invalid invalid invalid invalid ""GKMbNZq^@0"" ""stuubt.pack(\'<ivdMFG4294967245\',^V \'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'319\', 2\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\',\', \'-1494241318543828858\')\'L\')N))\'r\')\')~D\')\')E)\')\')\')\')\')\')\')\'l\')\')\')\')\')\'M-`\'o\')\')\'Pp)U)"" invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid ""1"" [|RESP]'}, 'tests/resp_4_infiniteloop.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/db24063b01cba8e9d4d88b7d8ac70c9000c104e4/tests%2Fresp_4_infiniteloop.pcap', 'patch': None}}",,"{'additions': 14, 'deletions': 3, 'total': 17}","{'c', 'pcap', 'out'}",{'C/C++'}
"ubik_print(netdissect_options *ndo,
           register const u_char *bp)
{
	int ubik_op;
	int32_t temp;

	/*
	 * Print out the afs call we're invoking.  The table used here was
	 * gleaned from ubik/ubik_int.xg
	 */

	ubik_op = EXTRACT_32BITS(bp + sizeof(struct rx_header));

	ND_PRINT((ndo, "" ubik call %s"", tok2str(ubik_req, ""op#%d"", ubik_op)));

	/*
	 * Decode some of the arguments to the Ubik calls
	 */

	bp += sizeof(struct rx_header) + 4;

	switch (ubik_op) {
		case 10000:		/* Beacon */
			ND_TCHECK2(bp[0], 4);
			temp = EXTRACT_32BITS(bp);
			bp += sizeof(int32_t);
			ND_PRINT((ndo, "" syncsite %s"", temp ? ""yes"" : ""no""));
			ND_PRINT((ndo, "" votestart""));
			DATEOUT();
			ND_PRINT((ndo, "" dbversion""));
			UBIK_VERSIONOUT();
			ND_PRINT((ndo, "" tid""));
			UBIK_VERSIONOUT();
			break;
		case 10003:		/* Get sync site */
			ND_PRINT((ndo, "" site""));
			UINTOUT();
			break;
		case 20000:		/* Begin */
		case 20001:		/* Commit */
		case 20007:		/* Abort */
		case 20008:		/* Release locks */
		case 20010:		/* Writev */
			ND_PRINT((ndo, "" tid""));
			UBIK_VERSIONOUT();
			break;
		case 20002:		/* Lock */
			ND_PRINT((ndo, "" tid""));
			UBIK_VERSIONOUT();
			ND_PRINT((ndo, "" file""));
			INTOUT();
			ND_PRINT((ndo, "" pos""));
			INTOUT();
			ND_PRINT((ndo, "" length""));
			INTOUT();
			temp = EXTRACT_32BITS(bp);
			bp += sizeof(int32_t);
			tok2str(ubik_lock_types, ""type %d"", temp);
			break;
		case 20003:		/* Write */
			ND_PRINT((ndo, "" tid""));
			UBIK_VERSIONOUT();
			ND_PRINT((ndo, "" file""));
			INTOUT();
			ND_PRINT((ndo, "" pos""));
			INTOUT();
			break;
		case 20005:		/* Get file */
			ND_PRINT((ndo, "" file""));
			INTOUT();
			break;
		case 20006:		/* Send file */
			ND_PRINT((ndo, "" file""));
			INTOUT();
			ND_PRINT((ndo, "" length""));
			INTOUT();
			ND_PRINT((ndo, "" dbversion""));
			UBIK_VERSIONOUT();
			break;
		case 20009:		/* Truncate */
			ND_PRINT((ndo, "" tid""));
			UBIK_VERSIONOUT();
			ND_PRINT((ndo, "" file""));
			INTOUT();
			ND_PRINT((ndo, "" length""));
			INTOUT();
			break;
		case 20012:		/* Set version */
			ND_PRINT((ndo, "" tid""));
			UBIK_VERSIONOUT();
			ND_PRINT((ndo, "" oldversion""));
			UBIK_VERSIONOUT();
			ND_PRINT((ndo, "" newversion""));
			UBIK_VERSIONOUT();
			break;
		default:
			;
	}

	return;

trunc:
	ND_PRINT((ndo, "" [|ubik]""));
}",1,"['CWE-125', 'CWE-787']",tcpdump,aa0858100096a3490edf93034a80e66a4d61aad5,264601541811096325588976428461742276742,104,"CVE-2017-13049/Rx: add a missing bounds check for Ubik

One of the case blocks in ubik_print() didn't check bounds before
fetching 32 bits of packet data and could overread past the captured
packet data by that amount.

This fixes a buffer over-read discovered by Henri Salo from Nixu
Corporation.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-13049,CVE-2017-13049,{'CWE-125'},6.4,The Rx protocol parser in tcpdump before 4.9.2 has a buffer over-read in print-rx.c:ubik_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/aa0858100096a3490edf93034a80e66a4d61aad5'},https://github.com/the-tcpdump-group/tcpdump/commit/aa0858100096a3490edf93034a80e66a4d61aad5,SINGLE,['d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514'],1,aa0858100096a3490edf93034a80e66a4d61aad5,"08/04/2017, 16:15:07",aa0858100096a3490edf93034a80e66a4d61aad5,['aa0858100096a3490edf93034a80e66a4d61aad5'],Denis Ovsienko,"CVE-2017-13049/Rx: add a missing bounds check for Ubik

One of the case blocks in ubik_print() didn't check bounds before
fetching 32 bits of packet data and could overread past the captured
packet data by that amount.

This fixes a buffer over-read discovered by Henri Salo from Nixu
Corporation.

Add a test using the capture file supplied by the reporter(s).","{'print-rx.c': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/aa0858100096a3490edf93034a80e66a4d61aad5/print-rx.c', 'patch': '@@ -2577,6 +2577,7 @@ ubik_print(netdissect_options *ndo,\n \t\t\tINTOUT();\n \t\t\tND_PRINT((ndo, "" length""));\n \t\t\tINTOUT();\n+\t\t\tND_TCHECK_32BITS(bp);\n \t\t\ttemp = EXTRACT_32BITS(bp);\n \t\t\tbp += sizeof(int32_t);\n \t\t\ttok2str(ubik_lock_types, ""type %d"", temp);'}, 'tests/TESTLIST': {'additions': 3, 'deletions': 0, 'changes': 3, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/aa0858100096a3490edf93034a80e66a4d61aad5/tests%2FTESTLIST', 'patch': '@@ -573,6 +573,9 @@ mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out\n mptcp-dss-oobr\t\tmptcp-dss-oobr.pcap\t\tmptcp-dss-oobr.out\t-v\n icmp6_nodeinfo_oobr\ticmp6_nodeinfo_oobr.pcap\ticmp6_nodeinfo_oobr.out\n \n+# bad packets from Henri Salo\n+rx_ubik-oobr\t\trx_ubik-oobr.pcap\t\trx_ubik-oobr.out -c1\n+\n # RTP tests\n # fuzzed pcap\n rtp-seg-fault-1  rtp-seg-fault-1.pcap  rtp-seg-fault-1.out  -v -T rtp'}, 'tests/rx_ubik-oobr.out': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/aa0858100096a3490edf93034a80e66a4d61aad5/tests%2Frx_ubik-oobr.out', 'patch': '@@ -0,0 +1 @@\n+IP truncated-ip - 2598 bytes missing! 222.241.104.198.3503 > 131.63.241.146.7002:  rx data pt ubik call disk-lock tid 50266112.32382 file 2122216448 pos 545160708 length 1087685554 [|ubik] (2632)'}, 'tests/rx_ubik-oobr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/aa0858100096a3490edf93034a80e66a4d61aad5/tests%2Frx_ubik-oobr.pcap', 'patch': None}}",,"{'additions': 5, 'deletions': 0, 'total': 5}","{'c', 'pcap', 'out'}",{'C/C++'}
"lldp_private_8021_print(netdissect_options *ndo,
                        const u_char *tptr, u_int tlv_len)
{
    int subtype, hexdump = FALSE;
    u_int sublen;
    u_int tval;
    uint8_t i;

    if (tlv_len < 4) {
        return hexdump;
    }
    subtype = *(tptr+3);

    ND_PRINT((ndo, ""\n\t  %s Subtype (%u)"",
           tok2str(lldp_8021_subtype_values, ""unknown"", subtype),
           subtype));

    switch (subtype) {
    case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:
        if (tlv_len < 6) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    port vlan id (PVID): %u"",
               EXTRACT_16BITS(tptr + 4)));
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:
        if (tlv_len < 7) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)"",
               EXTRACT_16BITS(tptr+5),
	       bittok2str(lldp_8021_port_protocol_id_values, ""none"", *(tptr+4)),
	       *(tptr + 4)));
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME:
        if (tlv_len < 6) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    vlan id (VID): %u"", EXTRACT_16BITS(tptr + 4)));
        if (tlv_len < 7) {
            return hexdump;
        }
        sublen = *(tptr+6);
        if (tlv_len < 7+sublen) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    vlan name: ""));
        safeputs(ndo, tptr + 7, sublen);
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY:
        if (tlv_len < 5) {
            return hexdump;
        }
        sublen = *(tptr+4);
        if (tlv_len < 5+sublen) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    protocol identity: ""));
        safeputs(ndo, tptr + 5, sublen);
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH){
        	return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Pre-Priority CNPV Indicator""));
        ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
        ND_PRINT((ndo, ""\n\t     Value    : ""));
        for(i=0;i<NO_OF_BITS;i++)
            ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
        tval=*(tptr+5);
        ND_PRINT((ndo, ""\n\t    Pre-Priority Ready Indicator""));
        ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
        ND_PRINT((ndo, ""\n\t     Value    : ""));
        for(i=0;i<NO_OF_BITS;i++)
            ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH) {
            return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d"",
        	tval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07));

        /*Print Priority Assignment Table*/
        print_ets_priority_assignment_table(ndo, tptr + 5);

        /*Print TC Bandwidth Table*/
        print_tc_bandwidth_table(ndo, tptr + 9);

        /* Print TSA Assignment Table */
        print_tsa_assignment_table(ndo, tptr + 17);

        break;

    case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH) {
        	return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    RES: %d"", *(tptr + 4)));
        /*Print Priority Assignment Table */
        print_ets_priority_assignment_table(ndo, tptr + 5);
        /*Print TC Bandwidth Table */
        print_tc_bandwidth_table(ndo, tptr + 9);
        /* Print TSA Assignment Table */
        print_tsa_assignment_table(ndo, tptr + 17);
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH) {
            return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d "",
        	tval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f)));
        ND_PRINT((ndo, ""\n\t    PFC Enable""));
        tval=*(tptr+5);
        ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
        ND_PRINT((ndo, ""\n\t     Value    : ""));
        for(i=0;i<NO_OF_BITS;i++)
            ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    RES: %d"", *(tptr + 4)));
        if(tlv_len<=LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH){
        	return hexdump;
        }
        /*  Length of Application Priority Table */
        sublen=tlv_len-5;
        if(sublen%3!=0){
        	return hexdump;
        }
        i=0;
        ND_PRINT((ndo, ""\n\t    Application Priority Table""));
        while(i<sublen) {
        	tval=*(tptr+i+5);
        	ND_PRINT((ndo, ""\n\t      Priority: %d, RES: %d, Sel: %d"",
        		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));
        	ND_PRINT((ndo, ""Protocol ID: %d"", EXTRACT_16BITS(tptr + i + 5)));
        	i=i+3;
        }
        break;
    case LLDP_PRIVATE_8021_SUBTYPE_EVB:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){
        	return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    EVB Bridge Status""));
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d"",
        	tval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01));
        ND_PRINT((ndo, ""\n\t    EVB Station Status""));
        tval=*(tptr+5);
        ND_PRINT((ndo, ""\n\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d"",
        	tval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03));
        tval=*(tptr+6);
        ND_PRINT((ndo, ""\n\t    R: %d, RTE: %d, "",tval >> 5, tval & 0x1f));
        tval=*(tptr+7);
        ND_PRINT((ndo, ""EVB Mode: %s [%d]"",
        	tok2str(lldp_evb_mode_values, ""unknown"", tval >> 6), tval >> 6));
        ND_PRINT((ndo, ""\n\t    ROL: %d, RWD: %d, "", (tval >> 5) & 0x01, tval & 0x1f));
        tval=*(tptr+8);
        ND_PRINT((ndo, ""RES: %d, ROL: %d, RKA: %d"", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f));
        break;

    case LLDP_PRIVATE_8021_SUBTYPE_CDCP:
        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH){
        	return hexdump;
        }
        tval=*(tptr+4);
        ND_PRINT((ndo, ""\n\t    Role: %d, RES: %d, Scomp: %d "",
        	tval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01));
        ND_PRINT((ndo, ""ChnCap: %d"", EXTRACT_16BITS(tptr + 6) & 0x0fff));
        sublen=tlv_len-8;
        if(sublen%3!=0) {
        	return hexdump;
        }
        i=0;
        while(i<sublen) {
        	tval=EXTRACT_24BITS(tptr+i+8);
        	ND_PRINT((ndo, ""\n\t    SCID: %d, SVID: %d"",
        		tval >> 12, tval & 0x000fff));
        	i=i+3;
        }
        break;

    default:
        hexdump = TRUE;
        break;
    }

    return hexdump;
}",1,"['CWE-399', 'CWE-835']",tcpdump,34cec721d39c76be1e0a600829a7b17bdfb832b6,330707404329800776290824792295392284738,198,"CVE-2017-12997/LLDP: Don't use an 8-bit loop counter.

If you have a

	for (i = 0; i < N; i++)

loop, you'd better make sure that i is big enough to hold N - not N-1,
N.

The TLV length here is 9 bits long, not 8 bits long, so an 8-bit loop
counter will overflow and you can loop infinitely.

This fixes an infinite loop discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomäki.

Add tests using the capture files supplied by the reporter(s).

Clean up the output a bit while we're at it.",CVE-2017-12997,CVE-2017-12997,{'CWE-835'},2.9,The LLDP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-lldp.c:lldp_private_8021_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/34cec721d39c76be1e0a600829a7b17bdfb832b6'},https://github.com/the-tcpdump-group/tcpdump/commit/34cec721d39c76be1e0a600829a7b17bdfb832b6,SINGLE,['979dcefd7b259e9e233f77fe1c5312793bfd948f'],1,34cec721d39c76be1e0a600829a7b17bdfb832b6,"02/13/2017, 19:11:42",34cec721d39c76be1e0a600829a7b17bdfb832b6,['34cec721d39c76be1e0a600829a7b17bdfb832b6'],Guy Harris,"CVE-2017-12997/LLDP: Don't use an 8-bit loop counter.

If you have a

	for (i = 0; i < N; i++)

loop, you'd better make sure that i is big enough to hold N - not N-1,
N.

The TLV length here is 9 bits long, not 8 bits long, so an 8-bit loop
counter will overflow and you can loop infinitely.

This fixes an infinite loop discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomäki.

Add tests using the capture files supplied by the reporter(s).

Clean up the output a bit while we're at it.","{'print-lldp.c': {'additions': 4, 'deletions': 4, 'changes': 8, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/34cec721d39c76be1e0a600829a7b17bdfb832b6/print-lldp.c', 'patch': '@@ -651,7 +651,7 @@ lldp_private_8021_print(netdissect_options *ndo,\n     int subtype, hexdump = FALSE;\n     u_int sublen;\n     u_int tval;\n-    uint8_t i;\n+    u_int i;\n \n     if (tlv_len < 4) {\n         return hexdump;\n@@ -787,9 +787,9 @@ lldp_private_8021_print(netdissect_options *ndo,\n         ND_PRINT((ndo, ""\\n\\t    Application Priority Table""));\n         while(i<sublen) {\n         \ttval=*(tptr+i+5);\n-        \tND_PRINT((ndo, ""\\n\\t      Priority: %d, RES: %d, Sel: %d"",\n-        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));\n-        \tND_PRINT((ndo, ""Protocol ID: %d"", EXTRACT_16BITS(tptr + i + 5)));\n+        \tND_PRINT((ndo, ""\\n\\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u"",\n+        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),\n+        \t\t EXTRACT_16BITS(tptr + i + 5)));\n         \ti=i+3;\n         }\n         break;'}, 'tests/TESTLIST': {'additions': 2, 'deletions': 0, 'changes': 2, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests%2FTESTLIST', 'patch': '@@ -479,6 +479,8 @@ dns_fwdptr\t\tdns_fwdptr.pcap\t\t\tdns_fwdptr.out\t\t-vvv -e\n isis-areaaddr-oobr-1\tisis-areaaddr-oobr-1.pcap\tisis-areaaddr-oobr-1.out\t\t-vvv -e\n isis-areaaddr-oobr-2\tisis-areaaddr-oobr-2.pcap\tisis-areaaddr-oobr-2.out\t\t-vvv -e\n isis-extd-ipreach-oobr\tisis-extd-ipreach-oobr.pcap\tisis-extd-ipreach-oobr.out\t\t-vvv -e\n+lldp-infinite-loop-1\tlldp-infinite-loop-1.pcap\tlldp-infinite-loop-1.out\t\t-vvv -e\n+lldp-infinite-loop-2\tlldp-infinite-loop-2.pcap\tlldp-infinite-loop-2.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap'}, 'tests/lldp-infinite-loop-1.out': {'additions': 134, 'deletions': 0, 'changes': 134, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests%2Flldp-infinite-loop-1.out', 'patch': '@@ -0,0 +1,134 @@\n+08:00:27:42:ba:59 > 01:80:c2:00:00:0e, ethertype LLDP (0x88cc), length 1755: LLDP, length 1741\n+\tChassis ID TLV (1), length 7\n+\t  Subtype MAC address (4): 08:00:27:42:ba:59\n+\t  0x0000:  0408 0027 42ba 59\n+\tPort ID TLV (2), length 7\n+\t  Subtype MAC address (3): 08:00:27:42:ba:59\n+\t  0x0000:  0308 0027 42ba 59\n+\tTime to Live TLV (3), length 2: TTL 120s\n+\t  0x0000:  0078\n+\tOrganization specific TLV (127), length 6: OUI Ethernet bridged (0x0080c2)\n+\t  Port VLAN Id Subtype (1)\n+\t    port vlan id (PVID): 0\n+\t  0x0000:  0080 c201 0000\n+\tOrganization specific TLV (127), length 7: OUI Ethernet bridged (0x0080c2)\n+\t  Port and Protocol VLAN ID Subtype (2)\n+\t    port and protocol vlan id (PPVID): 0, flags [supported] (0x02)\n+\t  0x0000:  0080 c202 0200 00\n+\tOrganization specific TLV (127), length 14: OUI Ethernet bridged (0x0080c2)\n+\t  VLAN name Subtype (3)\n+\t    vlan id (VID): 1\n+\t    vlan name: default\n+\t  0x0000:  0080 c203 0001 0764 6566 6175 6c74\n+\tOrganization specific TLV (127), length 13: OUI Ethernet bridged (0x0080c2)\n+\t  Protocol Identity Subtype (4)\n+\t    protocol identity: \n+\t  0x0000:  0080 c204 0800 0042 4203 0080 08\n+\tOrganization specific TLV (127), length 263: OUI Ethernet bridged (0x0080c2)\n+\t  Application Priority Subtype (12)\n+\t    RES: 0\n+\t    Application Priority Table\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t  0x0000:  0080 c20c 0000 0000 0000 0000 80c2 0c00\n+\t  0x0010:  0000 0000 0000 0080 c20c 0000 0000 0000\n+\t  0x0020:  0000 80c2 0c00 0000 0000 0000 0080 c20c\n+\t  0x0030:  0000 0000 0000 0000 80c2 0c00 0000 0000\n+\t  0x0040:  0000 0080 c20c 0000 0000 0000 0000 80c2\n+\t  0x0050:  0c00 0000 0000 0000 0080 c20c 0000 0000\n+\t  0x0060:  0000 0000 80c2 0c00 0000 0000 0000 0080\n+\t  0x0070:  c20c 0000 0000 0000 0000 80c2 0c00 0000\n+\t  0x0080:  0000 0000 0080 c20c 0000 0000 0000 0000\n+\t  0x0090:  80c2 0c00 0000 0000 0000 0080 c20c 0000\n+\t  0x00a0:  0000 0000 0000 80c2 0c00 0000 0000 0000\n+\t  0x00b0:  0080 c20c 0000 0000 0000 0000 80c2 0c00\n+\t  0x00c0:  0000 0000 0000 0080 c20c 0000 0000 0000\n+\t  0x00d0:  0000 80c2 0c00 0000 0000 0000 0080 c20c\n+\t  0x00e0:  0000 0000 0000 0000 80c2 0c00 0000 0000\n+\t  0x00f0:  0000 0080 c20c 0000 0000 0000 0000 80c2\n+\t  0x0100:  0c00 0000 0000 00\n+\tEnd TLV (0), length 0'}, 'tests/lldp-infinite-loop-1.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests%2Flldp-infinite-loop-1.pcap', 'patch': None}, 'tests/lldp-infinite-loop-2.out': {'additions': 161, 'deletions': 0, 'changes': 161, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests%2Flldp-infinite-loop-2.out', 'patch': '@@ -0,0 +1,161 @@\n+08:00:27:0d:f1:3c > 01:80:c2:00:00:0e, ethertype LLDP (0x88cc), length 2130: LLDP, length 2116\n+\tChassis ID TLV (1), length 7\n+\t  Subtype MAC address (4): 08:00:27:0d:f1:3c\n+\t  0x0000:  0408 0027 0df1 3c\n+\tPort ID TLV (2), length 7\n+\t  Subtype MAC address (3): 08:00:27:0d:f1:3c\n+\t  0x0000:  0308 0027 0df1 3c\n+\tTime to Live TLV (3), length 2: TTL 120s\n+\t  0x0000:  0078\n+\tOrganization specific TLV (127), length 6: OUI Ethernet bridged (0x0080c2)\n+\t  Port VLAN Id Subtype (1)\n+\t    port vlan id (PVID): 1\n+\t  0x0000:  0080 c201 0001\n+\tOrganization specific TLV (127), length 7: OUI Ethernet bridged (0x0080c2)\n+\t  Port and Protocol VLAN ID Subtype (2)\n+\t    port and protocol vlan id (PPVID): 0, flags [supported] (0x02)\n+\t  0x0000:  0080 c202 0200 00\n+\tOrganization specific TLV (127), length 14: OUI Ethernet bridged (0x0080c2)\n+\t  VLAN name Subtype (3)\n+\t    vlan id (VID): 1\n+\t    vlan name: default\n+\t  0x0000:  0080 c203 0001 0764 6566 6175 6c74\n+\tOrganization specific TLV (127), length 13: OUI Ethernet bridged (0x0080c2)\n+\t  Protocol Identity Subtype (4)\n+\t    protocol identity: \n+\t  0x0000:  0080 c204 0800 0042 4203 0000 03\n+\tOrganization specific TLV (127), length 9: OUI Ethernet bridged (0x0080c2)\n+\t  EVB Subtype (13)\n+\t    EVB Bridge Status\n+\t      RES: 0, BGID: 0, RRCAP: 1, RRCTR: 0\n+\t    EVB Station Status\n+\t      RES: 0, SGID: 0, RRREQ: 0,RRSTAT: 0\n+\t    R: 7, RTE: 21, EVB Mode: EVB Bridge [1]\n+\t    ROL: 0, RWD: 30, RES: 0, ROL: 0, RKA: 15\n+\t  0x0000:  0080 c20d 0200 f55e 0f\n+\tOrganization specific TLV (127), length 266: OUI Ethernet bridged (0x0080c2)\n+\t  CDCP Subtype (14)\n+\t    Role: 0, RES: 0, Scomp: 0 ChnCap: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t  0x0000:  0080 c20e 0000 00a7 0010 0100 00c2 0e00\n+\t  0x0010:  0000 a700 1001 0000 c20e 0000 00a7 0010\n+\t  0x0020:  0100 00c2 0e00 0000 a700 1001 0000 c20e\n+\t  0x0030:  0000 00a7 0010 0100 00c2 0e00 0000 a700\n+\t  0x0040:  1001 0000 c20e 0000 00a7 0010 0100 00c2\n+\t  0x0050:  0e00 0000 a700 1001 0000 c20e 0000 00a7\n+\t  0x0060:  0010 0100 00c2 0e00 0000 a700 1001 0000\n+\t  0x0070:  c20e 0000 00a7 0010 0100 00c2 0e00 0000\n+\t  0x0080:  a700 1001 0000 c20e 0000 00a7 0010 0100\n+\t  0x0090:  00c2 0e00 0000 a700 1001 0000 c20e 0000\n+\t  0x00a0:  00a7 0010 0100 00c2 0e00 0000 a700 1001\n+\t  0x00b0:  0000 c20e 0000 00a7 0010 0100 00c2 0e00\n+\t  0x00c0:  0000 a700 1001 0000 c20e 0000 00a7 0010\n+\t  0x00d0:  0100 00c2 0e00 0000 a700 1001 0000 c20e\n+\t  0x00e0:  0000 00a7 0010 0100 00c2 0e00 0000 a700\n+\t  0x00f0:  1001 0000 c20e 0000 00a7 0010 0100 00c2\n+\t  0x0100:  0e00 0000 a700 1001 0000\n+\tUnknown TLV (97), length 14\n+\t  0x0000:  0000 00a7 0010 0100 00c2 0e00 0000\n+\tUnknown TLV (83), length 256\n+\t  0x0000:  1001 0000 c20e 0000 00a7 0010 0100 00c2\n+\t  0x0010:  0e00 0000 a700 1001 0000 c20e 0000 00a7\n+\t  0x0020:  0010 0100 00c2 0e00 0000 a700 1001 0000\n+\t  0x0030:  c20e 0000 00a7 0010 0100 00c2 0e00 0000\n+\t  0x0040:  a700 1001 0000 c20e 0000 00a7 0010 0100\n+\t  0x0050:  00c2 0e00 0000 a700 1001 0000 c20e 0000\n+\t  0x0060:  00a7 0010 0100 00c2 0e00 0000 a700 1001\n+\t  0x0070:  0000 c20e 0000 00a7 0010 0100 00c2 0e00\n+\t  0x0080:  0000 a700 1001 0000 c20e 0000 00a7 0010\n+\t  0x0090:  0100 00c2 0e00 0000 a700 1001 0000 c20e\n+\t  0x00a0:  0000 00a7 0010 0100 00c2 0e00 0000 a700\n+\t  0x00b0:  1001 0000 c20e 0000 00a7 0010 0100 00c2\n+\t  0x00c0:  0e00 0000 a700 1001 0000 c20e 0000 00a7\n+\t  0x00d0:  0010 0100 00c2 0e00 0000 a700 1001 0000\n+\t  0x00e0:  c20e 0000 00a7 0010 0100 00c2 0e00 0000\n+\t  0x00f0:  a700 1001 0000 c20e 0000 00a7 0010 0100\n+\tEnd TLV (0), length 194'}, 'tests/lldp-infinite-loop-2.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/34cec721d39c76be1e0a600829a7b17bdfb832b6/tests%2Flldp-infinite-loop-2.pcap', 'patch': None}}",,"{'additions': 301, 'deletions': 4, 'total': 305}","{'c', 'pcap', 'out'}",{'C/C++'}
"lldp_mgmt_addr_tlv_print(netdissect_options *ndo,
                         const u_char *pptr, u_int len)
{
    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;
    const u_char *tptr;
    u_int tlen;
    char *mgmt_addr;

    tlen = len;
    tptr = pptr;

    if (tlen < 1) {
        return 0;
    }
    mgmt_addr_len = *tptr++;
    tlen--;

    if (tlen < mgmt_addr_len) {
        return 0;
    }

    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);
    if (mgmt_addr == NULL) {
        return 0;
    }
    ND_PRINT((ndo, ""\n\t  Management Address length %u, %s"",
           mgmt_addr_len, mgmt_addr));
    tptr += mgmt_addr_len;
    tlen -= mgmt_addr_len;

    if (tlen < LLDP_INTF_NUM_LEN) {
        return 0;
    }

    intf_num_subtype = *tptr;
    ND_PRINT((ndo, ""\n\t  %s Interface Numbering (%u): %u"",
           tok2str(lldp_intf_numb_subtype_values, ""Unknown"", intf_num_subtype),
           intf_num_subtype,
           EXTRACT_32BITS(tptr + 1)));

    tptr += LLDP_INTF_NUM_LEN;
    tlen -= LLDP_INTF_NUM_LEN;

    /*
     * The OID is optional.
     */
    if (tlen) {
        oid_len = *tptr;

        if (tlen < oid_len) {
            return 0;
        }
        if (oid_len) {
            ND_PRINT((ndo, ""\n\t  OID length %u"", oid_len));
            safeputs(ndo, tptr + 1, oid_len);
        }
    }

    return 1;
}",1,"['CWE-125', 'CWE-787']",tcpdump,a77ff09c46560bc895dea11dc9fe643486b056ac,57146411791930008915328836940894141333,60,"CVE-2017-13027/LLDP: Fix a bounds check.

The total length of the OID is the OID length plus the length of the OID
length itself.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.",CVE-2017-13027,CVE-2017-13027,{'CWE-125'},6.4,The LLDP parser in tcpdump before 4.9.2 has a buffer over-read in print-lldp.c:lldp_mgmt_addr_tlv_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/a77ff09c46560bc895dea11dc9fe643486b056ac'},https://github.com/the-tcpdump-group/tcpdump/commit/a77ff09c46560bc895dea11dc9fe643486b056ac,SINGLE,['b20e1639dbac84b3fcb393858521c13ad47a9d70'],1,a77ff09c46560bc895dea11dc9fe643486b056ac,"03/22/2017, 18:21:00",a77ff09c46560bc895dea11dc9fe643486b056ac,['a77ff09c46560bc895dea11dc9fe643486b056ac'],Guy Harris,"CVE-2017-13027/LLDP: Fix a bounds check.

The total length of the OID is the OID length plus the length of the OID
length itself.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.","{'print-lldp.c': {'additions': 1, 'deletions': 1, 'changes': 2, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/a77ff09c46560bc895dea11dc9fe643486b056ac/print-lldp.c', 'patch': '@@ -1401,7 +1401,7 @@ lldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n     if (tlen) {\n         oid_len = *tptr;\n \n-        if (tlen < oid_len) {\n+        if (tlen < 1U + oid_len) {\n             return 0;\n         }\n         if (oid_len) {'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/a77ff09c46560bc895dea11dc9fe643486b056ac/tests%2FTESTLIST', 'patch': '@@ -532,6 +532,7 @@ isis_stlv_asan\t\tisis_stlv_asan.pcap\t\tisis_stlv_asan.out\t-v\n isis_stlv_asan-2\tisis_stlv_asan-2.pcap\t\tisis_stlv_asan-2.out\t-v\n isis_stlv_asan-3\tisis_stlv_asan-3.pcap\t\tisis_stlv_asan-3.out\t-v\n isis_stlv_asan-4\tisis_stlv_asan-4.pcap\t\tisis_stlv_asan-4.out\t-v\n+lldp_mgmt_addr_tlv_asan\tlldp_mgmt_addr_tlv_asan.pcap\tlldp_mgmt_addr_tlv_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap'}, 'tests/lldp_mgmt_addr_tlv_asan.out': {'additions': 8, 'deletions': 0, 'changes': 8, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/a77ff09c46560bc895dea11dc9fe643486b056ac/tests%2Flldp_mgmt_addr_tlv_asan.out', 'patch': '@@ -0,0 +1,8 @@\n+LLDP, length 1048572\n+\tManagement Address TLV (8), length 15\n+\t  Management Address length 6, AFI Reserved (0), no AF printer !\n+\t  Unknown Interface Numbering (10): 666137427\n+\t[|LLDP]\n+00:00:00:a0:d4:c3 > 06:04:e8:03:00:02, ethertype Unknown (0xb2a1), length 58785857: \n+\t0x0000:  0200 efff e5ff 804f 006e 0026 0000 0000  .......O.n.&....\n+\t0x0010:  01                                       .'}, 'tests/lldp_mgmt_addr_tlv_asan.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/a77ff09c46560bc895dea11dc9fe643486b056ac/tests%2Flldp_mgmt_addr_tlv_asan.pcap', 'patch': None}}",,"{'additions': 10, 'deletions': 1, 'total': 11}","{'c', 'pcap', 'out'}",{'C/C++'}
"isis_print_extd_ip_reach(netdissect_options *ndo,
                         const uint8_t *tptr, const char *ident, uint16_t afi)
{
    char ident_buffer[20];
    uint8_t prefix[sizeof(struct in6_addr)]; /* shared copy buffer for IPv4 and IPv6 prefixes */
    u_int metric, status_byte, bit_length, byte_length, sublen, processed, subtlvtype, subtlvlen;

    if (!ND_TTEST2(*tptr, 4))
        return (0);
    metric = EXTRACT_32BITS(tptr);
    processed=4;
    tptr+=4;

    if (afi == AF_INET) {
        if (!ND_TTEST2(*tptr, 1)) /* fetch status byte */
            return (0);
        status_byte=*(tptr++);
        bit_length = status_byte&0x3f;
        if (bit_length > 32) {
            ND_PRINT((ndo, ""%sIPv4 prefix: bad bit length %u"",
                   ident,
                   bit_length));
            return (0);
        }
        processed++;
    } else if (afi == AF_INET6) {
        if (!ND_TTEST2(*tptr, 1)) /* fetch status & prefix_len byte */
            return (0);
        status_byte=*(tptr++);
        bit_length=*(tptr++);
        if (bit_length > 128) {
            ND_PRINT((ndo, ""%sIPv6 prefix: bad bit length %u"",
                   ident,
                   bit_length));
            return (0);
        }
        processed+=2;
    } else
        return (0); /* somebody is fooling us */

    byte_length = (bit_length + 7) / 8; /* prefix has variable length encoding */

    if (!ND_TTEST2(*tptr, byte_length))
        return (0);
    memset(prefix, 0, sizeof prefix);   /* clear the copy buffer */
    memcpy(prefix,tptr,byte_length);    /* copy as much as is stored in the TLV */
    tptr+=byte_length;
    processed+=byte_length;

    if (afi == AF_INET)
        ND_PRINT((ndo, ""%sIPv4 prefix: %15s/%u"",
               ident,
               ipaddr_string(ndo, prefix),
               bit_length));
    else if (afi == AF_INET6)
        ND_PRINT((ndo, ""%sIPv6 prefix: %s/%u"",
               ident,
               ip6addr_string(ndo, prefix),
               bit_length));

    ND_PRINT((ndo, "", Distribution: %s, Metric: %u"",
           ISIS_MASK_TLV_EXTD_IP_UPDOWN(status_byte) ? ""down"" : ""up"",
           metric));

    if (afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))
        ND_PRINT((ndo, "", sub-TLVs present""));
    else if (afi == AF_INET6)
        ND_PRINT((ndo, "", %s%s"",
               ISIS_MASK_TLV_EXTD_IP6_IE(status_byte) ? ""External"" : ""Internal"",
               ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte) ? "", sub-TLVs present"" : """"));

    if ((afi == AF_INET  && ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))
     || (afi == AF_INET6 && ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte))
	) {
        /* assume that one prefix can hold more
           than one subTLV - therefore the first byte must reflect
           the aggregate bytecount of the subTLVs for this prefix
        */
        if (!ND_TTEST2(*tptr, 1))
            return (0);
        sublen=*(tptr++);
        processed+=sublen+1;
        ND_PRINT((ndo, "" (%u)"", sublen));   /* print out subTLV length */

        while (sublen>0) {
            if (!ND_TTEST2(*tptr,2))
                return (0);
            subtlvtype=*(tptr++);
            subtlvlen=*(tptr++);
            /* prepend the indent string */
            snprintf(ident_buffer, sizeof(ident_buffer), ""%s  "",ident);
            if (!isis_print_ip_reach_subtlv(ndo, tptr, subtlvtype, subtlvlen, ident_buffer))
                return(0);
            tptr+=subtlvlen;
            sublen-=(subtlvlen+2);
        }
    }
    return (processed);
}",1,"['CWE-125', 'CWE-787']",tcpdump,979dcefd7b259e9e233f77fe1c5312793bfd948f,274578969162283986419973621255322097286,99,"CVE-2017-12998/IS-IS: Check for 2 bytes if we're going to fetch 2 bytes.

Probably a copy-and-pasteo.

This fixes a buffer over-read discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomäki.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-12998,CVE-2017-12998,{'CWE-125'},6.4,The IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_extd_ip_reach().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/979dcefd7b259e9e233f77fe1c5312793bfd948f'},https://github.com/the-tcpdump-group/tcpdump/commit/979dcefd7b259e9e233f77fe1c5312793bfd948f,SINGLE,['3b32029db354cbc875127869d9b12a9addc75b50'],1,979dcefd7b259e9e233f77fe1c5312793bfd948f,"02/13/2017, 18:38:04",979dcefd7b259e9e233f77fe1c5312793bfd948f,['979dcefd7b259e9e233f77fe1c5312793bfd948f'],Guy Harris,"CVE-2017-12998/IS-IS: Check for 2 bytes if we're going to fetch 2 bytes.

Probably a copy-and-pasteo.

This fixes a buffer over-read discovered by Forcepoint's security
researchers Otto Airamo & Antti Levomäki.

Add a test using the capture file supplied by the reporter(s).","{'print-isoclns.c': {'additions': 1, 'deletions': 1, 'changes': 2, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/979dcefd7b259e9e233f77fe1c5312793bfd948f/print-isoclns.c', 'patch': '@@ -2038,7 +2038,7 @@ isis_print_extd_ip_reach(netdissect_options *ndo,\n         }\n         processed++;\n     } else if (afi == AF_INET6) {\n-        if (!ND_TTEST2(*tptr, 1)) /* fetch status & prefix_len byte */\n+        if (!ND_TTEST2(*tptr, 2)) /* fetch status & prefix_len byte */\n             return (0);\n         status_byte=*(tptr++);\n         bit_length=*(tptr++);'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/979dcefd7b259e9e233f77fe1c5312793bfd948f/tests%2FTESTLIST', 'patch': '@@ -478,6 +478,7 @@ resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n dns_fwdptr\t\tdns_fwdptr.pcap\t\t\tdns_fwdptr.out\t\t-vvv -e\n isis-areaaddr-oobr-1\tisis-areaaddr-oobr-1.pcap\tisis-areaaddr-oobr-1.out\t\t-vvv -e\n isis-areaaddr-oobr-2\tisis-areaaddr-oobr-2.pcap\tisis-areaaddr-oobr-2.out\t\t-vvv -e\n+isis-extd-ipreach-oobr\tisis-extd-ipreach-oobr.pcap\tisis-extd-ipreach-oobr.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap'}, 'tests/isis-extd-ipreach-oobr.out': {'additions': 10894, 'deletions': 0, 'changes': 10894, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/979dcefd7b259e9e233f77fe1c5312793bfd948f/tests%2Fisis-extd-ipreach-oobr.out', 'patch': None}, 'tests/isis-extd-ipreach-oobr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/979dcefd7b259e9e233f77fe1c5312793bfd948f/tests%2Fisis-extd-ipreach-oobr.pcap', 'patch': None}}",,"{'additions': 10896, 'deletions': 1, 'total': 10897}","{'c', 'pcap', 'out'}",{'C/C++'}
"ripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)
{
	register const struct rip6 *rp = (const struct rip6 *)dat;
	register const struct netinfo6 *ni;
	register u_int amt;
	register u_int i;
	int j;
	int trunc;

	if (ndo->ndo_snapend < dat)
		return;
	amt = ndo->ndo_snapend - dat;
	i = min(length, amt);
	if (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))
		return;
	i -= (sizeof(struct rip6) - sizeof(struct netinfo6));

	switch (rp->rip6_cmd) {

	case RIP6_REQUEST:
		j = length / sizeof(*ni);
		if (j == 1
		    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6
		    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {
			ND_PRINT((ndo, "" ripng-req dump""));
			break;
		}
		if (j * sizeof(*ni) != length - 4)
			ND_PRINT((ndo, "" ripng-req %d[%u]:"", j, length));
		else
			ND_PRINT((ndo, "" ripng-req %d:"", j));
		trunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);
		for (ni = rp->rip6_nets; i >= sizeof(*ni);
		    i -= sizeof(*ni), ++ni) {
			if (ndo->ndo_vflag > 1)
				ND_PRINT((ndo, ""\n\t""));
			else
				ND_PRINT((ndo, "" ""));
			rip6_entry_print(ndo, ni, 0);
		}
		break;
	case RIP6_RESPONSE:
		j = length / sizeof(*ni);
		if (j * sizeof(*ni) != length - 4)
			ND_PRINT((ndo, "" ripng-resp %d[%u]:"", j, length));
		else
			ND_PRINT((ndo, "" ripng-resp %d:"", j));
		trunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);
		for (ni = rp->rip6_nets; i >= sizeof(*ni);
		    i -= sizeof(*ni), ++ni) {
			if (ndo->ndo_vflag > 1)
				ND_PRINT((ndo, ""\n\t""));
			else
				ND_PRINT((ndo, "" ""));
			rip6_entry_print(ndo, ni, ni->rip6_metric);
		}
		if (trunc)
			ND_PRINT((ndo, ""[|ripng]""));
		break;
	default:
		ND_PRINT((ndo, "" ripng-%d ?? %u"", rp->rip6_cmd, length));
		break;
	}
	if (rp->rip6_vers != RIP6_VERSION)
		ND_PRINT((ndo, "" [vers %d]"", rp->rip6_vers));
}",1,['CWE-125'],tcpdump,e942fb84fbe3a73a98a00d2a279425872b5fb9d2,124033650329276317956176984654691806889,66,"CVE-2017-12992/RIPng: Clean up bounds checking.

Do bounds checking as we access items.

Scan the list of netinfo6 entries based on the supplied packet length,
without taking the captured length into account; let the aforementioned
bounds checking handle that.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-12992,CVE-2017-12992,{'CWE-125'},6.4,The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/e942fb84fbe3a73a98a00d2a279425872b5fb9d2'},https://github.com/the-tcpdump-group/tcpdump/commit/e942fb84fbe3a73a98a00d2a279425872b5fb9d2,SINGLE,['db24063b01cba8e9d4d88b7d8ac70c9000c104e4'],1,e942fb84fbe3a73a98a00d2a279425872b5fb9d2,"02/07/2017, 11:03:34",e942fb84fbe3a73a98a00d2a279425872b5fb9d2,['e942fb84fbe3a73a98a00d2a279425872b5fb9d2'],Guy Harris,"CVE-2017-12992/RIPng: Clean up bounds checking.

Do bounds checking as we access items.

Scan the list of netinfo6 entries based on the supplied packet length,
without taking the captured length into account; let the aforementioned
bounds checking handle that.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add a test using the capture file supplied by the reporter(s).","{'print-ripng.c': {'additions': 40, 'deletions': 31, 'changes': 71, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/e942fb84fbe3a73a98a00d2a279425872b5fb9d2/print-ripng.c', 'patch': '@@ -110,65 +110,74 @@ ripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)\n {\n \tregister const struct rip6 *rp = (const struct rip6 *)dat;\n \tregister const struct netinfo6 *ni;\n-\tregister u_int amt;\n-\tregister u_int i;\n-\tint j;\n-\tint trunc;\n-\n-\tif (ndo->ndo_snapend < dat)\n-\t\treturn;\n-\tamt = ndo->ndo_snapend - dat;\n-\ti = min(length, amt);\n-\tif (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n-\t\treturn;\n-\ti -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n+\tunsigned int length_left;\n+\tu_int j;\n \n+\tND_TCHECK(rp->rip6_cmd);\n \tswitch (rp->rip6_cmd) {\n \n \tcase RIP6_REQUEST:\n-\t\tj = length / sizeof(*ni);\n-\t\tif (j == 1\n-\t\t    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6\n-\t\t    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {\n-\t\t\tND_PRINT((ndo, "" ripng-req dump""));\n-\t\t\tbreak;\n+\t\tlength_left = length;\n+\t\tif (length_left < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n+\t\t\tgoto trunc;\n+\t\tlength_left -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n+ \t\tj = length_left / sizeof(*ni);\n+\t\tif (j == 1) {\n+\t\t\tND_TCHECK(rp->rip6_nets);\n+\t\t\tif (rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6\n+\t\t\t    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {\n+\t\t\t\tND_PRINT((ndo, "" ripng-req dump""));\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n-\t\tif (j * sizeof(*ni) != length - 4)\n-\t\t\tND_PRINT((ndo, "" ripng-req %d[%u]:"", j, length));\n+\t\tif (j * sizeof(*ni) != length_left)\n+\t\t\tND_PRINT((ndo, "" ripng-req %u[%u]:"", j, length));\n \t\telse\n-\t\t\tND_PRINT((ndo, "" ripng-req %d:"", j));\n-\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n-\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n-\t\t    i -= sizeof(*ni), ++ni) {\n+\t\t\tND_PRINT((ndo, "" ripng-req %u:"", j));\n+\t\tfor (ni = rp->rip6_nets; length_left >= sizeof(*ni);\n+\t\t    length_left -= sizeof(*ni), ++ni) {\n+\t\t\tND_TCHECK(*ni);\n \t\t\tif (ndo->ndo_vflag > 1)\n \t\t\t\tND_PRINT((ndo, ""\\n\\t""));\n \t\t\telse\n \t\t\t\tND_PRINT((ndo, "" ""));\n \t\t\trip6_entry_print(ndo, ni, 0);\n \t\t}\n+\t\tif (length_left != 0)\n+\t\t\tgoto trunc;\n \t\tbreak;\n \tcase RIP6_RESPONSE:\n-\t\tj = length / sizeof(*ni);\n-\t\tif (j * sizeof(*ni) != length - 4)\n+\t\tlength_left = length;\n+\t\tif (length_left < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n+\t\t\tgoto trunc;\n+\t\tlength_left -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n+\t\tj = length_left / sizeof(*ni);\n+\t\tif (j * sizeof(*ni) != length_left)\n \t\t\tND_PRINT((ndo, "" ripng-resp %d[%u]:"", j, length));\n \t\telse\n \t\t\tND_PRINT((ndo, "" ripng-resp %d:"", j));\n-\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n-\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n-\t\t    i -= sizeof(*ni), ++ni) {\n+\t\tfor (ni = rp->rip6_nets; length_left >= sizeof(*ni);\n+\t\t    length_left -= sizeof(*ni), ++ni) {\n+\t\t\tND_TCHECK(*ni);\n \t\t\tif (ndo->ndo_vflag > 1)\n \t\t\t\tND_PRINT((ndo, ""\\n\\t""));\n \t\t\telse\n \t\t\t\tND_PRINT((ndo, "" ""));\n \t\t\trip6_entry_print(ndo, ni, ni->rip6_metric);\n \t\t}\n-\t\tif (trunc)\n-\t\t\tND_PRINT((ndo, ""[|ripng]""));\n+\t\tif (length_left != 0)\n+\t\t\tgoto trunc;\n \t\tbreak;\n \tdefault:\n \t\tND_PRINT((ndo, "" ripng-%d ?? %u"", rp->rip6_cmd, length));\n \t\tbreak;\n \t}\n+\tND_TCHECK(rp->rip6_vers);\n \tif (rp->rip6_vers != RIP6_VERSION)\n \t\tND_PRINT((ndo, "" [vers %d]"", rp->rip6_vers));\n+\treturn;\n+\n+trunc:\n+\tND_PRINT((ndo, ""[|ripng]""));\n+\treturn;\n }'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/e942fb84fbe3a73a98a00d2a279425872b5fb9d2/tests%2FTESTLIST', 'patch': '@@ -450,6 +450,7 @@ isoclns-oobr\t\tisoclns-oobr.pcap\t\tisoclns-oobr.out\n nfs-attr-oobr\t\tnfs-attr-oobr.pcap\t\tnfs-attr-oobr.out\n decnet-oobr\t\tdecnet-oobr.pcap\t\tdecnet-oobr.out\n oobr_parse_elements\toobr_parse_elements.pcap\toobr_parse_elements.out\n+hoobr_ripng_print\thoobr_ripng_print.pcap\t\thoobr_ripng_print.out\n \n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve'}, 'tests/hoobr_ripng_print.out': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/e942fb84fbe3a73a98a00d2a279425872b5fb9d2/tests%2Fhoobr_ripng_print.out', 'patch': '@@ -0,0 +1 @@\n+IP 48.48.48.48.521 > 48.48.48.48.12336: [|ripng]'}, 'tests/hoobr_ripng_print.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/e942fb84fbe3a73a98a00d2a279425872b5fb9d2/tests%2Fhoobr_ripng_print.pcap', 'patch': None}}",,"{'additions': 42, 'deletions': 31, 'total': 73}","{'c', 'pcap', 'out'}",{'C/C++'}
"decode_multicast_vpn(netdissect_options *ndo,
                     const u_char *pptr, char *buf, u_int buflen)
{
        uint8_t route_type, route_length, addr_length, sg_length;
        u_int offset;

	ND_TCHECK2(pptr[0], 2);
        route_type = *pptr++;
        route_length = *pptr++;

        snprintf(buf, buflen, ""Route-Type: %s (%u), length: %u"",
                 tok2str(bgp_multicast_vpn_route_type_values,
                         ""Unknown"", route_type),
                 route_type, route_length);

        switch(route_type) {
        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI:
            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);
            offset = strlen(buf);
            snprintf(buf + offset, buflen - offset, "", RD: %s, Originator %s"",
                     bgp_vpn_rd_print(ndo, pptr),
                     bgp_vpn_ip_print(ndo, pptr + BGP_VPN_RD_LEN,
                                      (route_length - BGP_VPN_RD_LEN) << 3));
            break;
        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI:
            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);
            offset = strlen(buf);
	    snprintf(buf + offset, buflen - offset, "", RD: %s, Source-AS %s"",
		bgp_vpn_rd_print(ndo, pptr),
		as_printf(ndo, astostr, sizeof(astostr),
		EXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));
            break;

        case BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI:
            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);
            offset = strlen(buf);
            snprintf(buf + offset, buflen - offset, "", RD: %s"",
                     bgp_vpn_rd_print(ndo, pptr));
            pptr += BGP_VPN_RD_LEN;

            sg_length = bgp_vpn_sg_print(ndo, pptr, buf, buflen);
            addr_length =  route_length - sg_length;

            ND_TCHECK2(pptr[0], addr_length);
            offset = strlen(buf);
            snprintf(buf + offset, buflen - offset, "", Originator %s"",
                     bgp_vpn_ip_print(ndo, pptr, addr_length << 3));
            break;

        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE:
            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);
            offset = strlen(buf);
            snprintf(buf + offset, buflen - offset, "", RD: %s"",
                     bgp_vpn_rd_print(ndo, pptr));
            pptr += BGP_VPN_RD_LEN;

            bgp_vpn_sg_print(ndo, pptr, buf, buflen);
            break;

        case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN: /* fall through */
        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:
            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);
            offset = strlen(buf);
	    snprintf(buf + offset, buflen - offset, "", RD: %s, Source-AS %s"",
		bgp_vpn_rd_print(ndo, pptr),
		as_printf(ndo, astostr, sizeof(astostr),
		EXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));
            pptr += BGP_VPN_RD_LEN;

            bgp_vpn_sg_print(ndo, pptr, buf, buflen);
            break;

            /*
             * no per route-type printing yet.
             */
        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF:
        default:
            break;
        }

        return route_length + 2;

trunc:
	return -2;
}",1,"['CWE-125', 'CWE-787']",tcpdump,d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514,196926756413329234999445618939450495147,85,"CVE-2017-13043/BGP: fix decoding of MVPN route types 6 and 7

RFC 6514 Section 4.6 defines the structure for Shared Tree Join (6) and
Source Tree Join (7) multicast VPN route types. decode_multicast_vpn()
didn't implement the Source AS field of that structure properly, adjust
the offsets to put it right.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-13043,CVE-2017-13043,{'CWE-125'},6.4,The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:decode_multicast_vpn().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514'},https://github.com/the-tcpdump-group/tcpdump/commit/d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514,SINGLE,['d10a0f980fe8f9407ab1ffbd612641433ebe175e'],1,d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514,"08/03/2017, 23:08:23",d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514,['d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514'],Denis Ovsienko,"CVE-2017-13043/BGP: fix decoding of MVPN route types 6 and 7

RFC 6514 Section 4.6 defines the structure for Shared Tree Join (6) and
Source Tree Join (7) multicast VPN route types. decode_multicast_vpn()
didn't implement the Source AS field of that structure properly, adjust
the offsets to put it right.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).","{'print-bgp.c': {'additions': 2, 'deletions': 2, 'changes': 4, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514/print-bgp.c', 'patch': '@@ -965,13 +965,13 @@ decode_multicast_vpn(netdissect_options *ndo,\n \n         case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN: /* fall through */\n         case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:\n-            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n+            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n             offset = strlen(buf);\n \t    snprintf(buf + offset, buflen - offset, "", RD: %s, Source-AS %s"",\n \t\tbgp_vpn_rd_print(ndo, pptr),\n \t\tas_printf(ndo, astostr, sizeof(astostr),\n \t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n-            pptr += BGP_VPN_RD_LEN;\n+            pptr += BGP_VPN_RD_LEN + 4;\n \n             bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n             break;'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514/tests%2FTESTLIST', 'patch': '@@ -564,6 +564,7 @@ hncp_dhcpv6data-oobr\thncp_dhcpv6data-oobr.pcap\thncp_dhcpv6data-oobr.out -v -c1\n hncp_dhcpv4data-oobr\thncp_dhcpv4data-oobr.pcap\thncp_dhcpv4data-oobr.out -v -c1\n vqp-oobr\t\tvqp-oobr.pcap\t\t\tvqp-oobr.out\t\t-v -c1\n bgp_pmsi_tunnel-oobr\tbgp_pmsi_tunnel-oobr.pcap\tbgp_pmsi_tunnel-oobr.out -v -c1\n+bgp_mvpn_6_and_7\tbgp_mvpn_6_and_7.pcap\t\tbgp_mvpn_6_and_7.out\t-v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out'}, 'tests/bgp_mvpn_6_and_7.out': {'additions': 13, 'deletions': 0, 'changes': 13, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514/tests%2Fbgp_mvpn_6_and_7.out', 'patch': '@@ -0,0 +1,13 @@\n+IP (tos 0xc, ttl 254, id 21263, offset 0, flags [rsvd], proto TCP (6), length 517, bad cksum 8e15 (->99c9)!)\n+    241.0.93.20.179 > 255.247.0.1.200: Flags [none], seq 2146691977:2146692450, win 56026, options [unknown-161,eol], length 473: BGP\n+\tUpdate Message (2), length: 45\n+\t  Withdrawn routes: 3 bytes\n+\t  Attribute Set (128), length: 7, Flags [OTPE+f]: \n+\t    Origin AS: 148\n+\t      Multi-Protocol Reach NLRI (14), length: 71, Flags [T+6]: \n+\t    AFI: IPv4 (1), SAFI: Multicast VPN (5), nh-length: 0, no SNPA\n+\t      Route-Type: Intra-AS I-PMSI (1), length: 0, RD: 62209:33686018 (= 2.2.2.2), Originator bogus address length 4294967232\n+\t      Route-Type: Unknown (0), length: 0\n+\t      Route-Type: Unknown (243), length: 1\n+\t      Route-Type: Inter-AS I-PMSI (2), length: 2, RD: unknown RD format, Source-AS 368115805\n+\t      Route-Type: Inter-AS I-PMSI (2), length: 2, RD: unknown RD format, Source-AS 335544320[|BGP]'}, 'tests/bgp_mvpn_6_and_7.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514/tests%2Fbgp_mvpn_6_and_7.pcap', 'patch': None}}",,"{'additions': 16, 'deletions': 2, 'total': 18}","{'c', 'pcap', 'out'}",{'C/C++'}
"handle_mlppp(netdissect_options *ndo,
             const u_char *p, int length)
{
    if (!ndo->ndo_eflag)
        ND_PRINT((ndo, ""MLPPP, ""));

    ND_PRINT((ndo, ""seq 0x%03x, Flags [%s], length %u"",
           (EXTRACT_16BITS(p))&0x0fff, /* only support 12-Bit sequence space for now */
           bittok2str(ppp_ml_flag_values, ""none"", *p & 0xc0),
           length));
}",1,"['CWE-125', 'CWE-787']",tcpdump,7335163a6ef82d46ff18f3e6099a157747241629,244854354035808041975337253967814306386,11,"CVE-2017-13038/PPP: Do bounds checking.

This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.

Add a test using the capture file supplied by Katie Holly.",CVE-2017-13038,CVE-2017-13038,{'CWE-125'},6.4,The PPP parser in tcpdump before 4.9.2 has a buffer over-read in print-ppp.c:handle_mlppp().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/7335163a6ef82d46ff18f3e6099a157747241629'},https://github.com/the-tcpdump-group/tcpdump/commit/7335163a6ef82d46ff18f3e6099a157747241629,SINGLE,['3cb7c9ac790752e2f06ae7d8f4da3c75c934584c'],1,7335163a6ef82d46ff18f3e6099a157747241629,"06/12/2017, 01:27:27",7335163a6ef82d46ff18f3e6099a157747241629,['7335163a6ef82d46ff18f3e6099a157747241629'],Guy Harris,"CVE-2017-13038/PPP: Do bounds checking.

This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.

Add a test using the capture file supplied by Katie Holly.","{'print-ppp.c': {'additions': 9, 'deletions': 0, 'changes': 9, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/7335163a6ef82d46ff18f3e6099a157747241629/print-ppp.c', 'patch': '@@ -811,6 +811,15 @@ handle_mlppp(netdissect_options *ndo,\n     if (!ndo->ndo_eflag)\n         ND_PRINT((ndo, ""MLPPP, ""));\n \n+    if (length < 2) {\n+        ND_PRINT((ndo, ""[|mlppp]""));\n+        return;\n+    }\n+    if (!ND_TTEST_16BITS(p)) {\n+        ND_PRINT((ndo, ""[|mlppp]""));\n+        return;\n+    }\n+\n     ND_PRINT((ndo, ""seq 0x%03x, Flags [%s], length %u"",\n            (EXTRACT_16BITS(p))&0x0fff, /* only support 12-Bit sequence space for now */\n            bittok2str(ppp_ml_flag_values, ""none"", *p & 0xc0),'}, 'tests/TESTLIST': {'additions': 3, 'deletions': 0, 'changes': 3, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/7335163a6ef82d46ff18f3e6099a157747241629/tests%2FTESTLIST', 'patch': '@@ -554,6 +554,9 @@ radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n ospf6_decode_v3_asan\tospf6_decode_v3_asan.pcap\tospf6_decode_v3_asan.out -v\n ip_ts_opts_asan\t\tip_ts_opts_asan.pcap\t\tip_ts_opts_asan.out\t-v\n \n+# bad packets from Katie Holly\n+mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out\n+\n # RTP tests\n # fuzzed pcap\n rtp-seg-fault-1  rtp-seg-fault-1.pcap  rtp-seg-fault-1.out  -v -T rtp'}, 'tests/mlppp-oobr.out': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/7335163a6ef82d46ff18f3e6099a157747241629/tests%2Fmlppp-oobr.out', 'patch': '@@ -0,0 +1 @@\n+MLPPP, [|mlppp]'}, 'tests/mlppp-oobr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/7335163a6ef82d46ff18f3e6099a157747241629/tests%2Fmlppp-oobr.pcap', 'patch': None}}",,"{'additions': 13, 'deletions': 0, 'total': 13}","{'c', 'pcap', 'out'}",{'C/C++'}
"print_attr_string(netdissect_options *ndo,
                  register const u_char *data, u_int length, u_short attr_code)
{
   register u_int i;

   ND_TCHECK2(data[0],length);

   switch(attr_code)
   {
      case TUNNEL_PASS:
           if (length < 3)
           {
              ND_PRINT((ndo, ""%s"", tstr));
              return;
           }
           if (*data && (*data <=0x1F) )
              ND_PRINT((ndo, ""Tag[%u] "", *data));
           else
              ND_PRINT((ndo, ""Tag[Unused] ""));
           data++;
           length--;
           ND_PRINT((ndo, ""Salt %u "", EXTRACT_16BITS(data)));
           data+=2;
           length-=2;
        break;
      case TUNNEL_CLIENT_END:
      case TUNNEL_SERVER_END:
      case TUNNEL_PRIV_GROUP:
      case TUNNEL_ASSIGN_ID:
      case TUNNEL_CLIENT_AUTH:
      case TUNNEL_SERVER_AUTH:
           if (*data <= 0x1F)
           {
              if (length < 1)
              {
                 ND_PRINT((ndo, ""%s"", tstr));
                 return;
              }
              if (*data)
                ND_PRINT((ndo, ""Tag[%u] "", *data));
              else
                ND_PRINT((ndo, ""Tag[Unused] ""));
              data++;
              length--;
           }
        break;
      case EGRESS_VLAN_NAME:
           ND_PRINT((ndo, ""%s (0x%02x) "",
                  tok2str(rfc4675_tagged,""Unknown tag"",*data),
                  *data));
           data++;
           length--;
        break;
   }

   for (i=0; *data && i < length ; i++, data++)
       ND_PRINT((ndo, ""%c"", (*data < 32 || *data > 126) ? '.' : *data));

   return;

   trunc:
      ND_PRINT((ndo, ""%s"", tstr));
}",1,"['CWE-125', 'CWE-787']",tcpdump,1bc78d795cd5cad5525498658f414a11ea0a7e9c,27524724880230921475897766476442607200,63,"CVE-2017-13032/RADIUS: Check whether a byte exists before testing its value.

Reverse the test in a for loop to test the length before testing whether
we have a null byte.

This fixes a buffer over-read discovered by Bhargava Shastry.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.

Clean up other length tests while we're at it.",CVE-2017-13032,CVE-2017-13032,{'CWE-125'},6.4,The RADIUS parser in tcpdump before 4.9.2 has a buffer over-read in print-radius.c:print_attr_string().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/1bc78d795cd5cad5525498658f414a11ea0a7e9c'},https://github.com/the-tcpdump-group/tcpdump/commit/1bc78d795cd5cad5525498658f414a11ea0a7e9c,SINGLE,['0f1735981d7ee78af277fab4c29da83a3ce4da5e'],1,1bc78d795cd5cad5525498658f414a11ea0a7e9c,"03/22/2017, 22:38:02",1bc78d795cd5cad5525498658f414a11ea0a7e9c,['1bc78d795cd5cad5525498658f414a11ea0a7e9c'],Guy Harris,"CVE-2017-13032/RADIUS: Check whether a byte exists before testing its value.

Reverse the test in a for loop to test the length before testing whether
we have a null byte.

This fixes a buffer over-read discovered by Bhargava Shastry.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.

Clean up other length tests while we're at it.","{'print-radius.c': {'additions': 5, 'deletions': 9, 'changes': 14, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/1bc78d795cd5cad5525498658f414a11ea0a7e9c/print-radius.c', 'patch': '@@ -503,10 +503,7 @@ print_attr_string(netdissect_options *ndo,\n    {\n       case TUNNEL_PASS:\n            if (length < 3)\n-           {\n-              ND_PRINT((ndo, ""%s"", tstr));\n-              return;\n-           }\n+              goto trunc;\n            if (*data && (*data <=0x1F) )\n               ND_PRINT((ndo, ""Tag[%u] "", *data));\n            else\n@@ -526,10 +523,7 @@ print_attr_string(netdissect_options *ndo,\n            if (*data <= 0x1F)\n            {\n               if (length < 1)\n-              {\n-                 ND_PRINT((ndo, ""%s"", tstr));\n-                 return;\n-              }\n+                 goto trunc;\n               if (*data)\n                 ND_PRINT((ndo, ""Tag[%u] "", *data));\n               else\n@@ -539,6 +533,8 @@ print_attr_string(netdissect_options *ndo,\n            }\n         break;\n       case EGRESS_VLAN_NAME:\n+           if (length < 1)\n+              goto trunc;\n            ND_PRINT((ndo, ""%s (0x%02x) "",\n                   tok2str(rfc4675_tagged,""Unknown tag"",*data),\n                   *data));\n@@ -547,7 +543,7 @@ print_attr_string(netdissect_options *ndo,\n         break;\n    }\n \n-   for (i=0; *data && i < length ; i++, data++)\n+   for (i=0; i < length && *data; i++, data++)\n        ND_PRINT((ndo, ""%c"", (*data < 32 || *data > 126) ? \'.\' : *data));\n \n    return;'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/1bc78d795cd5cad5525498658f414a11ea0a7e9c/tests%2FTESTLIST', 'patch': '@@ -541,6 +541,7 @@ pim_header_asan\t\tpim_header_asan.pcap\t\tpim_header_asan.out\t-v\n pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t-v\n pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t-v\n ip6_frag_asan\t\tip6_frag_asan.pcap\t\tip6_frag_asan.out\t-v\n+radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap'}, 'tests/radius_attr_asan.out': {'additions': 9, 'deletions': 0, 'changes': 9, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/1bc78d795cd5cad5525498658f414a11ea0a7e9c/tests%2Fradius_attr_asan.out', 'patch': '@@ -0,0 +1,9 @@\n+IP (tos 0x64, ttl 249, id 40192, offset 0, flags [+, DF, rsvd], proto UDP (17), length 299, options (unknown 235 [bad length 252]), bad cksum 8000 (->1faa)!)\n+    0.0.86.32.258 > 0.2.250.99.3799: RADIUS, length: 263\n+\tUnknown Command (58), id: 0x6a, Authenticator: 0901020ed7ff03edb63a0f00cb0f00cb\n+\t  NAS-Port Attribute (5), length: 5, Value: ERROR: length 3 != 4\n+\t  Unknown Attribute (127), length: 4, Value: \n+\t  NAS-IP-Address Attribute (4), length: 4, Value: ERROR: length 2 != 4\n+\t  NAS-IP-Address Attribute (4), length: 4, Value: ERROR: length 2 != 4\n+\t  NAS-IP-Address Attribute (4), length: 4, Value: ERROR: length 2 != 4\n+\t  Callback-Id Attribute (20), length: 4, Value: .. [|radius]'}, 'tests/radius_attr_asan.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/1bc78d795cd5cad5525498658f414a11ea0a7e9c/tests%2Fradius_attr_asan.pcap', 'patch': None}}",,"{'additions': 15, 'deletions': 9, 'total': 24}","{'c', 'pcap', 'out'}",{'C/C++'}
"lldp_private_8023_print(netdissect_options *ndo,
                        const u_char *tptr, u_int tlv_len)
{
    int subtype, hexdump = FALSE;

    if (tlv_len < 4) {
        return hexdump;
    }
    subtype = *(tptr+3);

    ND_PRINT((ndo, ""\n\t  %s Subtype (%u)"",
           tok2str(lldp_8023_subtype_values, ""unknown"", subtype),
           subtype));

    switch (subtype) {
    case LLDP_PRIVATE_8023_SUBTYPE_MACPHY:
        if (tlv_len < 9) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    autonegotiation [%s] (0x%02x)"",
               bittok2str(lldp_8023_autonegotiation_values, ""none"", *(tptr+4)),
               *(tptr + 4)));
        ND_PRINT((ndo, ""\n\t    PMD autoneg capability [%s] (0x%04x)"",
               bittok2str(lldp_pmd_capability_values,""unknown"", EXTRACT_16BITS(tptr+5)),
               EXTRACT_16BITS(tptr + 5)));
        ND_PRINT((ndo, ""\n\t    MAU type %s (0x%04x)"",
               tok2str(lldp_mau_types_values, ""unknown"", EXTRACT_16BITS(tptr+7)),
               EXTRACT_16BITS(tptr + 7)));
        break;

    case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER:
        if (tlv_len < 7) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    MDI power support [%s], power pair %s, power class %s"",
               bittok2str(lldp_mdi_values, ""none"", *(tptr+4)),
               tok2str(lldp_mdi_power_pairs_values, ""unknown"", *(tptr+5)),
               tok2str(lldp_mdi_power_class_values, ""unknown"", *(tptr + 6))));
        break;

    case LLDP_PRIVATE_8023_SUBTYPE_LINKAGGR:
        if (tlv_len < 9) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    aggregation status [%s], aggregation port ID %u"",
               bittok2str(lldp_aggregation_values, ""none"", *(tptr+4)),
               EXTRACT_32BITS(tptr + 5)));
        break;

    case LLDP_PRIVATE_8023_SUBTYPE_MTU:
        ND_PRINT((ndo, ""\n\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));
        break;

    default:
        hexdump = TRUE;
        break;
    }

    return hexdump;
}",1,"['CWE-125', 'CWE-787']",tcpdump,e6511cc1a950fe1566b2236329d6b4bd0826cc7a,112885099028047697678752065937320477724,60,"CVE-2017-13054/LLDP: add a missing length check

In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame
Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length
check and could over-read the input buffer, put it right.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-13054,CVE-2017-13054,{'CWE-125'},6.4,The LLDP parser in tcpdump before 4.9.2 has a buffer over-read in print-lldp.c:lldp_private_8023_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/e6511cc1a950fe1566b2236329d6b4bd0826cc7a'},https://github.com/the-tcpdump-group/tcpdump/commit/e6511cc1a950fe1566b2236329d6b4bd0826cc7a,SINGLE,['83c64fce3a5226b080e535f5131a8a318f30e79b'],1,e6511cc1a950fe1566b2236329d6b4bd0826cc7a,"08/09/2017, 23:01:55",e6511cc1a950fe1566b2236329d6b4bd0826cc7a,['e6511cc1a950fe1566b2236329d6b4bd0826cc7a'],Denis Ovsienko,"CVE-2017-13054/LLDP: add a missing length check

In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame
Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length
check and could over-read the input buffer, put it right.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).","{'print-lldp.c': {'additions': 3, 'deletions': 0, 'changes': 3, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/e6511cc1a950fe1566b2236329d6b4bd0826cc7a/print-lldp.c', 'patch': '@@ -898,6 +898,9 @@ lldp_private_8023_print(netdissect_options *ndo,\n         break;\n \n     case LLDP_PRIVATE_8023_SUBTYPE_MTU:\n+        if (tlv_len < 6) {\n+            return hexdump;\n+        }\n         ND_PRINT((ndo, ""\\n\\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));\n         break;'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/e6511cc1a950fe1566b2236329d6b4bd0826cc7a/tests%2FTESTLIST', 'patch': '@@ -571,6 +571,7 @@ rsvp_uni-oobr-1\trsvp_uni-oobr-1.pcap\trsvp_uni-oobr-1.out\t-v -c1\n rsvp_uni-oobr-2\trsvp_uni-oobr-2.pcap\trsvp_uni-oobr-2.out\t-v -c1\n rsvp_uni-oobr-3\trsvp_uni-oobr-3.pcap\trsvp_uni-oobr-3.out\t-v -c3\n rpki-rtr-oob\t\trpki-rtr-oob.pcap\trpki-rtr-oob.out\t-v -c1\n+lldp_8023_mtu-oobr\tlldp_8023_mtu-oobr.pcap\tlldp_8023_mtu-oobr.out\t-v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out'}, 'tests/lldp_8023_mtu-oobr.out': {'additions': 4, 'deletions': 0, 'changes': 4, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/e6511cc1a950fe1566b2236329d6b4bd0826cc7a/tests%2Flldp_8023_mtu-oobr.out', 'patch': '@@ -0,0 +1,4 @@\n+LLDP, length 4293194266\n+\tOrganization specific TLV (127), length 4: OUI IEEE 802.3 Private (0x00120f)\n+\t  Max frame size Subtype (4)\n+\t[|LLDP]'}, 'tests/lldp_8023_mtu-oobr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/e6511cc1a950fe1566b2236329d6b4bd0826cc7a/tests%2Flldp_8023_mtu-oobr.pcap', 'patch': None}}",,"{'additions': 8, 'deletions': 0, 'total': 8}","{'c', 'pcap', 'out'}",{'C/C++'}
"isis_print_is_reach_subtlv(netdissect_options *ndo,
                           const uint8_t *tptr, u_int subt, u_int subl,
                           const char *ident)
{
        u_int te_class,priority_level,gmpls_switch_cap;
        union { /* int to float conversion buffer for several subTLVs */
            float f;
            uint32_t i;
        } bw;

        /* first lets see if we know the subTLVs name*/
	ND_PRINT((ndo, ""%s%s subTLV #%u, length: %u"",
	          ident, tok2str(isis_ext_is_reach_subtlv_values, ""unknown"", subt),
	          subt, subl));

	ND_TCHECK2(*tptr, subl);

        switch(subt) {
        case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP:
        case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID:
        case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID:
	    if (subl >= 4) {
	      ND_PRINT((ndo, "", 0x%08x"", EXTRACT_32BITS(tptr)));
	      if (subl == 8) /* rfc4205 */
	        ND_PRINT((ndo, "", 0x%08x"", EXTRACT_32BITS(tptr+4)));
	    }
	    break;
        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR:
        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR:
            if (subl >= sizeof(struct in_addr))
              ND_PRINT((ndo, "", %s"", ipaddr_string(ndo, tptr)));
            break;
        case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW :
	case ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW:
            if (subl >= 4) {
              bw.i = EXTRACT_32BITS(tptr);
              ND_PRINT((ndo, "", %.3f Mbps"", bw.f * 8 / 1000000));
            }
            break;
        case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW :
            if (subl >= 32) {
              for (te_class = 0; te_class < 8; te_class++) {
                bw.i = EXTRACT_32BITS(tptr);
                ND_PRINT((ndo, ""%s  TE-Class %u: %.3f Mbps"",
                       ident,
                       te_class,
                       bw.f * 8 / 1000000));
		tptr+=4;
	      }
            }
            break;
        case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: /* fall through */
        case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD:
            ND_PRINT((ndo, ""%sBandwidth Constraints Model ID: %s (%u)"",
                   ident,
                   tok2str(diffserv_te_bc_values, ""unknown"", *tptr),
                   *tptr));
            tptr++;
            /* decode BCs until the subTLV ends */
            for (te_class = 0; te_class < (subl-1)/4; te_class++) {
                ND_TCHECK2(*tptr, 4);
                bw.i = EXTRACT_32BITS(tptr);
                ND_PRINT((ndo, ""%s  Bandwidth constraint CT%u: %.3f Mbps"",
                       ident,
                       te_class,
                       bw.f * 8 / 1000000));
		tptr+=4;
            }
            break;
        case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC:
            if (subl >= 3)
              ND_PRINT((ndo, "", %u"", EXTRACT_24BITS(tptr)));
            break;
        case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE:
            if (subl == 2) {
               ND_PRINT((ndo, "", [ %s ] (0x%04x)"",
                      bittok2str(isis_subtlv_link_attribute_values,
                                 ""Unknown"",
                                 EXTRACT_16BITS(tptr)),
                      EXTRACT_16BITS(tptr)));
            }
            break;
        case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE:
            if (subl >= 2) {
              ND_PRINT((ndo, "", %s, Priority %u"",
		   bittok2str(gmpls_link_prot_values, ""none"", *tptr),
                   *(tptr+1)));
            }
            break;
        case ISIS_SUBTLV_SPB_METRIC:
            if (subl >= 6) {
              ND_PRINT((ndo, "", LM: %u"", EXTRACT_24BITS(tptr)));
              tptr=tptr+3;
              ND_PRINT((ndo, "", P: %u"", *(tptr)));
              tptr++;
              ND_PRINT((ndo, "", P-ID: %u"", EXTRACT_16BITS(tptr)));
            }
            break;
        case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR:
            if (subl >= 36) {
              gmpls_switch_cap = *tptr;
              ND_PRINT((ndo, ""%s  Interface Switching Capability:%s"",
                   ident,
                   tok2str(gmpls_switch_cap_values, ""Unknown"", gmpls_switch_cap)));
              ND_PRINT((ndo, "", LSP Encoding: %s"",
                   tok2str(gmpls_encoding_values, ""Unknown"", *(tptr + 1))));
	      tptr+=4;
              ND_PRINT((ndo, ""%s  Max LSP Bandwidth:"", ident));
              for (priority_level = 0; priority_level < 8; priority_level++) {
                bw.i = EXTRACT_32BITS(tptr);
                ND_PRINT((ndo, ""%s    priority level %d: %.3f Mbps"",
                       ident,
                       priority_level,
                       bw.f * 8 / 1000000));
		tptr+=4;
              }
              subl-=36;
              switch (gmpls_switch_cap) {
              case GMPLS_PSC1:
              case GMPLS_PSC2:
              case GMPLS_PSC3:
              case GMPLS_PSC4:
                ND_TCHECK2(*tptr, 6);
                bw.i = EXTRACT_32BITS(tptr);
                ND_PRINT((ndo, ""%s  Min LSP Bandwidth: %.3f Mbps"", ident, bw.f * 8 / 1000000));
                ND_PRINT((ndo, ""%s  Interface MTU: %u"", ident, EXTRACT_16BITS(tptr + 4)));
                break;
              case GMPLS_TSC:
                ND_TCHECK2(*tptr, 8);
                bw.i = EXTRACT_32BITS(tptr);
                ND_PRINT((ndo, ""%s  Min LSP Bandwidth: %.3f Mbps"", ident, bw.f * 8 / 1000000));
                ND_PRINT((ndo, ""%s  Indication %s"", ident,
                       tok2str(gmpls_switch_cap_tsc_indication_values, ""Unknown (%u)"", *(tptr + 4))));
                break;
              default:
                /* there is some optional stuff left to decode but this is as of yet
                   not specified so just lets hexdump what is left */
                if(subl>0){
                  if (!print_unknown_data(ndo, tptr, ""\n\t\t    "", subl))
                    return(0);
                }
              }
            }
            break;
        default:
            if (!print_unknown_data(ndo, tptr, ""\n\t\t    "", subl))
                return(0);
            break;
        }
        return(1);

trunc:
    return(0);
}",1,"['CWE-125', 'CWE-787']",tcpdump,5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e,301315777931496171051980814379630287884,154,"CVE-2017-13055/IS-IS: fix an Extended IS Reachability sub-TLV

In isis_print_is_reach_subtlv() one of the case blocks did not check that
the sub-TLV ""V"" is actually present and could over-read the input buffer.
Add a length check to fix that and remove a useless boundary check from
a loop because the boundary is tested for the full length of ""V"" before
the switch block.

Update one of the prior test cases as it turns out it depended on this
previously incorrect code path to make it to its own malformed structure
further down the buffer, the bugfix has changed its output.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-13055,CVE-2017-13055,{'CWE-125'},6.4,The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_is_reach_subtlv().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e'},https://github.com/the-tcpdump-group/tcpdump/commit/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e,SINGLE,['5d340a5ca6e420a70297cdbdf777333f18bfdab7'],1,5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e,"08/16/2017, 22:04:31",5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e,['5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e'],Denis Ovsienko,"CVE-2017-13055/IS-IS: fix an Extended IS Reachability sub-TLV

In isis_print_is_reach_subtlv() one of the case blocks did not check that
the sub-TLV ""V"" is actually present and could over-read the input buffer.
Add a length check to fix that and remove a useless boundary check from
a loop because the boundary is tested for the full length of ""V"" before
the switch block.

Update one of the prior test cases as it turns out it depended on this
previously incorrect code path to make it to its own malformed structure
further down the buffer, the bugfix has changed its output.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s).","{'print-isoclns.c': {'additions': 2, 'deletions': 1, 'changes': 3, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e/print-isoclns.c', 'patch': '@@ -1861,14 +1861,15 @@ isis_print_is_reach_subtlv(netdissect_options *ndo,\n             break;\n         case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: /* fall through */\n         case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD:\n+            if (subl == 0)\n+                break;\n             ND_PRINT((ndo, ""%sBandwidth Constraints Model ID: %s (%u)"",\n                    ident,\n                    tok2str(diffserv_te_bc_values, ""unknown"", *tptr),\n                    *tptr));\n             tptr++;\n             /* decode BCs until the subTLV ends */\n             for (te_class = 0; te_class < (subl-1)/4; te_class++) {\n-                ND_TCHECK2(*tptr, 4);\n                 bw.i = EXTRACT_32BITS(tptr);\n                 ND_PRINT((ndo, ""%s  Bandwidth constraint CT%u: %.3f Mbps"",\n                        ident,'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e/tests%2FTESTLIST', 'patch': '@@ -574,6 +574,7 @@ rpki-rtr-oob\t\trpki-rtr-oob.pcap\trpki-rtr-oob.out\t-v -c1\n lldp_8023_mtu-oobr\tlldp_8023_mtu-oobr.pcap\tlldp_8023_mtu-oobr.out\t-v -c1\n bgp_vpn_rt-oobr\tbgp_vpn_rt-oobr.pcap\tbgp_vpn_rt-oobr.out\t-v -c1\n cfm_sender_id-oobr\tcfm_sender_id-oobr.pcap\tcfm_sender_id-oobr.out\t-v -c1\n+isis-extd-isreach-oobr\tisis-extd-isreach-oobr.pcap\tisis-extd-isreach-oobr.out -v -c4\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out'}, 'tests/isis-extd-isreach-oobr.out': {'additions': 39, 'deletions': 0, 'changes': 39, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e/tests%2Fisis-extd-isreach-oobr.out', 'patch': '@@ -0,0 +1,39 @@\n+OSI NLPID 0xfe unknown, length: 33554428\n+\t0x0000:  fe7f 4a01 0066 0002 00ff ffff f200 0000\n+\t0x0010:  00c6 0000 007f e6ff 00e6 6800 0000\n+unknown CHDLC protocol (0xfafe)\n+OSI NLPID 0xfe unknown, length: 33554428\n+\t0x0000:  fe7f 4a01 f165 0002 0000 0000 0000 0000\n+\t0x0010:  00c6 0000 007f e6ff 00e6 6800 0000\n+IS-IS, length 33554427\n+\tL2 Lan IIH, hlen: 27, v: 1, pdu-v: 1, sys-id-len: 6 (0), max-area: 3 (0)\n+\t  source-id: 3801.0101.0101,  holding time: 257s, Flags: [unknown circuit type 0x00]\n+\t  lan-id:    0101.0101.0100.00, Priority: 1, PDU length: 257\n+\t    Extended IS Reachability TLV #22, length: 12\n+\t      IS Neighbor: 0d0d.0d0d.0d0d.0d, Metric: 855309, sub-TLVs present (13)\n+\t        unknown subTLV #13, length: 13\n+\t\t    0x0000:  0d0d 0d0d 0d0d 0d0d 0d0d 0d0d 0d\n+\t      IS Neighbor: 0d0d.0d0d.0d0d.0d, Metric: 855309, sub-TLVs present (13)\n+\t        unknown subTLV #13, length: 13\n+\t\t    0x0000:  0d0d 0d0d 0d0d 0d64 0d0d 0d0d 0d\n+\t      IS Neighbor: 0d0d.0d0d.0d0d.0d, Metric: 855309, sub-TLVs present (13)\n+\t        unknown subTLV #13, length: 13\n+\t\t    0x0000:  0d0d 0d0d 0d0d 0d0d 0d0d 0d0d 0d\n+\t      IS Neighbor: 0d0d.0d0d.0d0d.0d, Metric: 855309, sub-TLVs present (13)\n+\t        unknown subTLV #13, length: 13\n+\t\t    0x0000:  1c0d 0d0d 0d0d 670d 0d0d 0d0d 0d\n+\t      IS Neighbor: 0d0d.0d00.0000.40, Metric: 13391955, sub-TLVs present (3)\n+\t        unknown subTLV #41, length: 16\n+\t\t    0x0000:  0022 0000 0000 0000 0000 0000 0000 0000\n+\t      IS Neighbor: 0000.0000.0a16.00, Metric: 2097279, no sub-TLVs present\n+\t      IS Neighbor: 0000.3604.1f01.16, Metric: 70400, no sub-TLVs present\n+\t      IS Neighbor: 0012.3a01.4996.01, Metric: 8838496, no sub-TLVs present\n+\t      IS Neighbor: 00c7.8787.8766.87, Metric: 0, sub-TLVs present (64)\n+\t        unknown subTLV #120, length: 22\n+\t\t    0x0000:  0101 0100 f0ff ffff ff01 0101 434c 4945\n+\t\t    0x0010:  4e54 0101 011f\n+\t        Link Local/Remote Identifier subTLV #4, length: 4, 0x04040404\n+\t        Link Local/Remote Identifier subTLV #4, length: 4, 0x04040404\n+\t        Link Local/Remote Identifier subTLV #4, length: 4, 0x0404000a\n+\t        Bandwidth Constraints subTLV #22, length: 0\n+\t\t [|isis]'}, 'tests/isis-extd-isreach-oobr.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e/tests%2Fisis-extd-isreach-oobr.pcap', 'patch': None}, 'tests/isis-seg-fault-1-v.out': {'additions': 152, 'deletions': 271, 'changes': 423, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e/tests%2Fisis-seg-fault-1-v.out', 'patch': '@@ -28,274 +28,155 @@ IS-IS, length 1497\n \t        unknown subTLV #0, length: 0\n \t        unknown subTLV #0, length: 0\n \t        Bandwidth Constraints subTLV #22, length: 0\n-\t        Bandwidth Constraints Model ID: Russian dolls (0)\n-\t          Bandwidth constraint CT0: 0.000 Mbps\n-\t          Bandwidth constraint CT1: 0.000 Mbps\n-\t          Bandwidth constraint CT2: 0.000 Mbps\n-\t          Bandwidth constraint CT3: 0.000 Mbps\n-\t          Bandwidth constraint CT4: 0.000 Mbps\n-\t          Bandwidth constraint CT5: 0.000 Mbps\n-\t          Bandwidth constraint CT6: -0.000 Mbps\n-\t          Bandwidth constraint CT7: 0.000 Mbps\n-\t          Bandwidth constraint CT8: 0.000 Mbps\n-\t          Bandwidth constraint CT9: 0.000 Mbps\n-\t          Bandwidth constraint CT10: 0.000 Mbps\n-\t          Bandwidth constraint CT11: 0.000 Mbps\n-\t          Bandwidth constraint CT12: 0.000 Mbps\n-\t          Bandwidth constraint CT13: 0.000 Mbps\n-\t          Bandwidth constraint CT14: -1267650597027719304708096.000 Mbps\n-\t          Bandwidth constraint CT15: 0.000 Mbps\n-\t          Bandwidth constraint CT16: 0.000 Mbps\n-\t          Bandwidth constraint CT17: 0.000 Mbps\n-\t          Bandwidth constraint CT18: 0.000 Mbps\n-\t          Bandwidth constraint CT19: 0.000 Mbps\n-\t          Bandwidth constraint CT20: 0.000 Mbps\n-\t          Bandwidth constraint CT21: 0.000 Mbps\n-\t          Bandwidth constraint CT22: 0.000 Mbps\n-\t          Bandwidth constraint CT23: 0.000 Mbps\n-\t          Bandwidth constraint CT24: 0.000 Mbps\n-\t          Bandwidth constraint CT25: 0.000 Mbps\n-\t          Bandwidth constraint CT26: 0.000 Mbps\n-\t          Bandwidth constraint CT27: 0.000 Mbps\n-\t          Bandwidth constraint CT28: 0.000 Mbps\n-\t          Bandwidth constraint CT29: 0.000 Mbps\n-\t          Bandwidth constraint CT30: 0.000 Mbps\n-\t          Bandwidth constraint CT31: 0.000 Mbps\n-\t          Bandwidth constraint CT32: 0.000 Mbps\n-\t          Bandwidth constraint CT33: 0.000 Mbps\n-\t          Bandwidth constraint CT34: 0.000 Mbps\n-\t          Bandwidth constraint CT35: 0.000 Mbps\n-\t          Bandwidth constraint CT36: 0.000 Mbps\n-\t          Bandwidth constraint CT37: 0.000 Mbps\n-\t          Bandwidth constraint CT38: 16.777 Mbps\n-\t          Bandwidth constraint CT39: 0.000 Mbps\n-\t          Bandwidth constraint CT40: 0.000 Mbps\n-\t          Bandwidth constraint CT41: 0.000 Mbps\n-\t          Bandwidth constraint CT42: 0.000 Mbps\n-\t          Bandwidth constraint CT43: 0.000 Mbps\n-\t          Bandwidth constraint CT44: 0.000 Mbps\n-\t          Bandwidth constraint CT45: 0.000 Mbps\n-\t          Bandwidth constraint CT46: 0.000 Mbps\n-\t          Bandwidth constraint CT47: 0.000 Mbps\n-\t          Bandwidth constraint CT48: 0.000 Mbps\n-\t          Bandwidth constraint CT49: 0.000 Mbps\n-\t          Bandwidth constraint CT50: 0.000 Mbps\n-\t          Bandwidth constraint CT51: 0.000 Mbps\n-\t          Bandwidth constraint CT52: 0.000 Mbps\n-\t          Bandwidth constraint CT53: 0.000 Mbps\n-\t          Bandwidth constraint CT54: 0.000 Mbps\n-\t          Bandwidth constraint CT55: 0.000 Mbps\n-\t          Bandwidth constraint CT56: 0.000 Mbps\n-\t          Bandwidth constraint CT57: 0.000 Mbps\n-\t          Bandwidth constraint CT58: 0.000 Mbps\n-\t          Bandwidth constraint CT59: 0.000 Mbps\n-\t          Bandwidth constraint CT60: 0.000 Mbps\n-\t          Bandwidth constraint CT61: 0.000 Mbps\n-\t          Bandwidth constraint CT62: 0.000 Mbps\n-\t          Bandwidth constraint CT63: 0.000 Mbps\n-\t          Bandwidth constraint CT64: 0.000 Mbps\n-\t          Bandwidth constraint CT65: 0.000 Mbps\n-\t          Bandwidth constraint CT66: 0.000 Mbps\n-\t          Bandwidth constraint CT67: 0.000 Mbps\n-\t          Bandwidth constraint CT68: 0.000 Mbps\n-\t          Bandwidth constraint CT69: 0.000 Mbps\n-\t          Bandwidth constraint CT70: 0.000 Mbps\n-\t          Bandwidth constraint CT71: 0.000 Mbps\n-\t          Bandwidth constraint CT72: 0.000 Mbps\n-\t          Bandwidth constraint CT73: 0.000 Mbps\n-\t          Bandwidth constraint CT74: 0.000 Mbps\n-\t          Bandwidth constraint CT75: 0.000 Mbps\n-\t          Bandwidth constraint CT76: 0.000 Mbps\n-\t          Bandwidth constraint CT77: 0.000 Mbps\n-\t          Bandwidth constraint CT78: 0.000 Mbps\n-\t          Bandwidth constraint CT79: 0.000 Mbps\n-\t          Bandwidth constraint CT80: 0.000 Mbps\n-\t          Bandwidth constraint CT81: 0.000 Mbps\n-\t          Bandwidth constraint CT82: 0.000 Mbps\n-\t          Bandwidth constraint CT83: 0.000 Mbps\n-\t          Bandwidth constraint CT84: 0.000 Mbps\n-\t          Bandwidth constraint CT85: 0.000 Mbps\n-\t          Bandwidth constraint CT86: 0.000 Mbps\n-\t          Bandwidth constraint CT87: 0.000 Mbps\n-\t          Bandwidth constraint CT88: 0.000 Mbps\n-\t          Bandwidth constraint CT89: 0.000 Mbps\n-\t          Bandwidth constraint CT90: 0.000 Mbps\n-\t          Bandwidth constraint CT91: 0.000 Mbps\n-\t          Bandwidth constraint CT92: 0.000 Mbps\n-\t          Bandwidth constraint CT93: 0.000 Mbps\n-\t          Bandwidth constraint CT94: 0.000 Mbps\n-\t          Bandwidth constraint CT95: 0.000 Mbps\n-\t          Bandwidth constraint CT96: 0.000 Mbps\n-\t          Bandwidth constraint CT97: 0.000 Mbps\n-\t          Bandwidth constraint CT98: 0.000 Mbps\n-\t          Bandwidth constraint CT99: 0.000 Mbps\n-\t          Bandwidth constraint CT100: 0.000 Mbps\n-\t          Bandwidth constraint CT101: 0.000 Mbps\n-\t          Bandwidth constraint CT102: 0.000 Mbps\n-\t          Bandwidth constraint CT103: 0.000 Mbps\n-\t          Bandwidth constraint CT104: 0.000 Mbps\n-\t          Bandwidth constraint CT105: 0.000 Mbps\n-\t          Bandwidth constraint CT106: 0.000 Mbps\n-\t          Bandwidth constraint CT107: 0.000 Mbps\n-\t          Bandwidth constraint CT108: 0.000 Mbps\n-\t          Bandwidth constraint CT109: 0.000 Mbps\n-\t          Bandwidth constraint CT110: 334903128525925002608918921216.000 Mbps\n-\t          Bandwidth constraint CT111: 0.000 Mbps\n-\t          Bandwidth constraint CT112: 0.000 Mbps\n-\t          Bandwidth constraint CT113: 0.000 Mbps\n-\t          Bandwidth constraint CT114: 0.000 Mbps\n-\t          Bandwidth constraint CT115: 0.000 Mbps\n-\t          Bandwidth constraint CT116: 0.000 Mbps\n-\t          Bandwidth constraint CT117: 0.000 Mbps\n-\t          Bandwidth constraint CT118: 0.000 Mbps\n-\t          Bandwidth constraint CT119: 0.000 Mbps\n-\t          Bandwidth constraint CT120: 0.000 Mbps\n-\t          Bandwidth constraint CT121: 0.000 Mbps\n-\t          Bandwidth constraint CT122: 0.000 Mbps\n-\t          Bandwidth constraint CT123: 0.000 Mbps\n-\t          Bandwidth constraint CT124: 0.000 Mbps\n-\t          Bandwidth constraint CT125: 0.000 Mbps\n-\t          Bandwidth constraint CT126: 0.000 Mbps\n-\t          Bandwidth constraint CT127: 0.000 Mbps\n-\t          Bandwidth constraint CT128: 0.000 Mbps\n-\t          Bandwidth constraint CT129: 0.000 Mbps\n-\t          Bandwidth constraint CT130: 0.000 Mbps\n-\t          Bandwidth constraint CT131: 0.000 Mbps\n-\t          Bandwidth constraint CT132: 0.000 Mbps\n-\t          Bandwidth constraint CT133: 0.000 Mbps\n-\t          Bandwidth constraint CT134: 0.000 Mbps\n-\t          Bandwidth constraint CT135: 0.000 Mbps\n-\t          Bandwidth constraint CT136: 0.000 Mbps\n-\t          Bandwidth constraint CT137: -4.194 Mbps\n-\t          Bandwidth constraint CT138: 0.000 Mbps\n-\t          Bandwidth constraint CT139: 0.000 Mbps\n-\t          Bandwidth constraint CT140: 0.000 Mbps\n-\t          Bandwidth constraint CT141: 0.000 Mbps\n-\t          Bandwidth constraint CT142: 0.000 Mbps\n-\t          Bandwidth constraint CT143: 0.000 Mbps\n-\t          Bandwidth constraint CT144: 0.000 Mbps\n-\t          Bandwidth constraint CT145: 0.000 Mbps\n-\t          Bandwidth constraint CT146: 0.000 Mbps\n-\t          Bandwidth constraint CT147: 0.000 Mbps\n-\t          Bandwidth constraint CT148: 0.000 Mbps\n-\t          Bandwidth constraint CT149: 0.000 Mbps\n-\t          Bandwidth constraint CT150: 0.000 Mbps\n-\t          Bandwidth constraint CT151: 0.000 Mbps\n-\t          Bandwidth constraint CT152: 0.000 Mbps\n-\t          Bandwidth constraint CT153: 0.000 Mbps\n-\t          Bandwidth constraint CT154: 16.777 Mbps\n-\t          Bandwidth constraint CT155: 0.000 Mbps\n-\t          Bandwidth constraint CT156: 0.000 Mbps\n-\t          Bandwidth constraint CT157: 0.000 Mbps\n-\t          Bandwidth constraint CT158: 0.000 Mbps\n-\t          Bandwidth constraint CT159: 0.000 Mbps\n-\t          Bandwidth constraint CT160: 0.000 Mbps\n-\t          Bandwidth constraint CT161: 0.000 Mbps\n-\t          Bandwidth constraint CT162: 0.000 Mbps\n-\t          Bandwidth constraint CT163: 0.000 Mbps\n-\t          Bandwidth constraint CT164: 0.000 Mbps\n-\t          Bandwidth constraint CT165: 0.000 Mbps\n-\t          Bandwidth constraint CT166: 0.000 Mbps\n-\t          Bandwidth constraint CT167: 0.000 Mbps\n-\t          Bandwidth constraint CT168: 0.000 Mbps\n-\t          Bandwidth constraint CT169: 0.000 Mbps\n-\t          Bandwidth constraint CT170: 0.000 Mbps\n-\t          Bandwidth constraint CT171: 0.000 Mbps\n-\t          Bandwidth constraint CT172: 0.000 Mbps\n-\t          Bandwidth constraint CT173: 0.000 Mbps\n-\t          Bandwidth constraint CT174: 0.000 Mbps\n-\t          Bandwidth constraint CT175: 0.000 Mbps\n-\t          Bandwidth constraint CT176: 0.000 Mbps\n-\t          Bandwidth constraint CT177: 0.000 Mbps\n-\t          Bandwidth constraint CT178: 0.000 Mbps\n-\t          Bandwidth constraint CT179: 1099511.625 Mbps\n-\t          Bandwidth constraint CT180: 0.000 Mbps\n-\t          Bandwidth constraint CT181: 0.000 Mbps\n-\t          Bandwidth constraint CT182: 0.000 Mbps\n-\t          Bandwidth constraint CT183: 0.000 Mbps\n-\t          Bandwidth constraint CT184: 0.000 Mbps\n-\t          Bandwidth constraint CT185: 0.000 Mbps\n-\t          Bandwidth constraint CT186: 0.000 Mbps\n-\t          Bandwidth constraint CT187: 0.000 Mbps\n-\t          Bandwidth constraint CT188: 0.000 Mbps\n-\t          Bandwidth constraint CT189: 0.000 Mbps\n-\t          Bandwidth constraint CT190: 0.000 Mbps\n-\t          Bandwidth constraint CT191: 0.000 Mbps\n-\t          Bandwidth constraint CT192: 0.000 Mbps\n-\t          Bandwidth constraint CT193: 0.000 Mbps\n-\t          Bandwidth constraint CT194: 0.000 Mbps\n-\t          Bandwidth constraint CT195: 0.000 Mbps\n-\t          Bandwidth constraint CT196: 0.000 Mbps\n-\t          Bandwidth constraint CT197: 0.000 Mbps\n-\t          Bandwidth constraint CT198: 0.000 Mbps\n-\t          Bandwidth constraint CT199: 0.000 Mbps\n-\t          Bandwidth constraint CT200: 0.000 Mbps\n-\t          Bandwidth constraint CT201: 0.000 Mbps\n-\t          Bandwidth constraint CT202: 0.000 Mbps\n-\t          Bandwidth constraint CT203: 0.000 Mbps\n-\t          Bandwidth constraint CT204: 0.000 Mbps\n-\t          Bandwidth constraint CT205: 0.000 Mbps\n-\t          Bandwidth constraint CT206: 0.000 Mbps\n-\t          Bandwidth constraint CT207: 0.000 Mbps\n-\t          Bandwidth constraint CT208: 0.000 Mbps\n-\t          Bandwidth constraint CT209: 0.000 Mbps\n-\t          Bandwidth constraint CT210: 0.000 Mbps\n-\t          Bandwidth constraint CT211: 0.000 Mbps\n-\t          Bandwidth constraint CT212: 0.000 Mbps\n-\t          Bandwidth constraint CT213: 0.000 Mbps\n-\t          Bandwidth constraint CT214: 0.000 Mbps\n-\t          Bandwidth constraint CT215: 0.000 Mbps\n-\t          Bandwidth constraint CT216: 0.000 Mbps\n-\t          Bandwidth constraint CT217: 0.000 Mbps\n-\t          Bandwidth constraint CT218: 0.000 Mbps\n-\t          Bandwidth constraint CT219: 0.000 Mbps\n-\t          Bandwidth constraint CT220: 0.000 Mbps\n-\t          Bandwidth constraint CT221: 0.000 Mbps\n-\t          Bandwidth constraint CT222: 0.000 Mbps\n-\t          Bandwidth constraint CT223: 0.000 Mbps\n-\t          Bandwidth constraint CT224: 0.000 Mbps\n-\t          Bandwidth constraint CT225: 0.000 Mbps\n-\t          Bandwidth constraint CT226: 0.000 Mbps\n-\t          Bandwidth constraint CT227: 0.000 Mbps\n-\t          Bandwidth constraint CT228: 0.000 Mbps\n-\t          Bandwidth constraint CT229: 0.000 Mbps\n-\t          Bandwidth constraint CT230: -0.000 Mbps\n-\t          Bandwidth constraint CT231: 0.000 Mbps\n-\t          Bandwidth constraint CT232: 0.000 Mbps\n-\t          Bandwidth constraint CT233: 0.000 Mbps\n-\t          Bandwidth constraint CT234: 0.000 Mbps\n-\t          Bandwidth constraint CT235: 0.000 Mbps\n-\t          Bandwidth constraint CT236: 0.000 Mbps\n-\t          Bandwidth constraint CT237: 0.000 Mbps\n-\t          Bandwidth constraint CT238: 0.000 Mbps\n-\t          Bandwidth constraint CT239: 0.000 Mbps\n-\t          Bandwidth constraint CT240: 0.000 Mbps\n-\t          Bandwidth constraint CT241: 0.000 Mbps\n-\t          Bandwidth constraint CT242: 0.000 Mbps\n-\t          Bandwidth constraint CT243: 0.000 Mbps\n-\t          Bandwidth constraint CT244: 0.000 Mbps\n-\t          Bandwidth constraint CT245: 0.000 Mbps\n-\t          Bandwidth constraint CT246: 0.000 Mbps\n-\t          Bandwidth constraint CT247: 0.000 Mbps\n-\t          Bandwidth constraint CT248: 0.000 Mbps\n-\t          Bandwidth constraint CT249: 0.000 Mbps\n-\t          Bandwidth constraint CT250: 0.000 Mbps\n-\t          Bandwidth constraint CT251: 0.000 Mbps\n-\t          Bandwidth constraint CT252: 0.000 Mbps\n-\t          Bandwidth constraint CT253: 0.000 Mbps\n-\t          Bandwidth constraint CT254: 0.000 Mbps\n-\t          Bandwidth constraint CT255: 0.000 Mbps\n-\t          Bandwidth constraint CT256: 0.000 Mbps\n-\t          Bandwidth constraint CT257: 0.000 Mbps\n-\t          Bandwidth constraint CT258: 0.000 Mbps\n-\t          Bandwidth constraint CT259: 0.000 Mbps\n-\t          Bandwidth constraint CT260: 0.000 Mbps\n-\t          Bandwidth constraint CT261: 0.000 Mbps\n-\t          Bandwidth constraint CT262: 0.000 Mbps\n-\t          Bandwidth constraint CT263: 0.000 Mbps\n-\t          Bandwidth constraint CT264: 0.000 Mbps\n-\t          Bandwidth constraint CT265: 0.000 Mbps\n-\t          Bandwidth constraint CT266: 0.000 Mbps\n-\t          Bandwidth constraint CT267: 0.000 Mbps\n-\t          Bandwidth constraint CT268: 0.000 Mbps\n-\t\t [|isis]\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #64, length: 0\n+\t        unknown subTLV #0, length: 189\n+\t\t    0x0000:  0000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0010:  00c2 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0020:  0000 0000 0000 0000 0000 0000 0020 0000\n+\t\t    0x0030:  00f0 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0040:  0000 0000 0000 0000 0000 0000 5900 0000\n+\t\t    0x0050:  0000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0060:  0000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0070:  0000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0080:  0000 0000 0000 0000 0000 7d00 0008 ff00\n+\t\t    0x0090:  004a 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x00a0:  8000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x00b0:  0000 0000 0000 0000 0000 0000 00\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 3400.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.2302.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0069.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0200.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0067.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, sub-TLVs present (37)\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 7800.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0065.00, sub-TLVs present (128)\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #66, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 8\n+\t\t    0x0000:  0000 0008 ff00 0000\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #121, length: 1\n+\t\t    0x0000:  00\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #50, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #132, length: 8\n+\t\t    0x0000:  0000 0000 0000 0000\n+\t        unknown subTLV #0, length: 0\n+\t      IS Neighbor: 8900.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 2500.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.2500.0000.c9, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0008.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: f700.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.004f.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 3d00.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0080.0002.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.007e.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t    Padding TLV #8, length: 255\n+\t    Padding TLV #8, length: 255\n+\t    Padding TLV #8, length: 247\n+\t    unknown TLV #0, length: 0\n+\t    unknown TLV #0, length: 0\n+\t    unknown TLV #0, length: 0\n+\t    unknown TLV #0, length: 0\n+\t    Padding TLV #8, length: 155'}}",,"{'additions': 194, 'deletions': 272, 'total': 466}","{'c', 'pcap', 'out'}",{'C/C++'}
"eap_print(netdissect_options *ndo,
          register const u_char *cp,
          u_int length)
{
    const struct eap_frame_t *eap;
    const u_char *tptr;
    u_int tlen, type, subtype;
    int count=0, len;

    tptr = cp;
    tlen = length;
    eap = (const struct eap_frame_t *)cp;
    ND_TCHECK(*eap);

    /* in non-verbose mode just lets print the basic info */
    if (ndo->ndo_vflag < 1) {
	ND_PRINT((ndo, ""%s (%u) v%u, len %u"",
               tok2str(eap_frame_type_values, ""unknown"", eap->type),
               eap->type,
               eap->version,
               EXTRACT_16BITS(eap->length)));
	return;
    }

    ND_PRINT((ndo, ""%s (%u) v%u, len %u"",
           tok2str(eap_frame_type_values, ""unknown"", eap->type),
           eap->type,
           eap->version,
           EXTRACT_16BITS(eap->length)));

    tptr += sizeof(const struct eap_frame_t);
    tlen -= sizeof(const struct eap_frame_t);

    switch (eap->type) {
    case EAP_FRAME_TYPE_PACKET:
        type = *(tptr);
        len = EXTRACT_16BITS(tptr+2);
        ND_PRINT((ndo, "", %s (%u), id %u, len %u"",
               tok2str(eap_code_values, ""unknown"", type),
               type,
               *(tptr+1),
               len));

        ND_TCHECK2(*tptr, len);

        if (type <= 2) { /* For EAP_REQUEST and EAP_RESPONSE only */
            subtype = *(tptr+4);
            ND_PRINT((ndo, ""\n\t\t Type %s (%u)"",
                   tok2str(eap_type_values, ""unknown"", *(tptr+4)),
                   *(tptr + 4)));

            switch (subtype) {
            case EAP_TYPE_IDENTITY:
                if (len - 5 > 0) {
                    ND_PRINT((ndo, "", Identity: ""));
                    safeputs(ndo, tptr + 5, len - 5);
                }
                break;

            case EAP_TYPE_NOTIFICATION:
                if (len - 5 > 0) {
                    ND_PRINT((ndo, "", Notification: ""));
                    safeputs(ndo, tptr + 5, len - 5);
                }
                break;

            case EAP_TYPE_NAK:
                count = 5;

                /*
                 * one or more octets indicating
                 * the desired authentication
                 * type one octet per type
                 */
                while (count < len) {
                    ND_PRINT((ndo, "" %s (%u),"",
                           tok2str(eap_type_values, ""unknown"", *(tptr+count)),
                           *(tptr + count)));
                    count++;
                }
                break;

            case EAP_TYPE_TTLS:
                ND_PRINT((ndo, "" TTLSv%u"",
                       EAP_TTLS_VERSION(*(tptr + 5)))); /* fall through */
            case EAP_TYPE_TLS:
                ND_PRINT((ndo, "" flags [%s] 0x%02x,"",
                       bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)),
                       *(tptr + 5)));

                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {
		    ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
                }
                break;

            case EAP_TYPE_FAST:
                ND_PRINT((ndo, "" FASTv%u"",
                       EAP_TTLS_VERSION(*(tptr + 5))));
                ND_PRINT((ndo, "" flags [%s] 0x%02x,"",
                       bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)),
                       *(tptr + 5)));

                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {
                    ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
                }

                /* FIXME - TLV attributes follow */
                break;

            case EAP_TYPE_AKA:
            case EAP_TYPE_SIM:
                ND_PRINT((ndo, "" subtype [%s] 0x%02x,"",
                       tok2str(eap_aka_subtype_values, ""unknown"", *(tptr+5)),
                       *(tptr + 5)));

                /* FIXME - TLV attributes follow */
                break;

            case EAP_TYPE_MD5_CHALLENGE:
            case EAP_TYPE_OTP:
            case EAP_TYPE_GTC:
            case EAP_TYPE_EXPANDED_TYPES:
            case EAP_TYPE_EXPERIMENTAL:
            default:
                break;
            }
        }
        break;

    case EAP_FRAME_TYPE_LOGOFF:
    case EAP_FRAME_TYPE_ENCAP_ASF_ALERT:
    default:
        break;
    }
    return;

 trunc:
    ND_PRINT((ndo, ""\n\t[|EAP]""));
}",1,"['CWE-125', 'CWE-787']",tcpdump,985122081165753c7442bd7824c473eb9ff56308,147246368263633124568420248823056497014,139,"CVE-2017-13015/EAP: Add more bounds checks.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.",CVE-2017-13015,CVE-2017-13015,{'CWE-125'},6.4,The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/985122081165753c7442bd7824c473eb9ff56308'},https://github.com/the-tcpdump-group/tcpdump/commit/985122081165753c7442bd7824c473eb9ff56308,SINGLE,['cc356512f512e7fa423b3674db4bb31dbe40ffec'],1,985122081165753c7442bd7824c473eb9ff56308,"03/16/2017, 19:02:20",985122081165753c7442bd7824c473eb9ff56308,['985122081165753c7442bd7824c473eb9ff56308'],Guy Harris,"CVE-2017-13015/EAP: Add more bounds checks.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.","{'print-eap.c': {'additions': 14, 'deletions': 4, 'changes': 18, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/985122081165753c7442bd7824c473eb9ff56308/print-eap.c', 'patch': '@@ -182,7 +182,9 @@ eap_print(netdissect_options *ndo,\n \n     switch (eap->type) {\n     case EAP_FRAME_TYPE_PACKET:\n+        ND_TCHECK_8BITS(tptr);\n         type = *(tptr);\n+        ND_TCHECK_16BITS(tptr+2);\n         len = EXTRACT_16BITS(tptr+2);\n         ND_PRINT((ndo, "", %s (%u), id %u, len %u"",\n                tok2str(eap_code_values, ""unknown"", type),\n@@ -193,10 +195,11 @@ eap_print(netdissect_options *ndo,\n         ND_TCHECK2(*tptr, len);\n \n         if (type <= 2) { /* For EAP_REQUEST and EAP_RESPONSE only */\n+            ND_TCHECK_8BITS(tptr+4);\n             subtype = *(tptr+4);\n             ND_PRINT((ndo, ""\\n\\t\\t Type %s (%u)"",\n-                   tok2str(eap_type_values, ""unknown"", *(tptr+4)),\n-                   *(tptr + 4)));\n+                   tok2str(eap_type_values, ""unknown"", subtype),\n+                   subtype));\n \n             switch (subtype) {\n             case EAP_TYPE_IDENTITY:\n@@ -222,6 +225,7 @@ eap_print(netdissect_options *ndo,\n                  * type one octet per type\n                  */\n                 while (count < len) {\n+                    ND_TCHECK_8BITS(tptr+count);\n                     ND_PRINT((ndo, "" %s (%u),"",\n                            tok2str(eap_type_values, ""unknown"", *(tptr+count)),\n                            *(tptr + count)));\n@@ -230,26 +234,31 @@ eap_print(netdissect_options *ndo,\n                 break;\n \n             case EAP_TYPE_TTLS:\n-                ND_PRINT((ndo, "" TTLSv%u"",\n-                       EAP_TTLS_VERSION(*(tptr + 5)))); /* fall through */\n             case EAP_TYPE_TLS:\n+                ND_TCHECK_8BITS(tptr + 5);\n+                if (subtype == EAP_TYPE_TTLS)\n+                    ND_PRINT((ndo, "" TTLSv%u"",\n+                           EAP_TTLS_VERSION(*(tptr + 5))));\n                 ND_PRINT((ndo, "" flags [%s] 0x%02x,"",\n                        bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)),\n                        *(tptr + 5)));\n \n                 if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {\n+                    ND_TCHECK_32BITS(tptr + 6);\n \t\t    ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));\n                 }\n                 break;\n \n             case EAP_TYPE_FAST:\n+                ND_TCHECK_8BITS(tptr + 5);\n                 ND_PRINT((ndo, "" FASTv%u"",\n                        EAP_TTLS_VERSION(*(tptr + 5))));\n                 ND_PRINT((ndo, "" flags [%s] 0x%02x,"",\n                        bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)),\n                        *(tptr + 5)));\n \n                 if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {\n+                    ND_TCHECK_32BITS(tptr + 6);\n                     ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));\n                 }\n \n@@ -258,6 +267,7 @@ eap_print(netdissect_options *ndo,\n \n             case EAP_TYPE_AKA:\n             case EAP_TYPE_SIM:\n+                ND_TCHECK_8BITS(tptr + 5);\n                 ND_PRINT((ndo, "" subtype [%s] 0x%02x,"",\n                        tok2str(eap_aka_subtype_values, ""unknown"", *(tptr+5)),\n                        *(tptr + 5)));'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/985122081165753c7442bd7824c473eb9ff56308/tests%2FTESTLIST', 'patch': '@@ -512,6 +512,7 @@ wb-oobr\t\t\twb-oobr.pcap\t\t\twb-oobr.out\t-v\n lldp_asan\t\tlldp_asan.pcap\t\t\tlldp_asan.out\t-v\n extract_read2_asan\textract_read2_asan.pcap\t\textract_read2_asan.out\t-v\n getname_2_read4_asan\tgetname_2_read4_asan.pcap\tgetname_2_read4_asan.out\t-v\n+eap_extract_read2_asan\teap_extract_read2_asan.pcap\teap_extract_read2_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap'}, 'tests/eap_extract_read2_asan.out': {'additions': 2, 'deletions': 0, 'changes': 2, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/985122081165753c7442bd7824c473eb9ff56308/tests%2Feap_extract_read2_asan.out', 'patch': '@@ -0,0 +1,2 @@\n+EAP packet (0) v155, len 0\n+\t[|EAP]'}, 'tests/eap_extract_read2_asan.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/985122081165753c7442bd7824c473eb9ff56308/tests%2Feap_extract_read2_asan.pcap', 'patch': None}}",,"{'additions': 17, 'deletions': 4, 'total': 21}","{'c', 'pcap', 'out'}",{'C/C++'}
"isis_print_id(const uint8_t *cp, int id_len)
{
    int i;
    static char id[sizeof(""xxxx.xxxx.xxxx.yy-zz"")];
    char *pos = id;

    for (i = 1; i <= SYSTEM_ID_LEN; i++) {
        snprintf(pos, sizeof(id) - (pos - id), ""%02x"", *cp++);
	pos += strlen(pos);
	if (i == 2 || i == 4)
	    *pos++ = '.';
	}
    if (id_len >= NODE_ID_LEN) {
        snprintf(pos, sizeof(id) - (pos - id), "".%02x"", *cp++);
	pos += strlen(pos);
    }
    if (id_len == LSP_ID_LEN)
        snprintf(pos, sizeof(id) - (pos - id), ""-%02x"", *cp);
    return (id);
}",1,"['CWE-125', 'CWE-787']",tcpdump,571a6f33f47e7a2394fa08f925e534135c29cf1e,11368313297091407506664895854998378609,20,"CVE-2017-13035/Properly handle IS-IS IDs shorter than a system ID (MAC address).

Some of them are variable-length, with a field giving the total length,
and therefore they can be shorter than 6 octets.  If one is, don't run
past the end.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.",CVE-2017-13035,CVE-2017-13035,{'CWE-125'},6.4,The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_id().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/571a6f33f47e7a2394fa08f925e534135c29cf1e'},https://github.com/the-tcpdump-group/tcpdump/commit/571a6f33f47e7a2394fa08f925e534135c29cf1e,SINGLE,['da6f1a677bfa4476abaeaf9b1afe1c4390f51b41'],1,571a6f33f47e7a2394fa08f925e534135c29cf1e,"03/23/2017, 21:37:56",571a6f33f47e7a2394fa08f925e534135c29cf1e,['571a6f33f47e7a2394fa08f925e534135c29cf1e'],Guy Harris,"CVE-2017-13035/Properly handle IS-IS IDs shorter than a system ID (MAC address).

Some of them are variable-length, with a field giving the total length,
and therefore they can be shorter than 6 octets.  If one is, don't run
past the end.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.","{'print-isoclns.c': {'additions': 5, 'deletions': 1, 'changes': 6, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/571a6f33f47e7a2394fa08f925e534135c29cf1e/print-isoclns.c', 'patch': '@@ -1646,8 +1646,12 @@ isis_print_id(const uint8_t *cp, int id_len)\n     int i;\n     static char id[sizeof(""xxxx.xxxx.xxxx.yy-zz"")];\n     char *pos = id;\n+    int sysid_len;\n \n-    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n+    sysid_len = SYSTEM_ID_LEN;\n+    if (sysid_len > id_len)\n+        sysid_len = id_len;\n+    for (i = 1; i <= sysid_len; i++) {\n         snprintf(pos, sizeof(id) - (pos - id), ""%02x"", *cp++);\n \tpos += strlen(pos);\n \tif (i == 2 || i == 4)'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/571a6f33f47e7a2394fa08f925e534135c29cf1e/tests%2FTESTLIST', 'patch': '@@ -539,6 +539,7 @@ isis_stlv_asan\t\tisis_stlv_asan.pcap\t\tisis_stlv_asan.out\t-v\n isis_stlv_asan-2\tisis_stlv_asan-2.pcap\t\tisis_stlv_asan-2.out\t-v\n isis_stlv_asan-3\tisis_stlv_asan-3.pcap\t\tisis_stlv_asan-3.out\t-v\n isis_stlv_asan-4\tisis_stlv_asan-4.pcap\t\tisis_stlv_asan-4.out\t-v\n+isis_sysid_asan\t\tisis_sysid_asan.pcap\t\tisis_sysid_asan.out\t-v\n lldp_mgmt_addr_tlv_asan\tlldp_mgmt_addr_tlv_asan.pcap\tlldp_mgmt_addr_tlv_asan.out\t-v\n bootp_asan\t\tbootp_asan.pcap\t\t\tbootp_asan.out\t\t-v\n bootp_asan-2\t\tbootp_asan-2.pcap\t\tbootp_asan-2.out\t-v'}, 'tests/isis_sysid_asan.out': {'additions': 71, 'deletions': 0, 'changes': 71, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/571a6f33f47e7a2394fa08f925e534135c29cf1e/tests%2Fisis_sysid_asan.out', 'patch': '@@ -0,0 +1,71 @@\n+UI 22! IS-IS, length 469869187\n+\tL2 Lan IIH, hlen: 27, v: 1, pdu-v: 1, sys-id-len: 6 (0), max-area: 224 (224)\n+\t  source-id: fed0.f90f.58af,  holding time: 34047s, Flags: [unknown circuit type 0x00]\n+\t  lan-id:    0105.0088.a204.00, Priority: 65, PDU length: 4096\n+\t    unknown TLV #64, length: 128\n+\t\t0x0000:  ff10 8e12 0001 1b01 0000 6b00 fbcf f90f\n+\t\t0x0010:  58af 84ff 1000 4901 0000 88a2 011c 000c\n+\t\t0x0020:  0281 0083 1b01 0010 019d e000 fed0 f90f\n+\t\t0x0030:  58af 84ff 1000 4101 0500 88a2 011c 0272\n+\t\t0x0040:  0c2a 2205 831b 011c 0010 0000 0583 1b01\n+\t\t0x0050:  0010 01ab e000 fe08 0808 0808 08cb 0808\n+\t\t0x0060:  0808 0808 0808 0880 0008 7f08 0808 0808\n+\t\t0x0070:  08fd 0808 080c 0608 0807 0808 0808 0408\n+\t    Padding TLV #8, length: 8\n+\t    Padding TLV #8, length: 8\n+\t    Padding TLV #8, length: 7\n+\t    Padding TLV #8, length: 8\n+\t    Padding TLV #8, length: 0\n+\t    Padding TLV #8, length: 8\n+\t    unknown TLV #100, length: 0\n+\t    unknown TLV #32, length: 16\n+\t\t0x0000:  2020 2020 3c20 2020 2020 2020 205a 1a31\n+\t    IS Neighbor(s) (variable length) TLV #7, length: 238\n+\t      LAN address length 1 bytes \n+\t\tIS Neighbor: 5a\n+\t\tIS Neighbor: 45\n+\t\tIS Neighbor: 50\n+\t\tIS Neighbor: 48\n+\t\tIS Neighbor: 59\n+\t\tIS Neighbor: 52\n+\t\tIS Neighbor: 5f\n+\t\tIS Neighbor: 43\n+\t\tIS Neighbor: 54\n+\t\tIS Neighbor: 4c\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 64\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 10\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20 [|isis]'}, 'tests/isis_sysid_asan.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/571a6f33f47e7a2394fa08f925e534135c29cf1e/tests%2Fisis_sysid_asan.pcap', 'patch': None}}",,"{'additions': 77, 'deletions': 1, 'total': 78}","{'c', 'pcap', 'out'}",{'C/C++'}
"pktap_if_print(netdissect_options *ndo,
               const struct pcap_pkthdr *h, const u_char *p)
{
	uint32_t dlt, hdrlen, rectype;
	u_int caplen = h->caplen;
	u_int length = h->len;
	if_printer printer;
	const pktap_header_t *hdr;

	if (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {
		ND_PRINT((ndo, ""[|pktap]""));
		return (0);
	}
	hdr = (const pktap_header_t *)p;
	dlt = EXTRACT_LE_32BITS(&hdr->pkt_dlt);
	hdrlen = EXTRACT_LE_32BITS(&hdr->pkt_len);
	if (hdrlen < sizeof(pktap_header_t)) {
		/*
		 * Claimed header length < structure length.
		 * XXX - does this just mean some fields aren't
		 * being supplied, or is it truly an error (i.e.,
		 * is the length supplied so that the header can
		 * be expanded in the future)?
		 */
		ND_PRINT((ndo, ""[|pktap]""));
		return (0);
	}
	if (caplen < hdrlen || length < hdrlen) {
		ND_PRINT((ndo, ""[|pktap]""));
		return (hdrlen);
	}

	if (ndo->ndo_eflag)
		pktap_header_print(ndo, p, length);

	length -= hdrlen;
	caplen -= hdrlen;
	p += hdrlen;

	rectype = EXTRACT_LE_32BITS(&hdr->pkt_rectype);
	switch (rectype) {

	case PKT_REC_NONE:
		ND_PRINT((ndo, ""no data""));
		break;

	case PKT_REC_PACKET:
		if ((printer = lookup_printer(dlt)) != NULL) {
			hdrlen += printer(ndo, h, p);
		} else {
			if (!ndo->ndo_eflag)
				pktap_header_print(ndo, (const u_char *)hdr,
						length + hdrlen);

			if (!ndo->ndo_suppress_default_print)
				ND_DEFAULTPRINT(p, caplen);
		}
		break;
	}

	return (hdrlen);
}",1,"['CWE-125', 'CWE-787']",tcpdump,ca336198e8bebccc18502de27672fdbd6eb34856,165915244467436054193177047528287418792,62,"CVE-2017-13007/PKTAP: Pass a properly updated struct pcap_pkthdr to the sub-dissector.

The sub-dissector expects that the length and captured length will
reflect the actual remaining data in the packet, not the raw amount
including the PKTAP header; pass an updated header, just as we do for
PPI.

This fixes a buffer over-read discovered by Yannick Formaggio.

Add a test using the capture file supplied by the reporter(s).",CVE-2017-13007,CVE-2017-13007,{'CWE-125'},6.4,The Apple PKTAP parser in tcpdump before 4.9.2 has a buffer over-read in print-pktap.c:pktap_if_print().,2017-09-14,NVD,0.0,1.0,https://github.com/the-tcpdump-group/tcpdump,{'https://github.com/the-tcpdump-group/tcpdump/commit/ca336198e8bebccc18502de27672fdbd6eb34856'},https://github.com/the-tcpdump-group/tcpdump/commit/ca336198e8bebccc18502de27672fdbd6eb34856,SINGLE,['cc4a7391c616be7a64ed65742ef9ed3f106eb165'],1,ca336198e8bebccc18502de27672fdbd6eb34856,"03/06/2017, 04:21:48",ca336198e8bebccc18502de27672fdbd6eb34856,['ca336198e8bebccc18502de27672fdbd6eb34856'],Guy Harris,"CVE-2017-13007/PKTAP: Pass a properly updated struct pcap_pkthdr to the sub-dissector.

The sub-dissector expects that the length and captured length will
reflect the actual remaining data in the packet, not the raw amount
including the PKTAP header; pass an updated header, just as we do for
PPI.

This fixes a buffer over-read discovered by Yannick Formaggio.

Add a test using the capture file supplied by the reporter(s).","{'print-pktap.c': {'additions': 5, 'deletions': 1, 'changes': 6, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/ca336198e8bebccc18502de27672fdbd6eb34856/print-pktap.c', 'patch': '@@ -104,6 +104,7 @@ pktap_if_print(netdissect_options *ndo,\n \tu_int length = h->len;\n \tif_printer printer;\n \tconst pktap_header_t *hdr;\n+\tstruct pcap_pkthdr nhdr;\n \n \tif (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {\n \t\tND_PRINT((ndo, ""[|pktap]""));\n@@ -144,7 +145,10 @@ pktap_if_print(netdissect_options *ndo,\n \n \tcase PKT_REC_PACKET:\n \t\tif ((printer = lookup_printer(dlt)) != NULL) {\n-\t\t\thdrlen += printer(ndo, h, p);\n+\t\t\tnhdr = *h;\n+\t\t\tnhdr.caplen = caplen;\n+\t\t\tnhdr.len = length;\n+\t\t\thdrlen += printer(ndo, &nhdr, p);\n \t\t} else {\n \t\t\tif (!ndo->ndo_eflag)\n \t\t\t\tpktap_header_print(ndo, (const u_char *)hdr,'}, 'tests/TESTLIST': {'additions': 1, 'deletions': 0, 'changes': 1, 'status': 'modified', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/ca336198e8bebccc18502de27672fdbd6eb34856/tests%2FTESTLIST', 'patch': '@@ -502,6 +502,7 @@ juniper_es\t\tjuniper_es.pcap\t\t\tjuniper_es.out\t-vvv -e\n \n # bad packets from Yannick Formaggio\n l2tp-avp-overflow\tl2tp-avp-overflow.pcap\t\tl2tp-avp-overflow.out\t-v\n+pktap-heap-overflow\tpktap-heap-overflow.pcap\tpktap-heap-overflow.out\t-v\n \n # RTP tests\n # fuzzed pcap'}, 'tests/pktap-heap-overflow.out': {'additions': 3, 'deletions': 0, 'changes': 3, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/ca336198e8bebccc18502de27672fdbd6eb34856/tests%2Fpktap-heap-overflow.out', 'patch': '@@ -0,0 +1,3 @@\n+[|pktap]\n+[|ppp]\n+EXIT CODE 00000100'}, 'tests/pktap-heap-overflow.pcap': {'additions': 0, 'deletions': 0, 'changes': 0, 'status': 'added', 'raw_url': 'https://github.com/the-tcpdump-group/tcpdump/raw/ca336198e8bebccc18502de27672fdbd6eb34856/tests%2Fpktap-heap-overflow.pcap', 'patch': None}}",,"{'additions': 9, 'deletions': 1, 'total': 10}","{'c', 'pcap', 'out'}",{'C/C++'}
